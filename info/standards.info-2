This is ../info/standards.info, produced by makeinfo version 4.0 from
standards.texi.

START-INFO-DIR-ENTRY
* Standards: (standards).        GNU coding standards.
END-INFO-DIR-ENTRY

   GNU Coding Standards Copyright (C) 1992, 1993, 1994, 1995, 1996,
1997, 1998, 1999, 2000 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: standards.info,  Node: Formatting,  Next: Comments,  Up: Writing C

Formatting Your Source Code
===========================

   It is important to put the open-brace that starts the body of a C
function in column zero, and avoid putting any other open-brace or
open-parenthesis or open-bracket in column zero.  Several tools look
for open-braces in column zero to find the beginnings of C functions.
These tools will not work on code not formatted that way.

   It is also important for function definitions to start the name of
the function in column zero.  This helps people to search for function
definitions, and may also help certain tools recognize them.  Thus, the
proper format is this:

     static char *
     concat (s1, s2)        /* Name starts in column zero here */
          char *s1, *s2;
     {                     /* Open brace in column zero here */
       ...
     }

or, if you want to use Standard C syntax, format the definition like
this:

     static char *
     concat (char *s1, char *s2)
     {
       ...
     }

   In Standard C, if the arguments don't fit nicely on one line, split
it like this:

     int
     lots_of_args (int an_integer, long a_long, short a_short,
                   double a_double, float a_float)
     ...

   The rest of this section gives our recommendations for other aspects
of C formatting style, which is also the default style of the `indent'
program in version 1.2 and newer.  It corresponds to the options

     -nbad -bap -nbc -bbo -bl -bli2 -bls -ncdb -nce -cp1 -cs -di2
     -ndj -nfc1 -nfca -hnl -i2 -ip5 -lp -pcs -psl -nsc -nsob

   We don't think of these recommendations as requirements, because it
causes no problems for users if two different programs have different
formatting styles.

   But whatever style you use, please use it consistently, since a
mixture of styles within one program tends to look ugly.  If you are
contributing changes to an existing program, please follow the style of
that program.

   For the body of the function, our recommended style looks like this:

     if (x < foo (y, z))
       haha = bar[4] + 5;
     else
       {
         while (z)
           {
             haha += foo (z, z);
             z--;
           }
         return ++x + bar ();
       }

   We find it easier to read a program when it has spaces before the
open-parentheses and after the commas.  Especially after the commas.

   When you split an expression into multiple lines, split it before an
operator, not after one.  Here is the right way:

     if (foo_this_is_long && bar > win (x, y, z)
         && remaining_condition)

   Try to avoid having two operators of different precedence at the same
level of indentation.  For example, don't write this:

     mode = (inmode[j] == VOIDmode
             || GET_MODE_SIZE (outmode[j]) > GET_MODE_SIZE (inmode[j])
             ? outmode[j] : inmode[j]);

   Instead, use extra parentheses so that the indentation shows the
nesting:

     mode = ((inmode[j] == VOIDmode
              || (GET_MODE_SIZE (outmode[j]) > GET_MODE_SIZE (inmode[j])))
             ? outmode[j] : inmode[j]);

   Insert extra parentheses so that Emacs will indent the code properly.
For example, the following indentation looks nice if you do it by hand,

     v = rup->ru_utime.tv_sec*1000 + rup->ru_utime.tv_usec/1000
         + rup->ru_stime.tv_sec*1000 + rup->ru_stime.tv_usec/1000;

but Emacs would alter it.  Adding a set of parentheses produces
something that looks equally nice, and which Emacs will preserve:

     v = (rup->ru_utime.tv_sec*1000 + rup->ru_utime.tv_usec/1000
          + rup->ru_stime.tv_sec*1000 + rup->ru_stime.tv_usec/1000);

   Format do-while statements like this:

     do
       {
         a = foo (a);
       }
     while (a > 0);

   Please use formfeed characters (control-L) to divide the program into
pages at logical places (but not within a function).  It does not matter
just how long the pages are, since they do not have to fit on a printed
page.  The formfeeds should appear alone on lines by themselves.


File: standards.info,  Node: Comments,  Next: Syntactic Conventions,  Prev: Formatting,  Up: Writing C

Commenting Your Work
====================

   Every program should start with a comment saying briefly what it is
for.  Example: `fmt - filter for simple filling of text'.

   Please write the comments in a GNU program in English, because
English is the one language that nearly all programmers in all
countries can read.  If you do not write English well, please write
comments in English as well as you can, then ask other people to help
rewrite them.  If you can't write comments in English, please find
someone to work with you and translate your comments into English.

   Please put a comment on each function saying what the function does,
what sorts of arguments it gets, and what the possible values of
arguments mean and are used for.  It is not necessary to duplicate in
words the meaning of the C argument declarations, if a C type is being
used in its customary fashion.  If there is anything nonstandard about
its use (such as an argument of type `char *' which is really the
address of the second character of a string, not the first), or any
possible values that would not work the way one would expect (such as,
that strings containing newlines are not guaranteed to work), be sure
to say so.

   Also explain the significance of the return value, if there is one.

   Please put two spaces after the end of a sentence in your comments,
so that the Emacs sentence commands will work.  Also, please write
complete sentences and capitalize the first word.  If a lower-case
identifier comes at the beginning of a sentence, don't capitalize it!
Changing the spelling makes it a different identifier.  If you don't
like starting a sentence with a lower case letter, write the sentence
differently (e.g., "The identifier lower-case is ...").

   The comment on a function is much clearer if you use the argument
names to speak about the argument values.  The variable name itself
should be lower case, but write it in upper case when you are speaking
about the value rather than the variable itself.  Thus, "the inode
number NODE_NUM" rather than "an inode".

   There is usually no purpose in restating the name of the function in
the comment before it, because the reader can see that for himself.
There might be an exception when the comment is so long that the
function itself would be off the bottom of the screen.

   There should be a comment on each static variable as well, like this:

     /* Nonzero means truncate lines in the display;
        zero means continue them.  */
     int truncate_lines;

   Every `#endif' should have a comment, except in the case of short
conditionals (just a few lines) that are not nested.  The comment should
state the condition of the conditional that is ending, _including its
sense_.  `#else' should have a comment describing the condition _and
sense_ of the code that follows.  For example:

     #ifdef foo
       ...
     #else /* not foo */
       ...
     #endif /* not foo */
     #ifdef foo
       ...
     #endif /* foo */

but, by contrast, write the comments this way for a `#ifndef':

     #ifndef foo
       ...
     #else /* foo */
       ...
     #endif /* foo */
     #ifndef foo
       ...
     #endif /* not foo */


File: standards.info,  Node: Syntactic Conventions,  Next: Names,  Prev: Comments,  Up: Writing C

Clean Use of C Constructs
=========================

   Please explicitly declare the types of all objects.  For example, you
should explicitly declare all arguments to functions, and you should
declare functions to return `int' rather than omitting the `int'.

   Some programmers like to use the GCC `-Wall' option, and change the
code whenever it issues a warning.  If you want to do this, then do.
Other programmers prefer not to use `-Wall', because it gives warnings
for valid and legitimate code which they do not want to change.  If you
want to do this, then do.  The compiler should be your servant, not
your master.

   Declarations of external functions and functions to appear later in
the source file should all go in one place near the beginning of the
file (somewhere before the first function definition in the file), or
else should go in a header file.  Don't put `extern' declarations inside
functions.

   It used to be common practice to use the same local variables (with
names like `tem') over and over for different values within one
function.  Instead of doing this, it is better declare a separate local
variable for each distinct purpose, and give it a name which is
meaningful.  This not only makes programs easier to understand, it also
facilitates optimization by good compilers.  You can also move the
declaration of each local variable into the smallest scope that includes
all its uses.  This makes the program even cleaner.

   Don't use local variables or parameters that shadow global
identifiers.

   Don't declare multiple variables in one declaration that spans lines.
Start a new declaration on each line, instead.  For example, instead of
this:

     int    foo,
            bar;

write either this:

     int foo, bar;

or this:

     int foo;
     int bar;

(If they are global variables, each should have a comment preceding it
anyway.)

   When you have an `if'-`else' statement nested in another `if'
statement, always put braces around the `if'-`else'.  Thus, never write
like this:

     if (foo)
       if (bar)
         win ();
       else
         lose ();

always like this:

     if (foo)
       {
         if (bar)
           win ();
         else
           lose ();
       }

   If you have an `if' statement nested inside of an `else' statement,
either write `else if' on one line, like this,

     if (foo)
       ...
     else if (bar)
       ...

with its `then'-part indented like the preceding `then'-part, or write
the nested `if' within braces like this:

     if (foo)
       ...
     else
       {
         if (bar)
           ...
       }

   Don't declare both a structure tag and variables or typedefs in the
same declaration.  Instead, declare the structure tag separately and
then use it to declare the variables or typedefs.

   Try to avoid assignments inside `if'-conditions.  For example, don't
write this:

     if ((foo = (char *) malloc (sizeof *foo)) == 0)
       fatal ("virtual memory exhausted");

instead, write this:

     foo = (char *) malloc (sizeof *foo);
     if (foo == 0)
       fatal ("virtual memory exhausted");

   Don't make the program ugly to placate `lint'.  Please don't insert
any casts to `void'.  Zero without a cast is perfectly fine as a null
pointer constant, except when calling a varargs function.


File: standards.info,  Node: Names,  Next: System Portability,  Prev: Syntactic Conventions,  Up: Writing C

Naming Variables and Functions
==============================

   The names of global variables and functions in a program serve as
comments of a sort.  So don't choose terse names--instead, look for
names that give useful information about the meaning of the variable or
function.  In a GNU program, names should be English, like other
comments.

   Local variable names can be shorter, because they are used only
within one context, where (presumably) comments explain their purpose.

   Try to limit your use of abbreviations in symbol names.  It is ok to
make a few abbreviations, explain what they mean, and then use them
frequently, but don't use lots of obscure abbreviations.

   Please use underscores to separate words in a name, so that the Emacs
word commands can be useful within them.  Stick to lower case; reserve
upper case for macros and `enum' constants, and for name-prefixes that
follow a uniform convention.

   For example, you should use names like `ignore_space_change_flag';
don't use names like `iCantReadThis'.

   Variables that indicate whether command-line options have been
specified should be named after the meaning of the option, not after
the option-letter.  A comment should state both the exact meaning of
the option and its letter.  For example,

     /* Ignore changes in horizontal whitespace (-b).  */
     int ignore_space_change_flag;

   When you want to define names with constant integer values, use
`enum' rather than `#define'.  GDB knows about enumeration constants.

   You might want to make sure that none of the file names would
conflict the files were loaded onto an MS-DOS file system which
shortens the names.  You can use the program `doschk' to test for this.

   Some GNU programs were designed to limit themselves to file names of
14 characters or less, to avoid file name conflicts if they are read
into older System V systems.  Please preserve this feature in the
existing GNU programs that have it, but there is no need to do this in
new GNU programs.  `doschk' also reports file names longer than 14
characters.


File: standards.info,  Node: System Portability,  Next: CPU Portability,  Prev: Names,  Up: Writing C

Portability between System Types
================================

   In the Unix world, "portability" refers to porting to different Unix
versions.  For a GNU program, this kind of portability is desirable, but
not paramount.

   The primary purpose of GNU software is to run on top of the GNU
kernel, compiled with the GNU C compiler, on various types of CPU.  So
the kinds of portability that are absolutely necessary are quite
limited.  But it is important to support Linux-based GNU systems, since
they are the form of GNU that is popular.

   Beyond that, it is good to support the other free operating systems
(*BSD), and it is nice to support other Unix-like systems if you want
to.  Supporting a variety of Unix-like systems is desirable, although
not paramount.  It is usually not too hard, so you may as well do it.
But you don't have to consider it an obligation, if it does turn out to
be hard.

   The easiest way to achieve portability to most Unix-like systems is
to use Autoconf.  It's unlikely that your program needs to know more
information about the host platform than Autoconf can provide, simply
because most of the programs that need such knowledge have already been
written.

   Avoid using the format of semi-internal data bases (e.g.,
directories) when there is a higher-level alternative (`readdir').

   As for systems that are not like Unix, such as MSDOS, Windows, the
Macintosh, VMS, and MVS, supporting them is often a lot of work.  When
that is the case, it is better to spend your time adding features that
will be useful on GNU and GNU/Linux, rather than on supporting other
incompatible systems.

   It is a good idea to define the "feature test macro" `_GNU_SOURCE'
when compiling your C files.  When you compile on GNU or GNU/Linux,
this will enable the declarations of GNU library extension functions,
and that will usually give you a compiler error message if you define
the same function names in some other way in your program.  (You don't
have to actually _use_ these functions, if you prefer to make the
program more portable to other systems.)

   But whether or not you use these GNU extensions, you should avoid
using their names for any other meanings.  Doing so would make it hard
to move your code into other GNU programs.


File: standards.info,  Node: CPU Portability,  Next: System Functions,  Prev: System Portability,  Up: Writing C

Portability between CPUs
========================

   Even GNU systems will differ because of differences among CPU
types--for example, difference in byte ordering and alignment
requirements.  It is absolutely essential to handle these differences.
However, don't make any effort to cater to the possibility that an
`int' will be less than 32 bits.  We don't support 16-bit machines in
GNU.

   Similarly, don't make any effort to cater to the possibility that
`long' will be smaller than predefined types like `size_t'.  For
example, the following code is ok:

     printf ("size = %lu\n", (unsigned long) sizeof array);
     printf ("diff = %ld\n", (long) (pointer2 - pointer1));

   1989 Standard C requires this to work, and we know of only one
counterexample: 64-bit programs on Microsoft Windows IA-64.  We will
leave it to those who want to port GNU programs to that environment to
figure out how to do it.

   Predefined file-size types like `off_t' are an exception: they are
longer than `long' on many platforms, so code like the above won't work
with them.  One way to print an `off_t' value portably is to print its
digits yourself, one by one.

   Don't assume that the address of an `int' object is also the address
of its least-significant byte.  This is false on big-endian machines.
Thus, don't make the following mistake:

     int c;
     ...
     while ((c = getchar()) != EOF)
       write(file_descriptor, &c, 1);

   When calling functions, you need not worry about the difference
between pointers of various types, or between pointers and integers.
On most machines, there's no difference anyway.  As for the few
machines where there is a difference, all of them support Standard C
prototypes, so you can use prototypes (perhaps conditionalized to be
active only in Standard C) to make the code work on those systems.

   In certain cases, it is ok to pass integer and pointer arguments
indiscriminately to the same function, and use no prototype on any
system.  For example, many GNU programs have error-reporting functions
that pass their arguments along to `printf' and friends:

     error (s, a1, a2, a3)
          char *s;
          char *a1, *a2, *a3;
     {
       fprintf (stderr, "error: ");
       fprintf (stderr, s, a1, a2, a3);
     }

In practice, this works on all machines, since a pointer is generally
the widest possible kind of argument; it is much simpler than any
"correct" alternative.  Be sure _not_ to use a prototype for such
functions.

   If you have decided to use Standard C, then you can instead define
`error' using `stdarg.h', and pass the arguments along to `vfprintf'.

   Avoid casting pointers to integers if you can.  Such casts greatly
reduce portability, and in most programs they are easy to avoid.  In the
cases where casting pointers to integers is essential--such as, a Lisp
interpreter which stores type information as well as an address in one
word--you'll have to make explicit provisions to handle different word
sizes.  You will also need to make provision for systems in which the
normal range of addresses you can get from `malloc' starts far away
from zero.


File: standards.info,  Node: System Functions,  Next: Internationalization,  Prev: CPU Portability,  Up: Writing C

Calling System Functions
========================

   C implementations differ substantially.  Standard C reduces but does
not eliminate the incompatibilities; meanwhile, many GNU packages still
support pre-standard compilers because this is not hard to do.  This
chapter gives recommendations for how to use the more-or-less standard C
library functions to avoid unnecessary loss of portability.

   * Don't use the return value of `sprintf'.  It returns the number of
     characters written on some systems, but not on all systems.

   * Be aware that `vfprintf' is not always available.

   * `main' should be declared to return type `int'.  It should
     terminate either by calling `exit' or by returning the integer
     status code; make sure it cannot ever return an undefined value.

   * Don't declare system functions explicitly.

     Almost any declaration for a system function is wrong on some
     system.  To minimize conflicts, leave it to the system header
     files to declare system functions.  If the headers don't declare a
     function, let it remain undeclared.

     While it may seem unclean to use a function without declaring it,
     in practice this works fine for most system library functions on
     the systems where this really happens; thus, the disadvantage is
     only theoretical.  By contrast, actual declarations have
     frequently caused actual conflicts.

   * If you must declare a system function, don't specify the argument
     types.  Use an old-style declaration, not a Standard C prototype.
     The more you specify about the function, the more likely a
     conflict.

   * In particular, don't unconditionally declare `malloc' or `realloc'.

     Most GNU programs use those functions just once, in functions
     conventionally named `xmalloc' and `xrealloc'.  These functions
     call `malloc' and `realloc', respectively, and check the results.

     Because `xmalloc' and `xrealloc' are defined in your program, you
     can declare them in other files without any risk of type conflict.

     On most systems, `int' is the same length as a pointer; thus, the
     calls to `malloc' and `realloc' work fine.  For the few
     exceptional systems (mostly 64-bit machines), you can use
     *conditionalized* declarations of `malloc' and `realloc'--or put
     these declarations in configuration files specific to those
     systems.

   * The string functions require special treatment.  Some Unix systems
     have a header file `string.h'; others have `strings.h'.  Neither
     file name is portable.  There are two things you can do: use
     Autoconf to figure out which file to include, or don't include
     either file.

   * If you don't include either strings file, you can't get
     declarations for the string functions from the header file in the
     usual way.

     That causes less of a problem than you might think.  The newer
     standard string functions should be avoided anyway because many
     systems still don't support them.  The string functions you can
     use are these:

          strcpy   strncpy   strcat   strncat
          strlen   strcmp    strncmp
          strchr   strrchr

     The copy and concatenate functions work fine without a declaration
     as long as you don't use their values.  Using their values without
     a declaration fails on systems where the width of a pointer
     differs from the width of `int', and perhaps in other cases.  It
     is trivial to avoid using their values, so do that.

     The compare functions and `strlen' work fine without a declaration
     on most systems, possibly all the ones that GNU software runs on.
     You may find it necessary to declare them *conditionally* on a few
     systems.

     The search functions must be declared to return `char *'.  Luckily,
     there is no variation in the data type they return.  But there is
     variation in their names.  Some systems give these functions the
     names `index' and `rindex'; other systems use the names `strchr'
     and `strrchr'.  Some systems support both pairs of names, but
     neither pair works on all systems.

     You should pick a single pair of names and use it throughout your
     program.  (Nowadays, it is better to choose `strchr' and `strrchr'
     for new programs, since those are the standard names.)  Declare
     both of those names as functions returning `char *'.  On systems
     which don't support those names, define them as macros in terms of
     the other pair.  For example, here is what to put at the beginning
     of your file (or in a header) if you want to use the names
     `strchr' and `strrchr' throughout:

          #ifndef HAVE_STRCHR
          #define strchr index
          #endif
          #ifndef HAVE_STRRCHR
          #define strrchr rindex
          #endif
          
          char *strchr ();
          char *strrchr ();

   Here we assume that `HAVE_STRCHR' and `HAVE_STRRCHR' are macros
defined in systems where the corresponding functions exist.  One way to
get them properly defined is to use Autoconf.


File: standards.info,  Node: Internationalization,  Next: Mmap,  Prev: System Functions,  Up: Writing C

Internationalization
====================

   GNU has a library called GNU gettext that makes it easy to translate
the messages in a program into various languages.  You should use this
library in every program.  Use English for the messages as they appear
in the program, and let gettext provide the way to translate them into
other languages.

   Using GNU gettext involves putting a call to the `gettext' macro
around each string that might need translation--like this:

     printf (gettext ("Processing file `%s'..."));

This permits GNU gettext to replace the string `"Processing file
`%s'..."' with a translated version.

   Once a program uses gettext, please make a point of writing calls to
`gettext' when you add new strings that call for translation.

   Using GNU gettext in a package involves specifying a "text domain
name" for the package.  The text domain name is used to separate the
translations for this package from the translations for other packages.
Normally, the text domain name should be the same as the name of the
package--for example, `fileutils' for the GNU file utilities.

   To enable gettext to work well, avoid writing code that makes
assumptions about the structure of words or sentences.  When you want
the precise text of a sentence to vary depending on the data, use two or
more alternative string constants each containing a complete sentences,
rather than inserting conditionalized words or phrases into a single
sentence framework.

   Here is an example of what not to do:

     printf ("%d file%s processed", nfiles,
             nfiles != 1 ? "s" : "");

The problem with that example is that it assumes that plurals are made
by adding `s'.  If you apply gettext to the format string, like this,

     printf (gettext ("%d file%s processed"), nfiles,
             nfiles != 1 ? "s" : "");

the message can use different words, but it will still be forced to use
`s' for the plural.  Here is a better way:

     printf ((nfiles != 1 ? "%d files processed"
              : "%d file processed"),
             nfiles);

This way, you can apply gettext to each of the two strings
independently:

     printf ((nfiles != 1 ? gettext ("%d files processed")
              : gettext ("%d file processed")),
             nfiles);

This can be any method of forming the plural of the word for "file", and
also handles languages that require agreement in the word for
"processed".

   A similar problem appears at the level of sentence structure with
this code:

     printf ("#  Implicit rule search has%s been done.\n",
             f->tried_implicit ? "" : " not");

Adding `gettext' calls to this code cannot give correct results for all
languages, because negation in some languages requires adding words at
more than one place in the sentence.  By contrast, adding `gettext'
calls does the job straightfowardly if the code starts out like this:

     printf (f->tried_implicit
             ? "#  Implicit rule search has been done.\n",
             : "#  Implicit rule search has not been done.\n");


File: standards.info,  Node: Mmap,  Prev: Internationalization,  Up: Writing C

Mmap
====

   Don't assume that `mmap' either works on all files or fails for all
files.  It may work on some files and fail on others.

   The proper way to use `mmap' is to try it on the specific file for
which you want to use it--and if `mmap' doesn't work, fall back on
doing the job in another way using `read' and `write'.

   The reason this precaution is needed is that the GNU kernel (the
HURD) provides a user-extensible file system, in which there can be many
different kinds of "ordinary files."  Many of them support `mmap', but
some do not.  It is important to make programs handle all these kinds
of files.


File: standards.info,  Node: Documentation,  Next: Managing Releases,  Prev: Writing C,  Up: Top

Documenting Programs
********************

   A GNU program should ideally come with full free documentation,
adequate for both reference and tutorial purposes.  If the package can
be programmed or extended, the documentation should cover programming or
extending it, as well as just using it.

* Menu:

* GNU Manuals::                 Writing proper manuals.
* Doc Strings and Manuals::     Compiling doc strings doesn't make a manual.
* Manual Structure Details::    Specific structure conventions.
* License for Manuals::         Writing the distribution terms for a manual.
* Manual Credits::              Giving credit to documentation contributors.
* Printed Manuals::             Mentioning the printed manual.
* NEWS File::                   NEWS files supplement manuals.
* Change Logs::                 Recording Changes
* Man Pages::                   Man pages are secondary.
* Reading other Manuals::       How far you can go in learning
                                from other manuals.


File: standards.info,  Node: GNU Manuals,  Next: Doc Strings and Manuals,  Up: Documentation

GNU Manuals
===========

   The preferred document format for the GNU system is the Texinfo
formatting language.  Every GNU package should (ideally) have
documentation in Texinfo both for reference and for learners.  Texinfo
makes it possible to produce a good quality formatted book, using TeX,
and to generate an Info file.  It is also possible to generate HTML
output from Texinfo source.  See the Texinfo manual, either the
hardcopy, or the on-line version available through `info' or the Emacs
Info subsystem (`C-h i').

   Nowadays some other formats such as Docbook and Sgmltexi can be
converted automatically into Texinfo.  It is ok to produce the Texinfo
documentation by conversion this way, as long as it gives good results.

   Programmers often find it most natural to structure the documentation
following the structure of the implementation, which they know.  But
this structure is not necessarily good for explaining how to use the
program; it may be irrelevant and confusing for a user.

   At every level, from the sentences in a paragraph to the grouping of
topics into separate manuals, the right way to structure documentation
is according to the concepts and questions that a user will have in mind
when reading it.  Sometimes this structure of ideas matches the
structure of the implementation of the software being documented--but
often they are different.  Often the most important part of learning to
write good documentation is learning to notice when you are structuring
the documentation like the implementation, and think about better
alternatives.

   For example, each program in the GNU system probably ought to be
documented in one manual; but this does not mean each program should
have its own manual.  That would be following the structure of the
implementation, rather than the structure that helps the user
understand.

   Instead, each manual should cover a coherent _topic_.  For example,
instead of a manual for `diff' and a manual for `diff3', we have one
manual for "comparison of files" which covers both of those programs,
as well as `cmp'.  By documenting these programs together, we can make
the whole subject clearer.

   The manual which discusses a program should certainly document all of
the program's command-line options and all of its commands.  It should
give examples of their use.  But don't organize the manual as a list of
features.  Instead, organize it logically, by subtopics.  Address the
questions that a user will ask when thinking about the job that the
program does.

   In general, a GNU manual should serve both as tutorial and reference.
It should be set up for convenient access to each topic through Info,
and for reading straight through (appendixes aside).  A GNU manual
should give a good introduction to a beginner reading through from the
start, and should also provide all the details that hackers want.  The
Bison manual is a good example of this--please take a look at it to see
what we mean.

   That is not as hard as it first sounds.  Arrange each chapter as a
logical breakdown of its topic, but order the sections, and write their
text, so that reading the chapter straight through makes sense.  Do
likewise when structuring the book into chapters, and when structuring a
section into paragraphs.  The watchword is, _at each point, address the
most fundamental and important issue raised by the preceding text._

   If necessary, add extra chapters at the beginning of the manual which
are purely tutorial and cover the basics of the subject.  These provide
the framework for a beginner to understand the rest of the manual.  The
Bison manual provides a good example of how to do this.

   To serve as a reference, a manual should have an Index that list all
the functions, variables, options, and important concepts that are part
of the program.  One combined Index should do for a short manual, but
sometimes for a complex package it is better to use multiple indices.
The Texinfo manual includes advice on preparing good index entries, see
*Note Making Index Entries: (texinfo)Index Entries, and see *Note
Defining the Entries of an Index: (texinfo)Indexing Commands.

   Don't use Unix man pages as a model for how to write GNU
documentation; most of them are terse, badly structured, and give
inadequate explanation of the underlying concepts.  (There are, of
course, some exceptions.)  Also, Unix man pages use a particular format
which is different from what we use in GNU manuals.

   Please include an email address in the manual for where to report
bugs _in the manual_.

   Please do not use the term "pathname" that is used in Unix
documentation; use "file name" (two words) instead.  We use the term
"path" only for search paths, which are lists of directory names.

   Please do not use the term "illegal" to refer to erroneous input to a
computer program.  Please use "invalid" for this, and reserve the term
"illegal" for activities punishable by law.


File: standards.info,  Node: Doc Strings and Manuals,  Next: Manual Structure Details,  Prev: GNU Manuals,  Up: Documentation

Doc Strings and Manuals
=======================

   Some programming systems, such as Emacs, provide a documentation
string for each function, command or variable.  You may be tempted to
write a reference manual by compiling the documentation strings and
writing a little additional text to go around them--but you must not do
it.  That approach is a fundamental mistake.  The text of well-written
documentation strings will be entirely wrong for a manual.

   A documentation string needs to stand alone--when it appears on the
screen, there will be no other text to introduce or explain it.
Meanwhile, it can be rather informal in style.

   The text describing a function or variable in a manual must not stand
alone; it appears in the context of a section or subsection.  Other text
at the beginning of the section should explain some of the concepts, and
should often make some general points that apply to several functions or
variables.  The previous descriptions of functions and variables in the
section will also have given information about the topic.  A description
written to stand alone would repeat some of that information; this
redundance looks bad.  Meanwhile, the informality that is acceptable in
a documentation string is totally unacceptable in a manual.

   The only good way to use documentation strings in writing a good
manual is to use them as a source of information for writing good text.


File: standards.info,  Node: Manual Structure Details,  Next: License for Manuals,  Prev: Doc Strings and Manuals,  Up: Documentation

Manual Structure Details
========================

   The title page of the manual should state the version of the
programs or packages documented in the manual.  The Top node of the
manual should also contain this information.  If the manual is changing
more frequently than or independent of the program, also state a version
number for the manual in both of these places.

   Each program documented in the manual should have a node named
`PROGRAM Invocation' or `Invoking PROGRAM'.  This node (together with
its subnodes, if any) should describe the program's command line
arguments and how to run it (the sort of information people would look
in a man page for).  Start with an `@example' containing a template for
all the options and arguments that the program uses.

   Alternatively, put a menu item in some menu whose item name fits one
of the above patterns.  This identifies the node which that item points
to as the node for this purpose, regardless of the node's actual name.

   The `--usage' feature of the Info reader looks for such a node or
menu item in order to find the relevant text, so it is essential for
every Texinfo file to have one.

   If one manual describes several programs, it should have such a node
for each program described in the manual.


File: standards.info,  Node: License for Manuals,  Next: Manual Credits,  Prev: Manual Structure Details,  Up: Documentation

License for Manuals
===================

   Please use the GNU Free Documentation License for all GNU manuals
that are more than a few pages long.  Likewise for a collection of short
documents--you only need one copy of the GNU FDL for the whole
collection.  For a single short document, you can use a very permissive
non-copyleft license, to avoid taking up space with a long license.

   See `http://www.gnu.org/copyleft/fdl-howto.html' for more explanation
of how to employ the GFDL.

   Note that it is not obligatory to include a copy of the GNU GPL or
GNU LGPL in a manual whose license is neither the GPL nor the LGPL.  It
can be a good idea to include the program's license in a large manual;
in a short manual, whose size would be increased considerably by
including the program's license, it is probably better not to include
it.


File: standards.info,  Node: Manual Credits,  Next: Printed Manuals,  Prev: License for Manuals,  Up: Documentation

Manual Credits
==============

   Please credit the principal human writers of the manual as the
authors, on the title page of the manual.  If a company sponsored the
work, thank the company in a suitable place in the manual, but do not
cite the company as an author.


File: standards.info,  Node: Printed Manuals,  Next: NEWS File,  Prev: Manual Credits,  Up: Documentation

Printed Manuals
===============

   The FSF publishes some GNU manuals in printed form.  To encourage
sales of these manuals, the on-line versions of the manual should
mention at the very start that the printed manual is available and
should point at information for getting it--for instance, with a link
to the page <http://www.gnu.org/order/order.html>.  This should not be
included in the printed manual, though, because there it is redundant.

   It is also useful to explain in the on-line forms of the manual how
the user can print out the manual from the sources.


File: standards.info,  Node: NEWS File,  Next: Change Logs,  Prev: Printed Manuals,  Up: Documentation

The NEWS File
=============

   In addition to its manual, the package should have a file named
`NEWS' which contains a list of user-visible changes worth mentioning.
In each new release, add items to the front of the file and identify
the version they pertain to.  Don't discard old items; leave them in
the file after the newer items.  This way, a user upgrading from any
previous version can see what is new.

   If the `NEWS' file gets very long, move some of the older items into
a file named `ONEWS' and put a note at the end referring the user to
that file.


File: standards.info,  Node: Change Logs,  Next: Man Pages,  Prev: NEWS File,  Up: Documentation

Change Logs
===========

   Keep a change log to describe all the changes made to program source
files.  The purpose of this is so that people investigating bugs in the
future will know about the changes that might have introduced the bug.
Often a new bug can be found by looking at what was recently changed.
More importantly, change logs can help you eliminate conceptual
inconsistencies between different parts of a program, by giving you a
history of how the conflicting concepts arose and who they came from.

* Menu:

* Change Log Concepts::
* Style of Change Logs::
* Simple Changes::
* Conditional Changes::
* Indicating the Part Changed::


File: standards.info,  Node: Change Log Concepts,  Next: Style of Change Logs,  Up: Change Logs

Change Log Concepts
-------------------

   You can think of the change log as a conceptual "undo list" which
explains how earlier versions were different from the current version.
People can see the current version; they don't need the change log to
tell them what is in it.  What they want from a change log is a clear
explanation of how the earlier version differed.

   The change log file is normally called `ChangeLog' and covers an
entire directory.  Each directory can have its own change log, or a
directory can use the change log of its parent directory-it's up to you.

   Another alternative is to record change log information with a
version control system such as RCS or CVS.  This can be converted
automatically to a `ChangeLog' file using `rcs2log'; in Emacs, the
command `C-x v a' (`vc-update-change-log') does the job.

   There's no need to describe the full purpose of the changes or how
they work together.  If you think that a change calls for explanation,
you're probably right.  Please do explain it--but please put the
explanation in comments in the code, where people will see it whenever
they see the code.  For example, "New function" is enough for the
change log when you add a function, because there should be a comment
before the function definition to explain what it does.

   However, sometimes it is useful to write one line to describe the
overall purpose of a batch of changes.

   The easiest way to add an entry to `ChangeLog' is with the Emacs
command `M-x add-change-log-entry'.  An entry should have an asterisk,
the name of the changed file, and then in parentheses the name of the
changed functions, variables or whatever, followed by a colon.  Then
describe the changes you made to that function or variable.


File: standards.info,  Node: Style of Change Logs,  Next: Simple Changes,  Prev: Change Log Concepts,  Up: Change Logs

Style of Change Logs
--------------------

   Here are some simple examples of change log entries, starting with
the header line that says who made the change and when, followed by
descriptions of specific changes.  (These examples are drawn from Emacs
and GCC.)

     1998-08-17  Richard Stallman  <rms@gnu.org>
     
     * register.el (insert-register): Return nil.
     (jump-to-register): Likewise.
     
     * sort.el (sort-subr): Return nil.
     
     * tex-mode.el (tex-bibtex-file, tex-file, tex-region):
     Restart the tex shell if process is gone or stopped.
     (tex-shell-running): New function.
     
     * expr.c (store_one_arg): Round size up for move_block_to_reg.
     (expand_call): Round up when emitting USE insns.
     * stmt.c (assign_parms): Round size up for move_block_from_reg.

   It's important to name the changed function or variable in full.
Don't abbreviate function or variable names, and don't combine them.
Subsequent maintainers will often search for a function name to find all
the change log entries that pertain to it; if you abbreviate the name,
they won't find it when they search.

   For example, some people are tempted to abbreviate groups of function
names by writing `* register.el ({insert,jump-to}-register)'; this is
not a good idea, since searching for `jump-to-register' or
`insert-register' would not find that entry.

   Separate unrelated change log entries with blank lines.  When two
entries represent parts of the same change, so that they work together,
then don't put blank lines between them.  Then you can omit the file
name and the asterisk when successive entries are in the same file.

   Break long lists of function names by closing continued lines with
`)', rather than `,', and opening the continuation with `(' as in this
example:

     * keyboard.c (menu_bar_items, tool_bar_items)
     (Fexecute_extended_command): Deal with `keymap' property.


File: standards.info,  Node: Simple Changes,  Next: Conditional Changes,  Prev: Style of Change Logs,  Up: Change Logs

Simple Changes
--------------

   Certain simple kinds of changes don't need much detail in the change
log.

   When you change the calling sequence of a function in a simple
fashion, and you change all the callers of the function to use the new
calling sequence, there is no need to make individual entries for all
the callers that you changed.  Just write in the entry for the function
being called, "All callers changed"--like this:

     * keyboard.c (Fcommand_execute): New arg SPECIAL.
     All callers changed.

   When you change just comments or doc strings, it is enough to write
an entry for the file, without mentioning the functions.  Just "Doc
fixes" is enough for the change log.

   There's no need to make change log entries for documentation files.
This is because documentation is not susceptible to bugs that are hard
to fix.  Documentation does not consist of parts that must interact in a
precisely engineered fashion.  To correct an error, you need not know
the history of the erroneous passage; it is enough to compare what the
documentation says with the way the program actually works.


File: standards.info,  Node: Conditional Changes,  Next: Indicating the Part Changed,  Prev: Simple Changes,  Up: Change Logs

Conditional Changes
-------------------

   C programs often contain compile-time `#if' conditionals.  Many
changes are conditional; sometimes you add a new definition which is
entirely contained in a conditional.  It is very useful to indicate in
the change log the conditions for which the change applies.

   Our convention for indicating conditional changes is to use square
brackets around the name of the condition.

   Here is a simple example, describing a change which is conditional
but does not have a function or entity name associated with it:

     * xterm.c [SOLARIS2]: Include string.h.

   Here is an entry describing a new definition which is entirely
conditional.  This new definition for the macro `FRAME_WINDOW_P' is
used only when `HAVE_X_WINDOWS' is defined:

     * frame.h [HAVE_X_WINDOWS] (FRAME_WINDOW_P): Macro defined.

   Here is an entry for a change within the function `init_display',
whose definition as a whole is unconditional, but the changes themselves
are contained in a `#ifdef HAVE_LIBNCURSES' conditional:

     * dispnew.c (init_display) [HAVE_LIBNCURSES]: If X, call tgetent.

   Here is an entry for a change that takes affect only when a certain
macro is _not_ defined:

     (gethostname) [!HAVE_SOCKETS]: Replace with winsock version.


File: standards.info,  Node: Indicating the Part Changed,  Prev: Conditional Changes,  Up: Change Logs

Indicating the Part Changed
---------------------------

   Indicate the part of a function which changed by using angle brackets
enclosing an indication of what the changed part does.  Here is an entry
for a change in the part of the function `sh-while-getopts' that deals
with `sh' commands:

     * progmodes/sh-script.el (sh-while-getopts) <sh>: Handle case that
     user-specified option string is empty.


File: standards.info,  Node: Man Pages,  Next: Reading other Manuals,  Prev: Change Logs,  Up: Documentation

Man Pages
=========

   In the GNU project, man pages are secondary.  It is not necessary or
expected for every GNU program to have a man page, but some of them do.
It's your choice whether to include a man page in your program.

   When you make this decision, consider that supporting a man page
requires continual effort each time the program is changed.  The time
you spend on the man page is time taken away from more useful work.

   For a simple program which changes little, updating the man page may
be a small job.  Then there is little reason not to include a man page,
if you have one.

   For a large program that changes a great deal, updating a man page
may be a substantial burden.  If a user offers to donate a man page,
you may find this gift costly to accept.  It may be better to refuse
the man page unless the same person agrees to take full responsibility
for maintaining it--so that you can wash your hands of it entirely.  If
this volunteer later ceases to do the job, then don't feel obliged to
pick it up yourself; it may be better to withdraw the man page from the
distribution until someone else agrees to update it.

   When a program changes only a little, you may feel that the
discrepancies are small enough that the man page remains useful without
updating.  If so, put a prominent note near the beginning of the man
page explaining that you don't maintain it and that the Texinfo manual
is more authoritative.  The note should say how to access the Texinfo
documentation.


File: standards.info,  Node: Reading other Manuals,  Prev: Man Pages,  Up: Documentation

Reading other Manuals
=====================

   There may be non-free books or documentation files that describe the
program you are documenting.

   It is ok to use these documents for reference, just as the author of
a new algebra textbook can read other books on algebra.  A large portion
of any non-fiction book consists of facts, in this case facts about how
a certain program works, and these facts are necessarily the same for
everyone who writes about the subject.  But be careful not to copy your
outline structure, wording, tables or examples from preexisting non-free
documentation.  Copying from free documentation may be ok; please check
with the FSF about the individual case.

