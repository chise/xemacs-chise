This is ../info/xemacs.info, produced by makeinfo version 4.0 from
xemacs/xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
-------------

   Aside from delimiting the region, the mark is also useful for marking
a spot that you may want to go back to.  To make this feature more
useful, Emacs remembers 16 previous locations of the mark in the "mark
ring".  Most commands that set the mark push the old mark onto this
ring.  To return to a marked location, use `C-u C-<SPC>' (or `C-u
C-@'); this is the command `set-mark-command' given a numeric argument.
The command moves point to where the mark was, and restores the mark
from the ring of former marks. Repeated use of this command moves point
to all the old marks on the ring, one by one.  The marks you have seen
go to the end of the ring, so no marks are lost.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-<SPC>' always stays
in the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This makes it easier for you to move back
later.  Searches set the mark, unless they do not actually move point.
When a command sets the mark, `Mark Set' is printed in the echo area.

   The variable `mark-ring-max' is the maximum number of entries to
keep in the mark ring.  If that many entries exist and another entry is
added, the last entry in the list is discarded.  Repeating `C-u
C-<SPC>' circulates through the entries that are currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.


File: xemacs.info,  Node: Mouse Selection,  Next: Additional Mouse Operations,  Prev: Mark,  Up: Top

Selecting Text with the Mouse
=============================

   If you are using XEmacs under X, you can use the mouse pointer to
select text. (The normal mouse pointer is an I-beam, the same pointer
that `xterm' uses.)

   The glyph variable `text-pointer-glyph' controls the shape of the
mouse pointer when over text.  You can also control the shape of the
mouse pointer when over nontext using `nontext-pointer-glyph', and the
shape of the mouse pointer when over the modeline using
`modeline-pointer-glyph'. (Remember, you should use `set-glyph-image',
not `setq', to set one of these variables.)

   If you want to get fancy, you can set the foreground and background
colors of the mouse pointer by setting the `pointer' face.

   There are two ways to select a region of text with the mouse:

   To select a word in text, double-click with the left mouse button
while the mouse cursor is over the word.  The word is highlighted when
selected. On monochrome monitors, a stippled background indicates that a
region of text has been highlighted. On color monitors, a color
background indicates highlighted text. You can triple-click to select
whole lines.

   To select an arbitrary region of text:

  1. Move the mouse cursor over the character at the beginning of the
     region of text you want to select.

  2. Press and hold the left mouse button.

  3. While holding the left mouse button down, drag the cursor to the
     character at the end of the region of text you want to select.

  4. Release the left mouse button.
        The selected region of text is highlighted.

   Once a region of text is selected, it becomes the primary X selection
(*note Using X Selections::) as well as the Emacs selected region. You
can paste it into other X applications and use the options from the
Edit pull-down menu on it.  Since it is also the Emacs region, you can
use Emacs region commands on it.


File: xemacs.info,  Node: Additional Mouse Operations,  Next: Killing,  Prev: Mouse Selection,  Up: Top

Additional Mouse Operations
===========================

   XEmacs also provides the following mouse functions.  Most of these
are not bound to mouse gestures by default, but they are provided for
your customization pleasure.  For example, if you wanted `shift-left'
(that is, holding down the <Shift> key and clicking the left mouse
button) to delete the character at which you are pointing, then you
could do this:

     (global-set-key '(shift button1) 'mouse-del-char)

`mouse-del-char'
     Delete the character pointed to by the mouse.

`mouse-delete-window'
     Delete the Emacs window that the mouse is on.

`mouse-keep-one-window'
     Select the Emacs window that the mouse is on, then delete all other
     windows on this frame.

`mouse-kill-line'
     Kill the line pointed to by the mouse.

`mouse-line-length'
     Print the length of the line indicated by the pointer.

`mouse-scroll'
     Scroll point to the mouse position.

`mouse-select'
     Select the Emacs window the mouse is on.

`mouse-select-and-split'
     Select the Emacs window mouse is on, then split it vertically in
     half.

`mouse-set-mark'
     Select the Emacs window the mouse is on and set the mark at the
     mouse position.  Display the cursor at that position for a second.

`mouse-set-point'
     Select the Emacs window that the mouse is on and move point to the
     mouse position.

`mouse-track'
     Make a selection with the mouse.   This is the default binding of
     the left mouse button (<button1>).

`mouse-track-adjust'
     Extend the existing selection.  This is the default binding of
     <Shift-button1>.

`mouse-track-and-copy-to-cutbuffer'
     Make a selection like `mouse-track', but also copy it to the cut
     buffer.

`mouse-track-delete-and-insert'
     Make a selection with the mouse and insert it at point.  This is
     the default binding of <control-shift-button1>.

`mouse-track-insert'
     Make a selection with the mouse and insert it at point.  This is
     the default binding of <control-button1>.

`mouse-window-to-region'
     Narrow a window to the region between the cursor and the mouse
     pointer.

   The `M-x mouse-track' command should be bound to a mouse button.  If
you click-and-drag, the selection is set to the region between the
point of the initial click and the point at which you release the
button.  These positions do not need to be ordered.

   If you click-and-release without moving the mouse, the point is
moved, and the selection is disowned (there will be no selection
owner.)  The mark will be set to the previous position of point.

   If you double-click, the selection will extend by symbols instead of
by characters.  If you triple-click, the selection will extend by lines.

   If you drag the mouse off the top or bottom of the window, you can
select pieces of text that are larger than the visible part of the
buffer; the buffer will scroll as necessary.

   The selected text becomes the current X selection, and is also
copied to the top of the kill ring.  Point will be left at the position
at which you released the button and the mark will be left at the
initial click position.  Bind a mouse click to
`mouse-track-and-copy-to-cutbuffer' to copy selections to the cut
buffer.  (See also the `mouse-track-adjust' command, on
`Shift-button1'.)

   The `M-x mouse-track-adjust' command should be bound to a mouse
button.  The selection will be enlarged or shrunk so that the point of
the mouse click is one of its endpoints.  This is only meaningful after
the `mouse-track' command (<button1>) has been executed.

   The `M-x mouse-track-delete-and-insert' command is exactly the same
as the `mouse-track' command on <button1>, except that point is not
moved; the selected text is immediately inserted after being selected;
and the text of the selection is deleted.

   The `M-x mouse-track-insert' command is exactly the same as the
`mouse-track' command on <button1>, except that point is not moved; the
selected text is immediately inserted after being selected; and the
selection is immediately disowned afterwards.


File: xemacs.info,  Node: Killing,  Next: Yanking,  Prev: Additional Mouse Operations,  Up: Top

Deletion and Killing
====================

   Most commands that erase text from the buffer save it. You can get
the text back if you change your mind, or you can move or copy it to
other parts of the buffer.  Commands which erase text and save it in the
kill ring are known as "kill" commands.  Some other commands erase text
but do not save it; they are known as "delete" commands.  (This
distinction is made only for erasing text in the buffer.)

   The commands' names and individual descriptions use the words `kill'
and `delete' to indicate what they do.  If you perform a kill or delete
command by mistake, use the `C-x u' (`undo') command to undo it (*note
Undo::). The delete commands include `C-d' (`delete-char') and <DEL>
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands that
can destroy significant amounts of nontrivial data usually kill.

Deletion
--------

`C-d'
     Delete next character (`delete-char').

`<DEL>'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-<SPC>'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, and any
     indentation following it (`delete-indentation').

   The most basic delete commands are `C-d' (`delete-char') and <DEL>
(`delete-backward-char').  `C-d' deletes the character after point, the
one the cursor is "on top of".  Point doesn't move.  <DEL> deletes the
character before the cursor, and moves point back.  You can delete
newlines like any other characters in the buffer; deleting a newline
joins two lines.  Actually, `C-d' and <DEL> aren't always delete
commands; if you give them an argument, they kill instead, since they
can erase more than one character this way.

   The other delete commands delete only formatting characters: spaces,
tabs and newlines.  `M-\' (`delete-horizontal-space') deletes all
spaces and tab characters before and after point.  `M-<SPC>'
(`just-one-space') does the same but leaves a single space after point,
regardless of the number of spaces that existed previously (even zero).

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line. If the current line is blank, it deletes all blank lines
preceding the current line as well as leaving one blank line, the
current line.  `M-^' (`delete-indentation') joins the current line and
the previous line, or, if given an argument, joins the current line and
the next line by deleting a newline and all surrounding spaces, possibly
leaving a single space.  *Note M-^: Indentation.

Killing by Lines
----------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

   The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving the line blank.  If
given on a blank line, the blank line disappears.  As a consequence, a
line disappears completely if you go to the front of a non-blank line
and type `C-k' twice.

   More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case, it kills the newline
following the line, thus merging the next line into the current one.
Emacs ignores invisible spaces and tabs at the end of the line when
deciding which case applies: if point appears to be at the end of the
line, you can be sure the newline will be killed.

   If you give `C-k' a positive argument, it kills that many lines and
the newlines that follow them (however, text on the current line before
point is not killed).  With a negative argument, `C-k' kills back to a
number of line beginnings.  An argument of -2 means kill back to the
second line beginning.  If point is at the beginning of a line, that
line beginning doesn't count, so `C-u - 2 C-k' with point at the front
of a line kills the two previous lines.

   `C-k' with an argument of zero kills all the text before point on the
current line.

Other Kill Commands
-------------------

`C-w'
     Kill region (from point to the mark) (`kill-region').  *Note
     Words::.

`M-d'
     Kill word (`kill-word').

`M-<DEL>'
     Kill word backwards (`backward-kill-word').

`C-x <DEL>'
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill sexp (`kill-sexp').  *Note Lists::.

`M-z CHAR'
     Kill up to next occurrence of CHAR (`zap-to-char').

   `C-w' (`kill-region') is a very general kill command; it kills
everything between point and the mark. You can use this command to kill
any contiguous sequence of characters by first setting the mark at one
end of a sequence of characters, then going to the other end and typing
`C-w'.

   A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (but not
including) the next occurrence of that character in the buffer.  If
there is no next occurrence, killing goes to the end of the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.

   Other syntactic units can be killed: words, with `M-<DEL>' and `M-d'
(*note Words::); sexps, with `C-M-k' (*note Lists::); and sentences,
with `C-x <DEL>' and `M-k' (*note Sentences::).


File: xemacs.info,  Node: Yanking,  Next: Using X Selections,  Prev: Killing,  Up: Top

Yanking
=======

   "Yanking" means getting back text which was killed. Some systems
call this "pasting".  The usual way to move or copy text is to kill it
and then yank it one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace re-inserted killed text with the previously killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`copy-region-as-kill').

`C-M-w'
     Append next kill to last batch of killed text (`append-next-kill').

* Menu:

* Kill Ring::       Where killed text is stored.  Basic yanking.
* Appending Kills:: Several kills in a row all yank together.
* Earlier Kills::   Yanking something killed some time ago.


File: xemacs.info,  Node: Kill Ring,  Next: Appending Kills,  Prev: Yanking,  Up: Yanking

The Kill Ring
-------------

   All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, used in all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

   If you have two separate Emacs processes, you cannot use the kill
ring to move text. If you are using XEmacs under X, however, you can
use the X selection mechanism to move text from one to another.

   If you are using XEmacs under X and have one Emacs process with
multiple frames, they do share the same kill ring.  You can kill or
copy text in one Emacs frame, then yank it in the other frame belonging
to the same process.

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text and sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' yanks the text, leaves the cursor in front of the text,
and sets the mark after it, if the argument is with just a `C-u'.  Any
other argument, including `C-u' and digits, has different results,
described below, under "Yanking Earlier Kills".

   To copy a block of text, you can also use `M-w'
(`copy-region-as-kill'), which copies the region into the kill ring
without removing it from the buffer. `M-w' is similar to `C-w' followed
by `C-y' but does not mark the buffer as "modified" and does not
actually cut anything.


File: xemacs.info,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

   Normally, each kill command pushes a new block onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks it all back. This means you
don't have to kill all the text you want to yank in one command; you
can kill line after line, or word after word, until you have killed what
you want, then get it all back at once using `C-y'. (Thus we join
television in leading people to kill thoughtlessly.)

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add onto
the beginning.  This way, any sequence of mixed forward and backward
kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains:

     This is the first
     line of sample text
     and here is the third.

with point at the beginning of the second line.  If you type `C-k C-u 2
M-<DEL> C-k', the first `C-k' kills the text `line of sample text',
`C-u 2 M-<DEL>' kills `the first' with the newline that followed it,
and the second `C-k' kills the newline after the second line.  The
result is that the buffer contains `This is and here is the third.' and
a single kill entry contains `the first<RET>line of sample
text<RET>'--all the killed text, in its original order.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  To force a kill command to append, first type the command `C-M-w'
(`append-next-kill'). `C-M-w' tells the following command, if it is a
kill command, to append the text it kills to the last killed text,
instead of starting a new entry.  With `C-M-w', you can kill several
separated pieces of text and accumulate them to be yanked back in one
place.


File: xemacs.info,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

   To recover killed text that is no longer the most recent kill, you
need the `Meta-y' (`yank-pop') command.  You can use `M-y' only after a
`C-y' or another `M-y'.  It takes the text previously yanked and
replaces it with the text from an earlier kill.  To recover the text of
the next-to-the-last kill, first use `C-y' to recover the last kill,
then `M-y' to replace it with the previous kill.

   You can think in terms of a "last yank" pointer which points at an
item in the kill ring.  Each time you kill, the "last yank" pointer
moves to the new item at the front of the ring.  `C-y' yanks the item
which the "last yank" pointer points to.  `M-y' moves the "last yank"
pointer to a different item, and the text in the buffer changes to
match.  Enough `M-y' commands can move the pointer to any item in the
ring, so you can get any item into the buffer.  Eventually the pointer
reaches the end of the ring; the next `M-y' moves it to the first item
again.

   Yanking moves the "last yank" pointer around the ring, but does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   Use `M-y' with a numeric argument to advance the "last yank" pointer
by the specified number of items.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves to the last entry and starts moving forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and the text will stay there. Since the text
is just a copy of the kill ring item, editing it in the buffer does not
change what's in the ring.  As long you don't kill additional text, the
"last yank" pointer remains at the same place in the kill ring:
repeating `C-y' will yank another copy of the same old kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a numeric
argument.  `C-y' with an argument greater than one restores the text
the specified number of entries back in the kill ring.  Thus, `C-u 2
C-y' gets the next to the last block of killed text.  It is equivalent
to `C-y M-y'.  `C-y' with a numeric argument starts counting from the
"last yank" pointer, and sets the "last yank" pointer to the entry that
it yanks.

   The variable `kill-ring-max' controls the length of the kill ring;
no more than that many blocks of killed text are saved.


File: xemacs.info,  Node: Using X Selections,  Next: Accumulating Text,  Prev: Yanking,  Up: Top

Using X Selections
==================

   In the X window system, mouse selections provide a simple mechanism
for text transfer between different applications.  In a typical X
application, you can select text by pressing the left mouse button and
dragging the cursor over the text you want to copy.  The text becomes
the primary X selection and is highlighted.  The highlighted region is
also the Emacs selected region.

   * Since the region is the primary X selection, you can go to a
     different X application and click the middle mouse button: the
     text that you selected in the previous application is pasted into
     the current application.

   * Since the region is the Emacs selected region, you can use all
     region commands (`C-w, M-w' etc.) as well as the options of the
     Edit menu to manipulate the selected text.

* Menu:

* X Clipboard Selection::     	Pasting to the X clipboard.
* X Selection Commands::	Other operations on the selection.
* X Cut Buffers::       	X cut buffers are available for compatibility.
* Active Regions::      	Using zmacs-style highlighting of the
                        	 selected region.


File: xemacs.info,  Node: X Clipboard Selection,  Next: X Selection Commands,  Prev: Using X Selections,  Up: Using X Selections

The Clipboard Selection
-----------------------

   There are other kinds of X selections besides the Primary selection;
one common one is the Clipboard selection.  Some applications prefer to
transfer data using this selection in preference to the Primary.  One
can transfer text from the Primary selection to the  Clipboard
selection with the Copy command under the Edit menu in the menubar.

   Usually, the clipboard selection is not visible.  However, if you
run the `xclipboard' application, the text most recently copied to the
clipboard (with the Copy command) is displayed in a window.  Any time
new text is thus copied, the `xclipboard' application makes a copy of
it and displays it in its window.  The value of the clipboard can
survive the lifetime of the running Emacs process.  The `xclipboard'
man page provides more details.

   Warning: If you use the `xclipboard' application, remember that it
maintains a list of all things that have been pasted to the clipboard
(that is, copied with the Copy command).  If you don't manually delete
elements from this list by clicking on the Delete button in the
`xclipboard' window, the clipboard will eventually consume a lot of
memory.

   In summary, some X applications (such as `xterm') allow one to paste
text in them from XEmacs in the following way:

   * Drag out a region of text in Emacs with the left mouse button,
     making that text be the Primary selection.

   * Click the middle button in the other application, pasting the
     Primary selection.

   With some other applications (notably, the OpenWindows and Motif
tools) you must use this method instead:

   * Drag out a region of text in Emacs with the left mouse button,
     making that text be the Primary selection.

   * Copy the selected text to the Clipboard selection by selecting the
     Copy menu item from the Edit menu, or by hitting the Copy key on
     your keyboard.

   * Paste the text in the other application by selecting Paste from its
     menu, or by hitting the Paste key on your keyboard.


File: xemacs.info,  Node: X Selection Commands,  Next: X Cut Buffers,  Prev: X Clipboard Selection,  Up: Using X Selections

Miscellaneous X Selection Commands
----------------------------------

`M-x x-copy-primary-selection'
     Copy the primary selection to both the kill ring and the Clipboard.

`M-x x-insert-selection'
     Insert the current selection into the buffer at point.

`M-x x-delete-primary-selection'
     Deletes the text in the primary selection without copying it to
     the kill ring or the Clipboard.

`M-x x-kill-primary-selection'
     Deletes the text in the primary selection and copies it to both
     the kill ring and the Clipboard.

`M-x x-mouse-kill'
     Kill the text between point and the mouse and copy it to the
     clipboard and to the cut buffer.

`M-x x-own-secondary-selection'
     Make a secondary X selection of the given argument.

`M-x x-own-selection'
     Make a primary X selection of the given argument.

`M-x x-set-point-and-insert-selection'
     Set point where clicked and insert the primary selection or the
     cut buffer.


File: xemacs.info,  Node: X Cut Buffers,  Next: Active Regions,  Prev: X Selection Commands,  Up: Using X Selections

X Cut Buffers
-------------

   X cut buffers are a different, older way of transferring text between
applications.  XEmacs supports cut buffers for compatibility with older
programs, even though selections are now the preferred way of
transferring text.

   X has a concept of applications "owning" selections.  When you select
text by clicking and dragging inside an application, the application
tells the X server that it owns the selection.  When another
application asks the X server for the value of the selection, the X
server requests the information from the owner. When you use
selections, the selection data is not actually transferred unless
someone wants it; the act of making a selection doesn't transfer data.
Cut buffers are different: when you "own" a cut buffer, the data is
actually transferred to the X server immediately, and survives the
lifetime of the application.

   Any time a region of text becomes the primary selection in Emacs,
Emacs also copies that text to the cut buffer.  This makes it possible
to copy text from an XEmacs buffer and paste it into an older,
non-selection-based application (such as Emacs 18).

   Note: Older versions of Emacs could not access the X selections, only
the X cut buffers.


File: xemacs.info,  Node: Active Regions,  Prev: X Cut Buffers,  Up: Using X Selections

Active Regions
--------------

   By default, both the text you select in an Emacs buffer using the
click-and-drag mechanism and text you select by setting point and the
mark is highlighted. You can use Emacs region commands as well as the
Cut and Copy commands on the highlighted region you selected with the
mouse.

   If you prefer, you can make a distinction between text selected with
the mouse and text selected with point and the mark by setting the
variable `zmacs-regions' to `nil'.  In that case:

   * The text selected with the mouse becomes both the X selection and
     the Emacs selected region. You can use menu-bar commands as well
     as Emacs region commands on it.

   * The text selected with point and the mark is not highlighted. You
     can only use Emacs region commands on it, not the menu-bar items.

   Active regions originally come from Zmacs, the Lisp Machine editor.
The idea behind them is that commands can only operate on a region when
the region is in an "active" state.  Put simply, you can only operate on
a region that is highlighted.

   The variable `zmacs-regions' checks whether LISPM-style active
regions should be used.  This means that commands that operate on the
region (the area between point and the mark) only work while the region
is in the active state, which is indicated by highlighting.  Most
commands causes the region to not be in the active state; for example,
`C-w' only works immediately after activating the region.

   More specifically:
   * Commands that operate on the region only work if the region is
     active.

   * Only a very small set of commands causes the region to become
     active-- those commands whose semantics are to mark an area, such
     as `mark-defun'.

   * The region is deactivated after each command that is executed,
     except that motion commands do not change whether the region is
     active or not.

   `set-mark-command' (`C-SPC') pushes a mark and activates the region.
Moving the cursor with normal motion commands (`C-n', `C-p', etc.)
will cause the region between point and the recently-pushed mark to be
highlighted.  It will remain highlighted until some non-motion command
is executed.

   `exchange-point-and-mark' (`C-x C-x') activates the region.  So if
you mark a region and execute a command that operates on it, you can
reactivate the same region with `C-x C-x' (or perhaps `C-x C-x C-x
C-x') to operate on it again.

   Generally, commands that push marks as a means of navigation, such as
`beginning-of-buffer' (`M-<') and `end-of-buffer' (`M->'), do not
activate the region.  However, commands that push marks as a means of
marking an area of text, such as `mark-defun' (`M-C-h'), `mark-word'
(`M-@'), and `mark-whole-buffer' (`C-x h'), do activate the region.

   When `zmacs-regions' is `t', there is no distinction between the
primary X selection and the active region selected by point and the
mark.  To see this, set the mark (<C-SPC>) and move the cursor with any
cursor-motion command: the region between point and mark is
highlighted, and you can watch it grow and shrink as you move the
cursor.

   Any other commands besides cursor-motion commands (such as inserting
or deleting text) will cause the region to no longer be active; it will
no longer be highlighted, and will no longer be the primary selection.
Region can be explicitly deactivated with `C-g'.

   Commands that require a region (such as `C-w') signal an error if
the region is not active.  Certain commands cause the region to be in
its active state.  The most common ones are `push-mark' (<C-SPC>) and
`exchange-point-and-mark' (`C-x C-x').

   When `zmacs-regions' is `t', programs can be non-intrusive on the
state of the region by setting the variable `zmacs-region-stays' to a
non-`nil' value.  If you are writing a new Emacs command that is
conceptually a "motion" command and should not interfere with the
current highlightedness of the region, then you may set this variable.
It is reset to `nil' after each user command is executed.

   When `zmacs-regions' is `t', programs can make the region between
point and mark go into the active (highlighted) state by using the
function `zmacs-activate-region'. Only a small number of commands
should ever do this.

   When `zmacs-regions' is `t', programs can deactivate the region
between point and the mark by using `zmacs-deactivate-region'.  Note:
you should not have to call this function; the command loop calls it
when appropriate.


File: xemacs.info,  Node: Accumulating Text,  Next: Rectangles,  Prev: Using X Selections,  Up: Top

Accumulating Text
=================

   Usually you copy or move text by killing it and yanking it, but
there are other ways that are useful for copying one block of text in
many places, or for copying many scattered blocks of text into one
place.

   If you like, you can accumulate blocks of text from scattered
locations either into a buffer or into a file.  The relevant commands
are described here.  You can also use Emacs registers for storing and
accumulating text.  *Note Registers::.

`M-x append-to-buffer'
     Append region to contents of specified buffer (`append-to-buffer').

`M-x prepend-to-buffer'
     Prepend region to contents of specified buffer.

`M-x copy-to-buffer'
     Copy region into specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert contents of specified buffer into current buffer at point.

`M-x append-to-file'
     Append region to the end of the contents of specified file.

   To accumulate text into a buffer, use the command `M-x
append-to-buffer', which inserts a copy of the region into the buffer
BUFFERNAME, at the location of point in that buffer.  If there is no
buffer with the given name, one is created.

   If you append text to a buffer that has been used for editing, the
copied text goes to the place where point is.  Point in that buffer is
left at the end of the copied text, so successive uses of
`append-to-buffer' accumulate the text in the specified buffer in the
same order as they were copied.  Strictly speaking, this command does
not always append to the text already in the buffer; but if this command
is the only command used to alter a buffer, it does always append to the
existing text because point is always at the end.

   `M-x prepend-to-buffer' is similar to `append-to-buffer', but point
in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is
similar, except that any existing text in the other buffer is deleted,
so the buffer is left containing just the text newly copied into it.

   You can retrieve the accumulated text from that buffer with `M-x
insert-buffer', which takes BUFFERNAME as an argument.  It inserts a
copy of the text in buffer BUFFERNAME into the selected buffer.  You
could alternatively select the other buffer for editing, perhaps moving
text from it by killing or with `append-to-buffer'.  *Note Buffers::,
for background information on buffers.

   Instead of accumulating text within Emacs in a buffer, you can append
text directly into a file with `M-x append-to-file', which takes
FILE-NAME as an argument.  It adds the text of the region to the end of
the specified file.  The file is changed immediately on disk.  This
command is normally used with files that are not being visited in
Emacs.  Using it on a file that Emacs is visiting can produce confusing
results, because the file's text inside Emacs does not change while the
file itself changes.


File: xemacs.info,  Node: Rectangles,  Next: Registers,  Prev: Accumulating Text,  Up: Top

Rectangles
==========

   The rectangle commands affect rectangular areas of text: all
characters between a certain pair of columns, in a certain range of
lines.  Commands are provided to kill rectangles, yank killed
rectangles, clear them out, or delete them.  Rectangle commands are
useful with text in multicolumnar formats, like code with comments at
the right, or for changing text into or out of such formats.

   To specify the rectangle a command should work on, put the mark at
one corner and point at the opposite corner.  The specified rectangle is
called the "region-rectangle" because it is controlled about the same
way the region is controlled.  Remember that a given combination of
point and mark values can be interpreted either as specifying a region
or as specifying a rectangle; it is up to the command that uses them to
choose the interpretation.

`M-x delete-rectangle'
     Delete the text of the region-rectangle, moving any following text
     on each line leftward to the left edge of the region-rectangle.

`M-x kill-rectangle'
     Similar, but also save the contents of the region-rectangle as the
     "last killed rectangle".

`M-x yank-rectangle'
     Yank the last killed rectangle with its upper left corner at point.

`M-x open-rectangle'
     Insert blank space to fill the space of the region-rectangle.  The
     previous contents of the region-rectangle are pushed rightward.

`M-x clear-rectangle'
     Clear the region-rectangle by replacing its contents with spaces.

   The rectangle operations fall into two classes: commands deleting and
moving rectangles, and commands for blank rectangles.

   There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed" rectangle.
The commands for these two ways are `M-x delete-rectangle' and `M-x
kill-rectangle'.  In either case, the portion of each line that falls
inside the rectangle's boundaries is deleted, causing following text
(if any) on the line to move left.

   Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that only records the most recently killed rectangle (that is, does not
append to a killed rectangle).  Different yank commands have to be used
and only one rectangle is stored, because yanking a rectangle is quite
different from yanking linear text and yank-popping commands are
difficult to make sense of.

   Inserting a rectangle is the opposite of deleting one.  You specify
where to put the upper left corner by putting point there.  The
rectangle's first line is inserted at point, the rectangle's second line
is inserted at a point one line vertically down, and so on.  The number
of lines affected is determined by the height of the saved rectangle.

   To insert the last killed rectangle, type `M-x yank-rectangle'.
This can be used to convert single-column lists into double-column
lists; kill the second half of the list as a rectangle and then yank it
beside the first line of the list.

   There are two commands for working with blank rectangles: `M-x
clear-rectangle' erases existing text, and `M-x open-rectangle' inserts
a blank rectangle.  Clearing a rectangle is equivalent to deleting it
and then inserting a blank rectangle of the same size.

   Rectangles can also be copied into and out of registers.  *Note
Rectangle Registers: RegRect.


File: xemacs.info,  Node: Registers,  Next: Display,  Prev: Rectangles,  Up: Top

Registers
*********

   XEmacs "registers" are places in which you can save text or
positions for later use.  Once you save text or a rectangle in a
register, you can copy it into the buffer once or many times; a position
saved in a register is used by moving point to that position.
Rectangles can also be copied into and out of registers (*note
Rectangles::).

   Each register has a name which is a single character.  A register can
store a piece of text, a rectangle, a position, a window configuration,
or a file name, but only one thing at any given time.  Whatever you
store in a register remains there until you store something else in that
register.  To see what a register R contains, use `M-x view-register'.

`M-x view-register <RET> R'
     Display a description of what register R contains.

   `M-x view-register' reads a register name as an argument and then
displays the contents of the specified register.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.


File: xemacs.info,  Node: RegPos,  Next: RegText,  Prev: Registers,  Up: Registers

Saving Positions in Registers
=============================

   Saving a position records a place in a buffer so that you can move
back there later.  Moving to a saved position switches to that buffer
and moves point to that place in it.

`C-x r <SPC> R'
     Save position of point in register R (`point-to-register').

`C-x r j R'
     Jump to the position saved in register R (`jump-to-register').

   To save the current position of point in a register, choose a name R
and type `C-x r <SPC> R'.  The register R retains the position thus
saved until you store something else in that register.

   The command `C-x r j R' moves point to the position recorded in
register R.  The register is not affected; it continues to record the
same location.  You can jump to the same position using the same
register as often as you want.

   If you use `C-x r j' to go to a saved position, but the buffer it
was saved from has been killed, `C-x r j' tries to create the buffer
again by visiting the same file.  Of course, this works only for buffers
that were visiting files.


File: xemacs.info,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

Saving Text in Registers
========================

   When you want to insert a copy of the same piece of text many times,
it can be impractical to use the kill ring, since each subsequent kill
moves the piece of text further down on the ring.  It becomes hard to
keep track of the argument needed to retrieve the same text with `C-y'.
An alternative is to store the text in a register with `C-x r s'
(`copy-to-register') and then retrieve it with `C-x r i'
(`insert-register').

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r g R'
`C-x r i R'
     Insert text contents of register R (`insert-register').

   `C-x r s R' stores a copy of the text of the region into the
register named R.  Given a numeric argument, `C-x r s R' deletes the
text from the buffer as well.

   `C-x r i R' inserts the text from register R in the buffer.  By
default it leaves point before the text and places the mark after it.
With a numeric argument (`C-u'), it puts point after the text and the
mark before it.


File: xemacs.info,  Node: RegRect,  Next: RegConfig,  Prev: RegText,  Up: Registers

Saving Rectangles in Registers
==============================

   A register can contain a rectangle instead of lines of text.  The
rectangle is represented as a list of strings.  *Note Rectangles::, for
basic information on rectangles and how to specify rectangles in a
buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-rectangle-to-register').  With a numeric argument, delete it
     as well.

`C-x r g R'
`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' command inserts linear text if the register
contains that, or inserts a rectangle if the register contains one.

   See also the command `sort-columns', which you can think of as
sorting a rectangle.  *Note Sorting::.


File: xemacs.info,  Node: RegConfig,  Next: RegNumbers,  Prev: RegRect,  Up: Registers

Saving Window Configurations in Registers
=========================================

   You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`M-x frame-configuration-to-register <RET> R'
     Save the state of all frames, including all their windows, in
     register R (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: xemacs.info,  Node: RegNumbers,  Next: RegFiles,  Prev: RegConfig,  Up: Registers

Keeping Numbers in Registers
============================

   There are commands to store a number in a register, to insert the
number in the buffer in decimal, and to increment it.  These commands
can be useful in keyboard macros (*note Keyboard Macros::).

`C-u NUMBER C-x r n REG'
     Store NUMBER into register REG (`number-to-register').

`C-u NUMBER C-x r + REG'
     Increment the number in register REG by NUMBER
     (`increment-register').

`C-x r g REG'
     Insert the number from register REG into the buffer.

   `C-x r g' is the same command used to insert any other sort of
register contents into the buffer.


File: xemacs.info,  Node: RegFiles,  Next: Bookmarks,  Prev: RegNumbers,  Up: Registers

Keeping File Names in Registers
===============================

   If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/usr/src/xemacs/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)


File: xemacs.info,  Node: Bookmarks,  Prev: RegFiles,  Up: Registers

Bookmarks
=========

   "Bookmarks" are somewhat like registers in that they record
positions you can jump to.  Unlike registers, they have long names, and
they persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

   Note: bookmark.el is distributed in edit-utils package.  You need to
install that to use bookmark facility (*note Packages::).

`C-x r m <RET>'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK <RET>'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK <RET>'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks').

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions or annotate the bookmarks.
Type `C-h m' in that buffer for more information about its special
editing commands.

   When you kill XEmacs, XEmacs offers to save your bookmark values in
your default bookmark file, `~/.emacs.bmk', if you have changed any
bookmark values.  You can also save the bookmarks at any time with the
`M-x bookmark-save' command.  The bookmark commands load your default
bookmark file automatically.  This saving and loading is how bookmarks
persist from one XEmacs session to the next.

   If you set the variable `bookmark-save-flag' to 1, then each command
that sets a bookmark will also save your bookmarks; this way, you don't
lose any bookmark values even if XEmacs crashes.  (The value, if a
number, says how many bookmark modifications should go by between
saving.)

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record, on each side of the bookmark's
position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load <RET> FILENAME <RET>'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write <RET> FILENAME <RET>'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete <RET> BOOKMARK <RET>'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-insert-location <RET> BOOKMARK <RET>'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert <RET> BOOKMARK <RET>'
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.


File: xemacs.info,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

Controlling the Display
***********************

   Since only part of a large buffer fits in the window, XEmacs tries
to show the part that is likely to be interesting.  The display control
commands allow you to specify which part of the text you want to see.

`C-l'
     Clear frame and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
`pgdn'
`next'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').  On most X keyboards, you can get this
     functionality using the key labelled `Page Down', which generates
     either `next' or `pgdn'.

`M-v'
`pgup'
`prior'
     Scroll backward (`scroll-down').  On most X keyboards, you can get
     this functionality using the key labelled `Page Up', which
     generates either `prior' or `pgup'.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-x <'
`C-pgdn'
`C-next'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
`C-pgup'
`C-prior'
     Scroll to the right (`scroll-right').

`C-x $'
     Make deeply indented lines invisible (`set-selective-display').

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* Display Vars::           Information on variables for customizing display.

