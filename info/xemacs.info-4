This is ../info/xemacs.info, produced by makeinfo version 4.0 from
xemacs/xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

Completion
==========

   For certain kinds of arguments, you can use "completion" to enter
the argument value.  Completion means that you type part of the
argument, then XEmacs visibly fills in the rest, or as much as can be
determined from the part you have typed.

   When completion is available, certain keys--<TAB>, <RET>, and
<SPC>--are rebound to complete the text present in the minibuffer into
a longer string that it stands for, by matching it against a set of
"completion alternatives" provided by the command reading the argument.
`?' is defined to display a list of possible completions of what you
have inserted.

   For example, when `M-x' uses the minibuffer to read the name of a
command, it provides a list of all available XEmacs command names to
complete against.  The completion keys match the text in the minibuffer
against all the command names, find any additional name characters
implied by the ones already present in the minibuffer, and add those
characters to the ones you have given.  This is what makes it possible
to type `M-x inse <SPC> b <RET>' instead of `M-x insert-buffer <RET>'
(for example).

   Case is normally significant in completion because it is significant
in most of the names that you can complete (buffer names, file names and
command names).  Thus, `fo' does not complete to `Foo'.  When you are
completing a name in which case does not matter, case may be ignored
for completion's sake if specified by program.

   When a completion list is displayed, the completions will highlight
as you move the mouse over them.  Clicking the middle mouse button on
any highlighted completion will "select" it just as if you had typed it
in and hit <RET>.

* Menu:

* Example: Completion Example.
* Commands: Completion Commands.
* Strict Completion::
* Options: Completion Options.


File: xemacs.info,  Node: Completion Example,  Next: Completion Commands,  Prev: Completion,  Up: Completion

Completion Example
------------------

   A concrete example may help here.  If you type `M-x au <TAB>', the
<TAB> looks for alternatives (in this case, command names) that start
with `au'.  There are several, including `auto-fill-mode' and
`auto-save-mode'--but they are all the same as far as `auto', so the
`au' in the minibuffer changes to `auto'.

   If you type <TAB> again immediately, there are multiple
possibilities for the very next character--it could be any of `c-'--so
no more characters are added; instead, <TAB> displays a list of all
possible completions in another window.

   If you go on to type `f <TAB>', this <TAB> sees `auto-f'.  The only
command name starting this way is `auto-fill-mode', so completion fills
in the rest of that.  You now have `auto-fill-mode' in the minibuffer
after typing just `au <TAB> f <TAB>'.  Note that <TAB> has this effect
because in the minibuffer it is bound to the command
`minibuffer-complete' when completion is available.


File: xemacs.info,  Node: Completion Commands,  Next: Strict Completion,  Prev: Completion Example,  Up: Completion

Completion Commands
-------------------

   Here is a list of the completion commands defined in the minibuffer
when completion is available.

`<TAB>'
     Complete the text in the minibuffer as much as possible
     (`minibuffer-complete').

`<SPC>'
     Complete the minibuffer text, but don't go beyond one word
     (`minibuffer-complete-word').

`<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described below
     (`minibuffer-complete-and-exit').

`?'
     Print a list of all possible completions of the text in the
     minibuffer (`minibuffer-list-completions').

`<button2>'
     Select the highlighted text under the mouse as a minibuffer
     response.  When the minibuffer is being used to prompt the user
     for a completion, any valid completions which are visible on the
     screen will be highlighted when the mouse moves over them.
     Clicking <button2> will select the highlighted completion and exit
     the minibuffer.  (`minibuf-select-highlighted-completion').

   <SPC> completes much like <TAB>, but never goes beyond the next
hyphen or space.  If you have `auto-f' in the minibuffer and type
<SPC>, it finds that the completion is `auto-fill-mode', but it stops
completing after `fill-'.  This gives `auto-fill-'.  Another <SPC> at
this point completes all the way to `auto-fill-mode'.  <SPC> in the
minibuffer when completion is available runs the command
`minibuffer-complete-word'.

   Here are some commands you can use to choose a completion from a
window that displays a list of completions:

`button2up'
     Clicking mouse button 2 on a completion in the list of possible
     completions chooses that completion (`mouse-choose-completion').
     You normally use this command while point is in the minibuffer;
     but you must click in the list of completions, not in the
     minibuffer itself.

`<RET>'
     Typing <RET> _in the completion list buffer_ chooses the
     completion that point is in or next to (`choose-completion').  To
     use this command, you must first switch windows to the window that
     shows the list of completions.

`<RIGHT>'
`<TAB>'
`C-f'
     Typing the right-arrow key <RIGHT>, <TAB> or `C-f' _in the
     completion list buffer_ moves point to the following completion
     (`next-list-mode-item').

`<LEFT>'
`C-b'
     Typing the left-arrow key <LEFT> or `C-b' _in the completion list
     buffer_ moves point toward the beginning of the buffer, to the
     previous completion (`previous-list-mode-item').


File: xemacs.info,  Node: Strict Completion,  Next: Completion Options,  Prev: Completion Commands,  Up: Completion

Strict Completion
-----------------

   There are three different ways that <RET> can work in completing
minibuffers, depending on how the argument will be used.

   * "Strict" completion is used when it is meaningless to give any
     argument except one of the known alternatives.  For example, when
     `C-x k' reads the name of a buffer to kill, it is meaningless to
     give anything but the name of an existing buffer.  In strict
     completion, <RET> refuses to exit if the text in the minibuffer
     does not complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     <RET> exits only if the text was an exact match already, not
     needing completion.  If the text is not an exact match, <RET> does
     not exit, but it does complete the text.  If it completes to an
     exact match, a second <RET> will exit.

     Cautious completion is used for reading file names for files that
     must already exist.

   * "Permissive" completion is used when any string whatever is
     meaningful, and the list of completion alternatives is just a
     guide.  For example, when `C-x C-f' reads the name of a file to
     visit, any file name is allowed, in case you want to create a
     file.  In permissive completion, <RET> takes the text in the
     minibuffer exactly as given, without completing it.

   The completion commands display a list of all possible completions in
a window whenever there is more than one possibility for the very next
character.  Also, typing `?' explicitly requests such a list.  If the
list of completions is long, you can scroll it with `C-M-v' (*note
Other Window::).


File: xemacs.info,  Node: Completion Options,  Prev: Strict Completion,  Up: Completion

Completion Options
------------------

   When completion is done on file names, certain file names are usually
ignored.  The variable `completion-ignored-extensions' contains a list
of strings; a file whose name ends in any of those strings is ignored
as a possible completion.  The standard value of this variable has
several elements including `".o"', `".elc"', `".dvi"' and `"~"'.  The
effect is that, for example, `foo' can complete to `foo.c' even though
`foo.o' exists as well.  However, if _all_ the possible completions end
in "ignored" strings, then they are not ignored.  Ignored extensions do
not apply to lists of completions--those always mention all possible
completions.

   If a completion command finds the next character is undetermined, it
automatically displays a list of all possible completions.  If the
variable `completion-auto-help' is set to `nil', this does not happen,
and you must type `?' to display the possible completions.

   If the variable `minibuffer-confirm-incomplete' is set to `t', then
in contexts where `completing-read' allows answers that are not valid
completions, an extra <RET> must be typed to confirm the response.
This is helpful for catching typos.


File: xemacs.info,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

Minibuffer History
==================

   Every argument that you enter with the minibuffer is saved on a
"minibuffer history list" so that you can use it again later in another
argument.  Special commands load the text of an earlier argument in the
minibuffer.  They discard the old minibuffer contents, so you can think
of them as moving through the history of previous arguments.

`<UP>'
`M-p'
     Move to the next earlier argument string saved in the minibuffer
     history (`previous-history-element').

`<DOWN>'
`M-n'
     Move to the next later argument string saved in the minibuffer
     history (`next-history-element').

`M-r REGEXP <RET>'
     Move to an earlier saved argument in the minibuffer history that
     has a match for REGEXP (`previous-matching-history-element').

`M-s REGEXP <RET>'
     Move to a later saved argument in the minibuffer history that has a
     match for REGEXP (`next-matching-history-element').

   The simplest way to reuse the saved arguments in the history list is
to move through the history list one element at a time.  While in the
minibuffer, use `M-p' or up-arrow (`previous-history-element') to "move
to" the next earlier minibuffer input, and use `M-n' or down-arrow
(`next-history-element') to "move to" the next later input.

   The previous input that you fetch from the history entirely replaces
the contents of the minibuffer.  To use it as the argument, exit the
minibuffer as usual with <RET>.  You can also edit the text before you
reuse it; this does not change the history element that you "moved" to,
but your new argument does go at the end of the history list in its own
right.

   For many minibuffer arguments there is a "default" value.  In some
cases, the minibuffer history commands know the default value.  Then you
can insert the default value into the minibuffer as text by using `M-n'
to move "into the future" in the history.

   There are also commands to search forward or backward through the
history; they search for history elements that match a regular
expression that you specify with the minibuffer.  `M-r'
(`previous-matching-history-element') searches older elements in the
history, while `M-s' (`next-matching-history-element') searches newer
elements.  By special dispensation, these commands can use the
minibuffer to read their arguments even though you are already in the
minibuffer when you issue them.  As with incremental searching, an
uppercase letter in the regular expression makes the search
case-sensitive (*note Search Case::).

   All uses of the minibuffer record your input on a history list, but
there are separate history lists for different kinds of arguments.  For
example, there is a list for file names, used by all the commands that
read file names.

   There are several other very specific history lists, including one
for command names read by `M-x', one for buffer names, one for arguments
of commands like `query-replace', and one for compilation commands read
by `compile'.  Finally, there is one "miscellaneous" history list that
most minibuffer arguments use.


File: xemacs.info,  Node: Repetition,  Prev: Minibuffer History,  Up: Minibuffer

Repeating Minibuffer Commands
=============================

   Every command that uses the minibuffer at least once is recorded on a
special history list, together with the values of its arguments, so that
you can repeat the entire command.  In particular, every use of `M-x'
is recorded there, since `M-x' uses the minibuffer to read the command
name.

`C-x <ESC> <ESC>'
     Re-execute a recent minibuffer command (`repeat-complex-command').

`M-p'
     Within `C-x <ESC>', move to previous recorded command
     (`previous-history-element').

`M-n'
     Within `C-x <ESC>', move to the next (more recent) recorded
     command (`next-history-element').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     <ESC> <ESC>' can repeat, most recent first.

   `C-x <ESC> <ESC>' is used to re-execute a recent minibuffer-using
command.  With no argument, it repeats the last such command.  A
numeric argument specifies which command to repeat; one means the last
one, and larger numbers specify earlier ones.

   `C-x <ESC> <ESC>' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  If you type just <RET>, the command is repeated as
before.  You can also change the command by editing the Lisp
expression.  Whatever expression you finally submit is what will be
executed.  The repeated command is added to the front of the command
history unless it is identical to the most recently executed command
already there.

   Even if you don't understand Lisp syntax, it will probably be obvious
which command is displayed for repetition.  If you do not change the
text, you can be sure the command will repeat exactly as before.

   If you are in the minibuffer for `C-x <ESC> <ESC>' and the command
shown to you is not the one you want to repeat, you can move around the
list of previous commands using `M-n' and `M-p'.  `M-p' replaces the
contents of the minibuffer with the next earlier recorded command, and
`M-n' replaces it with the next later command.  After finding the
desired previous command, you can edit its expression and then resubmit
it by typing <RET>.  Any editing you have done on the command to be
repeated is lost if you use `M-n' or `M-p'.

   `M-n' and `M-p' are specially defined within `C-x <ESC> <ESC>' to
run the commands `previous-history-element' and `next-history-element'.

   The list of previous commands using the minibuffer is stored as a
Lisp list in the variable `command-history'.  Each element of the list
is a Lisp expression which describes one command and its arguments.
Lisp programs can reexecute a command by feeding the corresponding
`command-history' element to `eval'.


File: xemacs.info,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

Running Commands by Name
************************

   The Emacs commands that are used often or that must be quick to type
are bound to keys--short sequences of characters--for convenient use.
Other Emacs commands that are used more rarely are not bound to keys;
to run them, you must refer to them by name.

   A command name consists, by convention, of one or more words,
separated by hyphens: for example, `auto-fill-mode' or `manual-entry'.
The use of English words makes the command name easier to remember than
a key made up of obscure characters, even though it results in more
characters to type.  You can run any command by name, even if it can be
run by keys as well.

   To run a command by name, start with `M-x', then type the command
name, and finish with <RET>.  `M-x' uses the minibuffer to read the
command name.  <RET> exits the minibuffer and runs the command.

   Emacs uses the minibuffer for reading input for many different
purposes; on this occasion, the string `M-x' is displayed at the
beginning of the minibuffer as a "prompt" to remind you that your input
should be the name of a command to be run.  *Note Minibuffer::, for
full information on the features of the minibuffer.

   You can use completion to enter a command name.  For example, to
invoke the command `forward-char', type:

     M-x forward-char <RET>
   or
     M-x fo <TAB> c <RET>

After you type in `M-x fo TAB' emacs will give you a possible list of
completions from which you can choose. Note that `forward-char' is the
same command that you invoke with the key `C-f'.  You can call any
command (interactively callable function) defined in Emacs by its name
using `M-x' regardless of whether or not any keys are bound to it.

   If you type `C-g' while Emacs reads the command name, you cancel the
`M-x' command and get out of the minibuffer, ending up at top level.

   To pass a numeric argument to a command you are invoking with `M-x',
specify the numeric argument before the `M-x'.  `M-x' passes the
argument along to the function that it calls.  The argument value
appears in the prompt while the command name is being read.

   You can use the command `M-x interactive' to specify a way of
parsing arguments for interactive use of a function.  For example,
write:

       (defun foo (arg) "Doc string" (interactive "p") ...use arg...)

   to make `arg' be the prefix argument when `foo' is called as a
command.  The call to `interactive' is actually a declaration rather
than a function; it tells `call-interactively' how to read arguments to
pass to the function.  When actually called, `interactive' returns
`nil'.

   The argument of INTERACTIVE is usually a string containing a code
letter followed by a prompt.  Some code letters do not use I/O to get
the argument and do not need prompts.  To prompt for multiple arguments,
you must provide a code letter, its prompt, a newline, and another code
letter, and so forth.  If the argument is not a string, it is evaluated
to get a list of arguments to pass to the function.  If you do not
provide an argument to `interactive', no arguments are passed when
calling interactively.

   Available code letters are:

`a'
     Function name: symbol with a function definition

`b'
     Name of existing buffer

`B'
     Name of buffer, possibly nonexistent

`c'
     Character

`C'
     Command name: symbol with interactive function definition

`d'
     Value of point as number (does not do I/O)

`D'
     Directory name

`e'
     Last mouse event

`f'
     Existing file name

`F'
     Possibly nonexistent file name

`k'
     Key sequence (string)

`m'
     Value of mark as number (does not do I/O)

`n'
     Number read using minibuffer

`N'
     Prefix arg converted to number, or if none, do like code `n'

`p'
     Prefix arg converted to number (does not do I/O)

`P'
     Prefix arg in raw form (does not do I/O)

`r'
     Region: point and mark as two numeric arguments, smallest first
     (does not do I/O)

`s'
     Any string

`S'
     Any symbol

`v'
     Variable name: symbol that is `user-variable-p'

`x'
     Lisp expression read but not evaluated

`X'
     Lisp expression read and evaluated

   In addition, if the string begins with `*', an error is signaled if
the buffer is read-only.  This happens before reading any arguments.
If the string begins with `@', the window the mouse is over is selected
before anything else is done.  You may use both `@' and `*'; they are
processed in the order that they appear.

   Normally, when describing a command that is run by name, we omit the
<RET> that is needed to terminate the name.  Thus we may refer to `M-x
auto-fill-mode' rather than `M-x auto-fill-mode' <RET>.  We mention the
<RET> only when it is necessary to emphasize its presence, for example,
when describing a sequence of input that contains a command name and
arguments that follow it.

   `M-x' is defined to run the command `execute-extended-command',
which is responsible for reading the name of another command and
invoking it.


File: xemacs.info,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

Help
****

   XEmacs provides extensive help features accessible through a single
character, `C-h'.  `C-h' is a prefix key that is used only for
documentation-printing commands.  The characters that you can type after
`C-h' are called "help options".  One help option is `C-h'; that is how
you ask for help about using `C-h'.  To cancel, type `C-g'.  The
function key <F1> is equivalent to `C-h'.

   `C-h C-h' (`help-for-help') displays a list of the possible help
options, and then asks you to type the desired option.  It prompts with
the string:

     A B C F I K L M N P S T V W C-c C-d C-f C-i C-k C-n C-w;  ? for more help:

You should type one of those characters.

   Typing a third `C-h' displays a description of what the options mean;
Emacs still waits for you to type an option.  To cancel, type `C-g'.

   Most help buffers use a special major mode, Help mode, which lets you
scroll conveniently with <SPC> and <DEL> or <BS>.

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in XEmacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Help Mode::           Special features of Help mode and Help buffers.
* Misc Help::		Other help commands.


File: xemacs.info,  Node: Help Summary,  Next: Key Help,  Prev: Help,  Up: Help

Help Summary
============

   Here is a summary of the defined help commands.

`C-h a REGEXP <RET>'
     Display a list of functions and variables whose names match REGEXP
     (`heper-apropos').

`C-h A REGEXP'
     Show all commands whose names contain matches for REGEXP
     (`command-apropos').

`C-h b'
     Display a table of all key bindings currently in effect, with local
     bindings of the current major mode first, followed by all global
     bindings (`describe-bindings').

`C-h c KEY'
     Print the name of the command that KEY runs
     (`describe-key-briefly').  Here `c' stands for `character'.  For
     more extensive information on KEY, use `C-h k'.

`C-h d FUNCTION <RET>'
`C-h f FUNCTION <RET>'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Since commands are Lisp functions, a
     command name may be used.

`C-h i'
     Run Info, the program for browsing documentation files (`info').
     The complete XEmacs manual is available online in Info.

`C-h k KEY'
     Display the name and documentation of the command that KEY runs
     (`describe-key').

`C-h l'
     Display a description of the last 100 characters you typed
     (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h n'
`C-h C-n'
     Display documentation of XEmacs changes, most recent first
     (`view-emacs-news').

`C-h p'
     Find packages by topic keyword (`finder-by-keyword').

`C-h C-p'
     Display a table of all mouse bindings currently in effect now, with
     local bindings of the current major mode first, followed by all
     global bindings (`describe-pointer').

`C-h s'
     Display current contents of the syntax table, plus an explanation
     of what they mean (`describe-syntax').  *Note Syntax::.

`C-h t'
     Enter the XEmacs interactive tutorial (`help-with-tutorial').

`C-h v VAR <RET>'
     Display the documentation of the Lisp variable VAR
     (`describe-variable').

`C-h w COMMAND <RET>'
     Print which keys run the command named COMMAND (`where-is').

`C-h B <RET>'
     Display info on how to deal with Beta versions of XEmacs
     (`describe-beta').

`C-h C GROUP <RET>'
     Select customization buffer for GROUP (`customize').

`C-h F <RET>'
     View the local copy of the XEmacs FAQ (`xemacs-local-faq').

`C-h C-i FILE <RET>'
     Read Info file FILE with Info browser (`Info-query').

`C-h C-c COMMAND <RET>'
     Look up an Emacs command COMMAND in the Emacs manual in the Info
     system (`Info-goto-emacs-command-node').

`C-h C-f FUNCTION <RET>'
     Look up an Emacs Lisp function FUNCTION in the Elisp manual in the
     Info system (`Info-elisp-ref').


File: xemacs.info,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

Documentation for a Key
=======================

   The most basic `C-h' options are `C-h c' (`describe-key-briefly')
and `C-h k' (`describe-key').  `C-h c KEY' prints in the echo area the
name of the command that KEY is bound to.  For example, `C-h c C-f'
prints `forward-char'.  Since command names are chosen to describe what
the commands do, this is a good way to get a very brief description of
what KEY does.

   `C-h k KEY' is similar to `C-h c' but gives more information.  It
displays the documentation string of the function KEY is bound to as
well as its name.  KEY is a string or vector of events.  When called
interactively, KEY may also be a menu selection.  This information does
not usually fit into the echo area, so a window is used for the display.

   `C-h c' and `C-h k' work for any sort of key sequences, including
function keys and mouse events.


File: xemacs.info,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

Help by Command or Variable Name
================================

   `C-h f' (`describe-function') reads the name of a Lisp function
using the minibuffer, then displays that function's documentation
string in a window.  Since commands are Lisp functions, you can use the
argument FUNCTION to get the documentation of a command that you know
by name.  For example,

     C-h f auto-fill-mode <RET>

displays the documentation for `auto-fill-mode'. Using `C-h f' is the
only way to see the documentation of a command that is not bound to any
key, that is, a command you would normally call using `M-x'.  If the
variable `describe-function-show-arglist' is `t', `describe-function'
shows its arglist if the FUNCTION is not an autoload function.

   `C-h f' is also useful for Lisp functions that you are planning to
use in a Lisp program.  For example, if you have just written the
expression `(make-vector len)' and want to make sure you are using
`make-vector' properly, type `C-h f make-vector <RET>'.  Because `C-h
f' allows all function names, not just command names, you may find that
some of your favorite abbreviations that work in `M-x' don't work in
`C-h f'.  An abbreviation may be unique among command names, yet fail
to be unique when other function names are allowed.

   The function name for `C-h f' to describe has a default which is
used if you type <RET> leaving the minibuffer empty.  The default is
the function called by the innermost Lisp expression in the buffer
around point, _provided_ that is a valid, defined Lisp function name.
For example, if point is located following the text `(make-vector (car
x)', the innermost list containing point is the one that starts with
`(make-vector', so the default is to describe the function
`make-vector'.

   `C-h f' is often useful just to verify that you have the right
spelling for the function name.  If `C-h f' mentions a name from the
buffer as the default, that name must be defined as a Lisp function.  If
that is all you want to know, just type `C-g' to cancel the `C-h f'
command, then go on editing.

   `C-h w COMMAND <RET>' (`where-is') tells you what keys are bound to
COMMAND.  It prints a list of the keys in the echo area. Alternatively,
it informs you that a command is not bound to any keys, which implies
that you must use `M-x' to call the command.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a known Lisp variable.
*Note Variables::.


File: xemacs.info,  Node: Apropos,  Next: Library Keywords,  Prev: Name Help,  Up: Help

Apropos
=======

`C-h A'
     Show only symbols that are names of commands (`command-apropos').

`M-x apropos REGEXP'
     Show all symbols whose names comtain matches for REGEXP.

   A more sophisticated sort of question to ask is, "What are the
commands for working with files?"  To ask this question, type `C-h a
file <RET>', which displays a list of all command names that contain
`file', including `copy-file', `find-file', and so on.  With each
command name appears a brief description of how to use the command, and
what keys you can currently invoke it with.  For example, it would say
that you can invoke `find-file' by typing `C-x C-f'.  The `A' in `C-h
A' stands for `Apropos'; `C-h A' runs the command `command-apropos'.
This command normally checks only commands (interactive functions); if
you specify a prefix argument, it checks noninteractive functions as
well.

   Because `C-h A' looks only for functions whose names contain the
string you specify, you must use ingenuity in choosing the string.  If
you are looking for commands for killing backwards and `C-h a
kill-backwards <RET>' doesn't reveal any, don't give up.  Try just
`kill', or just `backwards', or just `back'.  Be persistent.  Pretend
you are playing Adventure.  Also note that you can use a regular
expression as the argument, for more flexibility (*note Regexps::).

   Here is a set of arguments to give to `C-h a' that covers many
classes of XEmacs commands, since there are strong conventions for
naming the standard XEmacs commands.  By giving you a feel for the
naming conventions, this set should also serve to aid you in developing
a technique for picking `apropos' strings.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe, default.

   To list all Lisp symbols that contain a match for a regexp, not just
the ones that are defined as commands, use the command `M-x apropos'
instead of `C-h A'.  This command does not check key bindings by
default; specify a numeric argument if you want it to check them.

   The `apropos-documentation' command is like `apropos' except that it
searches documentation strings for matches for the specified regular
expression.

   The `apropos-value' command is like `apropos' except that it
searches symbols' values for matches for the specified regular
expression.  This command does not check function definitions or
property lists by default; specify a numeric argument if you want it to
check them.

   If the variable `apropos-do-all' is non-`nil', the commands above
all behave as if they had been given a prefix argument.

   If you want more information about a function definition, variable or
symbol property listed in the Apropos buffer, you can click on it with
`Mouse-2' or move there and type <RET>.


File: xemacs.info,  Node: Library Keywords,  Next: Help Mode,  Prev: Apropos,  Up: Help

Keyword Search for Lisp Libraries
=================================

   The `C-h p' command lets you search the standard Emacs Lisp
libraries by topic keywords.  Here is a partial list of keywords you can
use:

     abbrev        abbreviation handling, typing shortcuts, macros
     bib           code related to the `bib' bibliography processor
     c             C, C++, and Objective-C language support
     calendar      calendar and time management support
     comm          communications, networking, remote access to files
     data          support for editing files of data
     docs          support for Emacs documentation
     dumped        files preloaded into Emacs
     emulations    emulations of other editors
     extensions    Emacs Lisp language extensions
     faces         support for multiple fonts
     frames        support for Emacs frames and window systems
     games         games, jokes and amusements
     hardware      support for interfacing with exotic hardware
     help          support for on-line help systems
     hypermedia    support for links between text or other media types
     i18n          internationalization and alternate character-set support
     internal      code for Emacs internals, build process, defaults
     languages     specialized modes for editing programming languages
     lisp          Lisp support, including Emacs Lisp
     local         code local to your site
     maint         maintenance aids for the Emacs development group
     mail          modes for electronic-mail handling
     matching      various sorts of searching and matching
     mouse         mouse support
     mule          multi-language extensions
     news          support for netnews reading and posting
     oop           support for object-oriented programming
     outlines      support for hierarchical outlining
     processes     process, subshell, compilation, and job control support
     terminals     support for terminal types
     tex           code related to the TeX formatter
     tools         programming tools
     unix          front-ends/assistants for, or emulators of, UNIX features
     vms           support code for vms
     wp            word processing


File: xemacs.info,  Node: Help Mode,  Next: Misc Help,  Prev: Library Keywords,  Up: Help

Help Mode Commands
==================

   Help buffers provide the commands of View mode (*note Misc File
Ops::), plus a few special commands of their own.

`<SPC>'
     Scroll forward.

`<DEL>'
`<BS>'
     Scroll backward.

   When a command name (*note Running Commands by Name: M-x.) or
variable name (*note Variables::) appears in the documentation, it
normally appears inside paired single-quotes.


File: xemacs.info,  Node: Misc Help,  Prev: Help Mode,  Up: Help

Other Help Commands
===================

   `C-h i' (`info') runs the Info program, which is used for browsing
through structured documentation files.  The entire XEmacs manual is
available within Info.  Eventually all the documentation of the GNU
system will be available.  Type `h' after entering Info to run a
tutorial on using Info.

   If you specify a numeric argument, `C-h i' prompts for the name of a
documentation file.  This way, you can browse a file which doesn't have
an entry in the top-level Info menu.  It is also handy when you need to
get to the documentation quickly, and you know the exact name of the
file.

   There are two special help commands for accessing XEmacs
documentation through Info.  `C-h C-f FUNCTION <RET>' enters Info and
goes straight to the documentation of the XEmacs function FUNCTION.
`C-h C-k KEY' enters Info and goes straight to the documentation of the
key KEY.  These two keys run the commands `Info-elisp-ref' and
`Info-goto-emacs-key-command-node'.

   If something surprising happens, and you are not sure what commands
you typed, use `C-h l' (`view-lossage').  `C-h l' prints the last 100
command characters you typed in.  If you see commands that you don't
know, you can use `C-h c' to find out what they do.

   XEmacs has several major modes.  Each mode redefines a few keys and
makes a few other changes in how editing works.  `C-h m'
(`describe-mode') prints documentation on the current major mode, which
normally describes all the commands that are changed in this mode.

   `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax')
present information about the current XEmacs mode that is not covered
by `C-h m'.  `C-h b' displays a list of all the key bindings currently
in effect, with the local bindings of the current major mode first,
followed by the global bindings (*note Key Bindings::).  `C-h s'
displays the contents of the syntax table with explanations of each
character's syntax (*note Syntax::).

   You can get a similar list for a particular prefix key by typing
`C-h' after the prefix key.  (There are a few prefix keys for which
this does not work--those that provide their own bindings for `C-h'.
One of these is <ESC>, because `<ESC> C-h' is actually `C-M-h', which
marks a defun.)

   The other `C-h' options display various files of useful information.
`C-h C-w' (`describe-no-warranty') displays the full details on the
complete absence of warranty for XEmacs.  `C-h n' (`view-emacs-news')
displays the file `xemacs/etc/NEWS', which contains documentation on
XEmacs changes arranged chronologically.  `C-h F' (`xemacs-local-faq')
displays local version of the XEmacs
frequentliy-answered-questions-list.  `C-h t' (`help-with-tutorial')
displays the learn-by-doing XEmacs tutorial. `C-h C-c'
(`describe-copying') displays the file `xemacs/etc/COPYING', which
tells you the conditions you must obey in distributing copies of
XEmacs.  `C-h C-d' (`describe-distribution') displays another file named
`xemacs/etc/DISTRIB', which tells you how you can order a copy of the
latest version of XEmacs.


File: xemacs.info,  Node: Mark,  Next: Mouse Selection,  Prev: Help,  Up: Top

Selecting Text
**************

   Many Emacs commands operate on an arbitrary contiguous part of the
current buffer. You can select text in two ways:

   * You use special keys to select text by defining a region between
     point and the mark.

   * If you are running XEmacs under X, you can also select text with
     the mouse.

The Mark and the Region
=======================

   To specify the text for a command to operate on, set "the mark" at
one end of it, and move point to the other end.  The text between point
and the mark is called "the region".  You can move point or the mark to
adjust the boundaries of the region.  It doesn't matter which one is
set first chronologically, or which one comes earlier in the text.

   Once the mark has been set, it remains until it is set again at
another place.  The mark remains fixed with respect to the preceding
character if text is inserted or deleted in a buffer.  Each Emacs
buffer has its own mark; when you return to a buffer that had been
selected previously, it has the same mark it had before.

   Many commands that insert text, such as `C-y' (`yank') and `M-x
insert-buffer', position the mark at one end of the inserted text--the
opposite end from where point is positioned, so that the region
contains the text just inserted.

   Aside from delimiting the region, the mark is useful for marking a
spot that you may want to go back to.  To make this feature more useful,
Emacs remembers 16 previous locations of the mark in the `mark ring'.

* Menu:

* Setting Mark::	Commands to set the mark.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.


File: xemacs.info,  Node: Setting Mark,  Next: Using Region,  Prev: Mark,  Up: Mark

Setting the Mark
----------------

   Here are some commands for setting the mark:

`C-<SPC>'
     Set the mark where point is (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

`C-<'
     Pushes a mark at the beginning of the buffer.

`C->'
     Pushes a mark at the end of the buffer.

   For example, to convert part of the buffer to all upper-case, you
can use the `C-x C-u' (`upcase-region') command, which operates on the
text in the region.  First go to the beginning of the text you want to
capitalize and type `C-<SPC>' to put the mark there, then move to the
end, and then type `C-x C-u' to capitalize the selected region.  You
can also set the mark at the end of the text, move to the beginning,
and then type `C-x C-u'.  Most commands that operate on the text in the
region have the word `region' in their names.

   The most common way to set the mark is with the `C-<SPC>' command
(`set-mark-command').  This command sets the mark where point is. You
can then move point away, leaving the mark behind.  It is actually
incorrect to speak of the character `C-<SPC>'; there is no such
character.  When you type <SPC> while holding down <CTRL>, you get the
character `C-@' on most terminals. This character is actually bound to
`set-mark-command'.  But unless you are unlucky enough to have a
terminal where typing `C-<SPC>' does not produce `C-@', you should
think of this character as `C-<SPC>'.

   Since terminals have only one cursor, Emacs cannot show you where the
mark is located. Most people use the mark soon after they set it, before
they forget where it is. But you can see where the mark is with the
command `C-x C-x' (`exchange-point-and-mark') which puts the mark where
point was and point where the mark was.  The extent of the region is
unchanged, but the cursor and point are now at the previous location of
the mark.

   Another way to set the mark is to push the mark to the beginning of a
buffer while leaving point at its original location. If you supply an
argument to `C-<' (`mark-beginning-of-buffer'), the mark is pushed N/10
of the way from the true beginning of the buffer. You can also set the
mark at the end of a buffer with `C->' (`mark-end-of-buffer'). It
pushes the mark to the end of the buffer, leaving point alone.
Supplying an argument to the command pushes the mark N/10 of the way
from the true end of the buffer.

   If you are using XEmacs under the X window system, you can set the
variable `zmacs-regions' to `t'. This makes the current region (defined
by point and mark) highlight and makes it available as the X clipboard
selection, which means you can use the menu bar items on it.  *Note
Active Regions::, for more information.

   `C-x C-x' is also useful when you are satisfied with the location of
point but want to move the mark; do `C-x C-x' to put point there and
then you can move it.  A second use of `C-x C-x', if necessary, puts
the mark at the new location with point back at its original location.


File: xemacs.info,  Node: Using Region,  Next: Marking Objects,  Prev: Setting Mark,  Up: Mark

Operating on the Region
-----------------------

   Once you have created an active region, you can do many things to
the text in it:
   * Kill it with `C-w' (*note Killing::).

   * Save it in a register with `C-x r s' (*note Registers::).

   * Save it in a buffer or a file (*note Accumulating Text::).

   * Convert case with `C-x C-l' or `C-x C-u'
     (*note Case::).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::).

   * Fill it as text with `M-q' (*note Filling::).

   * Print hardcopy with `M-x print-region' (*note Hardcopy::).

   * Indent it with `C-x <TAB>' or `C-M-\' (*note Indentation::).


File: xemacs.info,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

Commands to Mark Textual Objects
--------------------------------

   There are commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of next Lisp expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current Lisp defun (`mark-defun').

`C-x h'
     Put region around entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

   `M-@' (`mark-word') puts the mark at the end of the next word, while
`C-M-@' (`mark-sexp') puts it at the end of the next Lisp expression.
These characters sometimes save you some typing.

   A number of commands are available that set both point and mark and
thus delimit an object in the buffer.  `M-h' (`mark-paragraph') moves
point to the beginning of the paragraph that surrounds or follows
point, and puts the mark at the end of that paragraph (*note
Paragraphs::).  You can then indent, case-convert, or kill the whole
paragraph.  In the same fashion, `C-M-h' (`mark-defun') puts point
before and the mark after the current or following defun (*note
Defuns::).  `C-x C-p' (`mark-page') puts point before the current page
(or the next or previous, depending on the argument), and mark at the
end (*note Pages::).  The mark goes after the terminating page
delimiter (to include it), while point goes after the preceding page
delimiter (to exclude it).  Finally, `C-x h' (`mark-whole-buffer') sets
up the entire buffer as the region by putting point at the beginning
and the mark at the end.


File: xemacs.info,  Node: Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
-------------

   Aside from delimiting the region, the mark is also useful for marking
a spot that you may want to go back to.  To make this feature more
useful, Emacs remembers 16 previous locations of the mark in the "mark
ring".  Most commands that set the mark push the old mark onto this
ring.  To return to a marked location, use `C-u C-<SPC>' (or `C-u
C-@'); this is the command `set-mark-command' given a numeric argument.
The command moves point to where the mark was, and restores the mark
from the ring of former marks. Repeated use of this command moves point
to all the old marks on the ring, one by one.  The marks you have seen
go to the end of the ring, so no marks are lost.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-<SPC>' always stays
in the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This makes it easier for you to move back
later.  Searches set the mark, unless they do not actually move point.
When a command sets the mark, `Mark Set' is printed in the echo area.

   The variable `mark-ring-max' is the maximum number of entries to
keep in the mark ring.  If that many entries exist and another entry is
added, the last entry in the list is discarded.  Repeating `C-u
C-<SPC>' circulates through the entries that are currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.


File: xemacs.info,  Node: Mouse Selection,  Next: Additional Mouse Operations,  Prev: Mark,  Up: Top

Selecting Text with the Mouse
=============================

   If you are using XEmacs under X, you can use the mouse pointer to
select text. (The normal mouse pointer is an I-beam, the same pointer
that `xterm' uses.)

   The glyph variable `text-pointer-glyph' controls the shape of the
mouse pointer when over text.  You can also control the shape of the
mouse pointer when over nontext using `nontext-pointer-glyph', and the
shape of the mouse pointer when over the modeline using
`modeline-pointer-glyph'. (Remember, you should use `set-glyph-image',
not `setq', to set one of these variables.)

   If you want to get fancy, you can set the foreground and background
colors of the mouse pointer by setting the `pointer' face.

   There are two ways to select a region of text with the mouse:

   To select a word in text, double-click with the left mouse button
while the mouse cursor is over the word.  The word is highlighted when
selected. On monochrome monitors, a stippled background indicates that a
region of text has been highlighted. On color monitors, a color
background indicates highlighted text. You can triple-click to select
whole lines.

   To select an arbitrary region of text:

  1. Move the mouse cursor over the character at the beginning of the
     region of text you want to select.

  2. Press and hold the left mouse button.

  3. While holding the left mouse button down, drag the cursor to the
     character at the end of the region of text you want to select.

  4. Release the left mouse button.
        The selected region of text is highlighted.

   Once a region of text is selected, it becomes the primary X selection
(*note Using X Selections::) as well as the Emacs selected region. You
can paste it into other X applications and use the options from the
Edit pull-down menu on it.  Since it is also the Emacs region, you can
use Emacs region commands on it.

