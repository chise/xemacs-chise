This is ../info/xemacs.info, produced by makeinfo version 4.0 from
xemacs/xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

Cursor Position Information
===========================

   If you are accustomed to other display editors, you may be surprised
that Emacs does not always display the page number or line number of
point in the mode line.  In Emacs, this information is only rarely
needed, and a number of commands are available to compute and print it.
Since text is stored in a way that makes it difficult to compute the
information, it is not displayed all the time.

`M-x what-page'
     Print page number of point, and line number within page.

`M-x what-line'
     Print line number of point in the buffer.

`M-x line-number-mode'
     Toggle automatic display of current line number.

`M-='
     Print number of lines and characters in the current region
     (`count-lines-region').  *Note Mark::, for information about the
     region.

`C-x ='
     Print character code of character after point, character position
     of point, and column of point (`what-cursor-position').

   There are several commands for printing line numbers:

   * `M-x what-line' counts lines from the beginning of the file and
     prints the line number point is on.  The first line of the file is
     line number 1.  You can use these numbers as arguments to `M-x
     goto-line'.

   * `M-x what-page' counts pages from the beginning of the file, and
     counts lines within the page, printing both of them.  *Note
     Pages::, for the command `C-x l', which counts the lines in the
     current page.

   * `M-=' (`count-lines-region') prints the number of lines in the
     region (*note Mark::).  *Note Pages::, for the command `C-x l'
     which counts the lines in the

   The command `C-x =' (`what-cursor-position') can be used to find out
the column that the cursor is in, and other miscellaneous information
about point.  It prints a line in the echo area that looks like this:

     Char: c (0143, 99, 0x63)  point=18862 of 24800(76%)  column 53

(In fact, this is the output produced when point is before `column 53'
in the example.)

   The four values after `Char:' describe the character that follows
point, first by showing it and then by giving its character code in
octal, decimal and hex.

   `point=' is followed by the position of point expressed as a
character count.  The front of the buffer counts as position 1, one
character later as 2, and so on.  The next, larger number is the total
number of characters in the buffer.  Afterward in parentheses comes the
position expressed as a percentage of the total size.

   `column' is followed by the horizontal position of point, in columns
from the left edge of the window.

   If the buffer has been narrowed, making some of the text at the
beginning and the end temporarily invisible, `C-x =' prints additional
text describing the current visible range.  For example, it might say:

     Char: c (0143, 99, 0x63)  point=19674 of 24575(80%) <19591 - 19703>  column 69

where the two extra numbers give the smallest and largest character
position that point is allowed to assume.  The characters between those
two positions are the visible ones.  *Note Narrowing::.

   If point is at the end of the buffer (or the end of the visible
part), `C-x =' omits any description of the character after point.  The
output looks like

     point=563026 of 563025(100%)  column 0


File: xemacs.info,  Node: Arguments,  Prev: Position Info,  Up: Basic

Numeric Arguments
=================

   In mathematics and computer usage, the word "argument" means "data
provided to a function or operation."  Any Emacs command can be given a
"numeric argument" (also called a "prefix argument").  Some commands
interpret the argument as a repetition count.  For example, giving an
argument of ten to the key `C-f' (the command `forward-char', move
forward one character) moves forward ten characters.  With these
commands, no argument is equivalent to an argument of one.  Negative
arguments are allowed.  Often they tell a command to move or act  in
the opposite direction.

   If your keyboard has a <META> key (labelled with a diamond on
Sun-type keyboards and labelled `Alt' on some other keyboards), the
easiest way to specify a numeric argument is to type digits and/or a
minus sign while holding down the <META> key.  For example,
     M-5 C-n

would move down five lines.  The characters `Meta-1', `Meta-2', and so
on, as well as `Meta--', do this because they are keys bound to
commands (`digit-argument' and `negative-argument') that are defined to
contribute to an argument for the next command.  Digits and `-'
modified with Control, or Control and Meta, also specify numeric
arguments.

   Another way of specifying an argument is to use the `C-u'
(`universal-argument') command followed by the digits of the argument.
With `C-u', you can type the argument digits without holding down
modifier keys; `C-u' works on all terminals.  To type a negative
argument, type a minus sign after `C-u'.  Just a minus sign without
digits normally means -1.

   `C-u' followed by a character which is neither a digit nor a minus
sign has the special meaning of "multiply by four".  It multiplies the
argument for the next command by four.  `C-u' twice multiplies it by
sixteen.  Thus, `C-u C-u C-f' moves forward sixteen characters.  This
is a good way to move forward "fast", since it moves about 1/5 of a line
in the usual size frame.  Other useful combinations are `C-u C-n', `C-u
C-u C-n' (move down a good fraction of a frame), `C-u C-u C-o' (make "a
lot" of blank lines), and `C-u C-k' (kill four lines).

   Some commands care only about whether there is an argument and not
about its value.  For example, the command `M-q' (`fill-paragraph') with
no argument fills text; with an argument, it justifies the text as well.
(*Note Filling::, for more information on `M-q'.)  Just `C-u' is a
handy way of providing an argument for such commands.

   Some commands use the value of the argument as a repeat count, but do
something peculiar when there is no argument.  For example, the command
`C-k' (`kill-line') with argument N kills N lines, including their
terminating newlines.  But `C-k' with no argument is special: it kills
the text up to the next newline, or, if point is right at the end of
the line, it kills the newline itself.  Thus, two `C-k' commands with
no arguments can kill a non-blank line, just like `C-k' with an
argument of one.  (*Note Killing::, for more information on `C-k'.)

   A few commands treat a plain `C-u' differently from an ordinary
argument.  A few others may treat an argument of just a minus sign
differently from an argument of -1.  These unusual cases are described
when they come up; they are always for reasons of convenience of use of
the individual command.

   You can use a numeric argument to insert multiple copies of a
character.  This is straightforward unless the character is a digit; for
example, `C-u 6 4 a' inserts 64 copies of the character `a'.  But this
does not work for inserting digits; `C-u 6 4 1' specifies an argument
of 641, rather than inserting anything.  To separate the digit to
insert from the argument, type another `C-u'; for example, `C-u 6 4 C-u
1' does insert 64 copies of the character `1'.

   We use the term "prefix argument" as well as "numeric argument" to
emphasize that you type the argument before the command, and to
distinguish these arguments from minibuffer arguments that come after
the command.


File: xemacs.info,  Node: Undo,  Next: Minibuffer,  Prev: Basic,  Up: Top

Undoing Changes
***************

   Emacs allows you to undo all changes you make to the text of a
buffer, up to a certain amount of change (8000 characters).  Each
buffer records changes individually, and the undo command always
applies to the current buffer.  Usually each editing command makes a
separate entry in the undo records, but some commands such as
`query-replace' make many entries, and very simple commands such as
self-inserting characters are often grouped to make undoing less
tedious.

`C-x u'
     Undo one batch of changes (usually, one command's worth) (`undo').

`C-_'
     The same.

   The command `C-x u' or `C-_' allows you to undo changes.  The first
time you give this command, it undoes the last change.  Point moves to
the text affected by the undo, so you can see what was undone.

   Consecutive repetitions of the `C-_' or `C-x u' commands undo
earlier and earlier changes, back to the limit of what has been
recorded.  If all recorded changes have already been undone, the undo
command prints an error message and does nothing.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting at this moment, the previous undo commands are
considered ordinary changes that can themselves be undone.  Thus, you
can redo changes you have undone by typing `C-f' or any other command
that have no important effect, and then using more undo commands.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  When that happens, all the
modifications you made have been canceled.  If you do not remember
whether you changed the buffer deliberately, type `C-_' once. When you
see Emacs undo the last change you made, you probably remember why you
made it.  If the change was an accident, leave it undone.  If it was
deliberate, redo the change as described in the preceding paragraph.

   Whenever an undo command makes the stars disappear from the mode
line, the buffer contents is the same as it was when the file was last
read in or saved.

   Not all buffers record undo information.  Buffers whose names start
with spaces don't; these buffers are used internally by Emacs and its
extensions to hold text that users don't normally look at or edit.
Minibuffers, help buffers, and documentation buffers also don't record
undo information.

   Emacs can remember at most 8000 or so characters of deleted or
modified text in any one buffer for reinsertion by the undo command.
There is also a limit on the number of individual insert, delete, or
change actions that Emacs can remember.

   There are two keys to run the `undo' command, `C-x u' and `C-_',
because on some keyboards, it is not obvious how to type `C-_'. `C-x u'
is an alternative you can type in the same fashion on any terminal.


File: xemacs.info,  Node: Minibuffer,  Next: M-x,  Prev: Undo,  Up: Top

The Minibuffer
**************

   The "minibuffer" is the facility used by XEmacs commands to read
arguments more complicated than a single number.  Minibuffer arguments
can be file names, buffer names, Lisp function names, XEmacs command
names, Lisp expressions, and many other things, depending on the command
reading the argument.  You can use the usual XEmacs editing commands in
the minibuffer to edit the argument text.

   When the minibuffer is in use, it appears in the echo area, and the
cursor moves there.  The beginning of the minibuffer line displays a
"prompt" which says what kind of input you should supply and how it
will be used.  Often this prompt is derived from the name of the command
that the argument is for.  The prompt normally ends with a colon.

   Sometimes a "default argument" appears in parentheses after the
colon; it, too, is part of the prompt.  The default is used as the
argument value if you enter an empty argument (e.g., by just typing
<RET>).  For example, commands that read buffer names always show a
default, which is the name of the buffer that will be used if you type
just <RET>.

   The simplest way to enter a minibuffer argument is to type the text
you want, terminated by <RET> which exits the minibuffer.  You can
cancel the command that wants the argument, and get out of the
minibuffer, by typing `C-g'.

   Since the minibuffer uses the screen space of the echo area, it can
conflict with other ways XEmacs customarily uses the echo area.  Here is
how XEmacs handles such conflicts:

   * If a command gets an error while you are in the minibuffer, this
     does not cancel the minibuffer.  However, the echo area is needed
     for the error message and therefore the minibuffer itself is
     hidden for a while.  It comes back after a few seconds, or as soon
     as you type anything.

   * If in the minibuffer you use a command whose purpose is to print a
     message in the echo area, such as `C-x =', the message is printed
     normally, and the minibuffer is hidden for a while.  It comes back
     after a few seconds, or as soon as you type anything.

   * Echoing of keystrokes does not take place while the minibuffer is
     in use.

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::		  Re-executing commands that used the minibuffer.


File: xemacs.info,  Node: Minibuffer File,  Next: Minibuffer Edit,  Prev: Minibuffer,  Up: Minibuffer

Minibuffers for File Names
==========================

   Sometimes the minibuffer starts out with text in it.  For example,
when you are supposed to give a file name, the minibuffer starts out
containing the "default directory", which ends with a slash.  This is
to inform you which directory the file will be found in if you do not
specify a directory.

   For example, the minibuffer might start out with these contents:

     Find File: /u2/emacs/src/

where `Find File: ' is the prompt.  Typing `buffer.c' specifies the
file `/u2/emacs/src/buffer.c'.  To find files in nearby directories,
use `..'; thus, if you type `../lisp/simple.el', you will get the file
named `/u2/emacs/lisp/simple.el'.  Alternatively, you can kill with
`M-<DEL>' the directory names you don't want (*note Words::).

   If you don't want any of the default, you can kill it with `C-a
C-k'.  But you don't need to kill the default; you can simply ignore it.
Insert an absolute file name, one starting with a slash or a tilde,
after the default directory.  For example, to specify the file
`/etc/termcap', just insert that name, giving these minibuffer contents:

     Find File: /u2/emacs/src//etc/termcap

XEmacs gives a special meaning to a double slash (which is not normally
a useful thing to write): it means, "ignore everything before the
second slash in the pair."  Thus, `/u2/emacs/src/' is ignored in the
example above, and you get the file `/etc/termcap'.

   If you set `insert-default-directory' to `nil', the default
directory is not inserted in the minibuffer.  This way, the minibuffer
starts out empty.  But the name you type, if relative, is still
interpreted with respect to the same default directory.


File: xemacs.info,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

Editing in the Minibuffer
=========================

   The minibuffer is an XEmacs buffer (albeit a peculiar one), and the
usual XEmacs commands are available for editing the text of an argument
you are entering.

   Since <RET> in the minibuffer is defined to exit the minibuffer, you
can't use it to insert a newline in the minibuffer.  To do that, type
`C-o' or `C-q C-j'.  (Recall that a newline is really the character
control-J.)

   The minibuffer has its own window which always has space on the
screen but acts as if it were not there when the minibuffer is not in
use.  When the minibuffer is in use, its window is just like the
others; you can switch to another window with `C-x o', edit text in
other windows and perhaps even visit more files, before returning to the
minibuffer to submit the argument.  You can kill text in another window,
return to the minibuffer window, and then yank the text to use it in the
argument.  *Note Windows::.

   There are some restrictions on the use of the minibuffer window,
however.  You cannot switch buffers in it--the minibuffer and its
window are permanently attached.  Also, you cannot split or kill the
minibuffer window. But you can make it taller in the normal fashion with
`C-x ^'.  If you enable Resize-Minibuffer mode, then the minibuffer
window expands vertically as necessary to hold the text that you put in
the minibuffer.  Use `M-x resize-minibuffer-mode' to enable or disable
this minor mode (*note Minor Modes::).

   If while in the minibuffer you issue a command that displays help
text of any sort in another window, you can use the `C-M-v' command
while in the minibuffer to scroll the help text.  This lasts until you
exit the minibuffer.  This feature is especially useful if a completing
minibuffer gives you a list of possible completions.  *Note Other
Window::.

   If the variable `minibuffer-confirm-incomplete' is `t', you are
asked for confirmation if there is no known completion for the text you
typed. For example, if you attempted to visit a non-existent file, the
minibuffer might read:
             Find File: chocolate_bar.c [no completions, confirm]
   If you press `Return' again, that confirms the filename. Otherwise,
you can continue editing it.

   XEmacs supports recursive use of the minibuffer.  However, it is easy
to do this by accident (because of autorepeating keyboards, for example)
and get confused.  Therefore, most XEmacs commands that use the
minibuffer refuse to operate if the minibuffer window is selected.  If
the minibuffer is active but you have switched to a different window,
recursive use of the minibuffer is allowed--if you know enough to try
to do this, you probably will not get confused.

   If you set the variable `enable-recursive-minibuffers' to a
non-`nil', recursive use of the minibuffer is always allowed.


File: xemacs.info,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

Completion
==========

   For certain kinds of arguments, you can use "completion" to enter
the argument value.  Completion means that you type part of the
argument, then XEmacs visibly fills in the rest, or as much as can be
determined from the part you have typed.

   When completion is available, certain keys--<TAB>, <RET>, and
<SPC>--are rebound to complete the text present in the minibuffer into
a longer string that it stands for, by matching it against a set of
"completion alternatives" provided by the command reading the argument.
`?' is defined to display a list of possible completions of what you
have inserted.

   For example, when `M-x' uses the minibuffer to read the name of a
command, it provides a list of all available XEmacs command names to
complete against.  The completion keys match the text in the minibuffer
against all the command names, find any additional name characters
implied by the ones already present in the minibuffer, and add those
characters to the ones you have given.  This is what makes it possible
to type `M-x inse <SPC> b <RET>' instead of `M-x insert-buffer <RET>'
(for example).

   Case is normally significant in completion because it is significant
in most of the names that you can complete (buffer names, file names and
command names).  Thus, `fo' does not complete to `Foo'.  When you are
completing a name in which case does not matter, case may be ignored
for completion's sake if specified by program.

   When a completion list is displayed, the completions will highlight
as you move the mouse over them.  Clicking the middle mouse button on
any highlighted completion will "select" it just as if you had typed it
in and hit <RET>.

* Menu:

* Example: Completion Example.
* Commands: Completion Commands.
* Strict Completion::
* Options: Completion Options.


File: xemacs.info,  Node: Completion Example,  Next: Completion Commands,  Prev: Completion,  Up: Completion

Completion Example
------------------

   A concrete example may help here.  If you type `M-x au <TAB>', the
<TAB> looks for alternatives (in this case, command names) that start
with `au'.  There are several, including `auto-fill-mode' and
`auto-save-mode'--but they are all the same as far as `auto', so the
`au' in the minibuffer changes to `auto'.

   If you type <TAB> again immediately, there are multiple
possibilities for the very next character--it could be any of `c-'--so
no more characters are added; instead, <TAB> displays a list of all
possible completions in another window.

   If you go on to type `-f <TAB>', this <TAB> sees `auto-f'.  The only
command name starting this way is `auto-fill-mode', so completion fills
in the rest of that.  You now have `auto-fill-mode' in the minibuffer
after typing just `au <TAB> f <TAB>'.  Note that <TAB> has this effect
because in the minibuffer it is bound to the command
`minibuffer-complete' when completion is available.


File: xemacs.info,  Node: Completion Commands,  Next: Strict Completion,  Prev: Completion Example,  Up: Completion

Completion Commands
-------------------

   Here is a list of the completion commands defined in the minibuffer
when completion is available.

`<TAB>'
     Complete the text in the minibuffer as much as possible
     (`minibuffer-complete').

`<SPC>'
     Complete the minibuffer text, but don't go beyond one word
     (`minibuffer-complete-word').

`<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described below
     (`minibuffer-complete-and-exit').

`?'
     Print a list of all possible completions of the text in the
     minibuffer (`minibuffer-list-completions').

`<button2>'
     Select the highlighted text under the mouse as a minibuffer
     response.  When the minibuffer is being used to prompt the user
     for a completion, any valid completions which are visible on the
     screen will be highlighted when the mouse moves over them.
     Clicking <button2> will select the highlighted completion and exit
     the minibuffer.  (`minibuf-select-highlighted-completion').

   <SPC> completes much like <TAB>, but never goes beyond the next
hyphen or space.  If you have `auto-f' in the minibuffer and type
<SPC>, it finds that the completion is `auto-fill-mode', but it stops
completing after `fill-'.  This gives `auto-fill-'.  Another <SPC> at
this point completes all the way to `auto-fill-mode'.  <SPC> in the
minibuffer when completion is available runs the command
`minibuffer-complete-word'.

   Here are some commands you can use to choose a completion from a
window that displays a list of completions:

`button2up'
     Clicking mouse button 2 on a completion in the list of possible
     completions chooses that completion (`mouse-choose-completion').
     You normally use this command while point is in the minibuffer;
     but you must click in the list of completions, not in the
     minibuffer itself.

`<PRIOR>'
`M-v'
     Typing <PRIOR> or `M-v', while in the minibuffer, selects the
     window showing the completion list buffer
     (`switch-to-completions').  This paves the way for using the
     commands below.  (Selecting that window in the usual ways has the
     same effect, but this way is more convenient.)

`<RET>'
     Typing <RET> _in the completion list buffer_ chooses the
     completion that point is in or next to (`choose-completion').  To
     use this command, you must first switch windows to the window that
     shows the list of completions.

`<RIGHT>'
`<TAB>'
`C-f'
     Typing the right-arrow key <RIGHT>, <TAB> or `C-f' _in the
     completion list buffer_ moves point to the following completion
     (`next-list-mode-item').

`<LEFT>'
`C-b'
     Typing the left-arrow key <LEFT> or `C-b' _in the completion list
     buffer_ moves point toward the beginning of the buffer, to the
     previous completion (`previous-list-mode-item').


File: xemacs.info,  Node: Strict Completion,  Next: Completion Options,  Prev: Completion Commands,  Up: Completion

Strict Completion
-----------------

   There are three different ways that <RET> can work in completing
minibuffers, depending on how the argument will be used.

   * "Strict" completion is used when it is meaningless to give any
     argument except one of the known alternatives.  For example, when
     `C-x k' reads the name of a buffer to kill, it is meaningless to
     give anything but the name of an existing buffer.  In strict
     completion, <RET> refuses to exit if the text in the minibuffer
     does not complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     <RET> exits only if the text was an exact match already, not
     needing completion.  If the text is not an exact match, <RET> does
     not exit, but it does complete the text.  If it completes to an
     exact match, a second <RET> will exit.

     Cautious completion is used for reading file names for files that
     must already exist.

   * "Permissive" completion is used when any string whatever is
     meaningful, and the list of completion alternatives is just a
     guide.  For example, when `C-x C-f' reads the name of a file to
     visit, any file name is allowed, in case you want to create a
     file.  In permissive completion, <RET> takes the text in the
     minibuffer exactly as given, without completing it.

   The completion commands display a list of all possible completions in
a window whenever there is more than one possibility for the very next
character.  Also, typing `?' explicitly requests such a list.  If the
list of completions is long, you can scroll it with `C-M-v' (*note
Other Window::).


File: xemacs.info,  Node: Completion Options,  Prev: Strict Completion,  Up: Completion

Completion Options
------------------

   When completion is done on file names, certain file names are usually
ignored.  The variable `completion-ignored-extensions' contains a list
of strings; a file whose name ends in any of those strings is ignored
as a possible completion.  The standard value of this variable has
several elements including `".o"', `".elc"', `".dvi"' and `"~"'.  The
effect is that, for example, `foo' can complete to `foo.c' even though
`foo.o' exists as well.  However, if _all_ the possible completions end
in "ignored" strings, then they are not ignored.  Ignored extensions do
not apply to lists of completions--those always mention all possible
completions.

   If a completion command finds the next character is undetermined, it
automatically displays a list of all possible completions.  If the
variable `completion-auto-help' is set to `nil', this does not happen,
and you must type `?' to display the possible completions.

   If the variable `minibuffer-confirm-incomplete' is set to `t', then
in contexts where `completing-read' allows answers that are not valid
completions, an extra <RET> must be typed to confirm the response.
This is helpful for catching typos.

   Icomplete mode presents a constantly-updated display that tells you
what completions are available for the text you've entered so far.  The
command to enable or disable this minor mode is `M-x icomplete-mode'.


File: xemacs.info,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

Minibuffer History
==================

   Every argument that you enter with the minibuffer is saved on a
"minibuffer history list" so that you can use it again later in another
argument.  Special commands load the text of an earlier argument in the
minibuffer.  They discard the old minibuffer contents, so you can think
of them as moving through the history of previous arguments.

`<UP>'
`M-p'
     Move to the next earlier argument string saved in the minibuffer
     history (`previous-history-element').

`<DOWN>'
`M-n'
     Move to the next later argument string saved in the minibuffer
     history (`next-history-element').

`M-r REGEXP <RET>'
     Move to an earlier saved argument in the minibuffer history that
     has a match for REGEXP (`previous-matching-history-element').

`M-s REGEXP <RET>'
     Move to a later saved argument in the minibuffer history that has a
     match for REGEXP (`next-matching-history-element').

   The simplest way to reuse the saved arguments in the history list is
to move through the history list one element at a time.  While in the
minibuffer, use `M-p' or up-arrow (`previous-history-element') to "move
to" the next earlier minibuffer input, and use `M-n' or down-arrow
(`next-history-element') to "move to" the next later input.

   The previous input that you fetch from the history entirely replaces
the contents of the minibuffer.  To use it as the argument, exit the
minibuffer as usual with <RET>.  You can also edit the text before you
reuse it; this does not change the history element that you "moved" to,
but your new argument does go at the end of the history list in its own
right.

   For many minibuffer arguments there is a "default" value.  In some
cases, the minibuffer history commands know the default value.  Then you
can insert the default value into the minibuffer as text by using `M-n'
to move "into the future" in the history.

   There are also commands to search forward or backward through the
history; they search for history elements that match a regular
expression that you specify with the minibuffer.  `M-r'
(`previous-matching-history-element') searches older elements in the
history, while `M-s' (`next-matching-history-element') searches newer
elements.  By special dispensation, these commands can use the
minibuffer to read their arguments even though you are already in the
minibuffer when you issue them.  As with incremental searching, an
uppercase letter in the regular expression makes the search
case-sensitive (*note Search Case::).

   All uses of the minibuffer record your input on a history list, but
there are separate history lists for different kinds of arguments.  For
example, there is a list for file names, used by all the commands that
read file names.

   There are several other very specific history lists, including one
for command names read by `M-x', one for buffer names, one for arguments
of commands like `query-replace', and one for compilation commands read
by `compile'.  Finally, there is one "miscellaneous" history list that
most minibuffer arguments use.


File: xemacs.info,  Node: Repetition,  Prev: Minibuffer History,  Up: Minibuffer

Repeating Minibuffer Commands
=============================

   Every command that uses the minibuffer at least once is recorded on a
special history list, together with the values of its arguments, so that
you can repeat the entire command.  In particular, every use of `M-x'
is recorded there, since `M-x' uses the minibuffer to read the command
name.

`C-x <ESC> <ESC>'
     Re-execute a recent minibuffer command (`repeat-complex-command').

`M-p'
     Within `C-x <ESC> <ESC>', move to previous recorded command
     (`previous-history-element').

`M-n'
     Within `C-x <ESC> <ESC>', move to the next (more recent) recorded
     command (`next-history-element').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     <ESC> <ESC>' can repeat, most recent first.

   `C-x <ESC> <ESC>' is used to re-execute a recent minibuffer-using
command.  With no argument, it repeats the last such command.  A
numeric argument specifies which command to repeat; one means the last
one, and larger numbers specify earlier ones.

   `C-x <ESC> <ESC>' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  If you type just <RET>, the command is repeated as
before.  You can also change the command by editing the Lisp
expression.  Whatever expression you finally submit is what will be
executed.  The repeated command is added to the front of the command
history unless it is identical to the most recently executed command
already there.

   Even if you don't understand Lisp syntax, it will probably be obvious
which command is displayed for repetition.  If you do not change the
text, you can be sure the command will repeat exactly as before.

   If you are in the minibuffer for `C-x <ESC> <ESC>' and the command
shown to you is not the one you want to repeat, you can move around the
list of previous commands using `M-n' and `M-p'.  `M-p' replaces the
contents of the minibuffer with the next earlier recorded command, and
`M-n' replaces it with the next later command.  After finding the
desired previous command, you can edit its expression and then resubmit
it by typing <RET>.  Any editing you have done on the command to be
repeated is lost if you use `M-n' or `M-p'.

   `M-n' and `M-p' are specially defined within `C-x <ESC> <ESC>' to
run the commands `previous-history-element' and `next-history-element'.

   The list of previous commands using the minibuffer is stored as a
Lisp list in the variable `command-history'.  Each element of the list
is a Lisp expression which describes one command and its arguments.
Lisp programs can reexecute a command by feeding the corresponding
`command-history' element to `eval'.


File: xemacs.info,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

Running Commands by Name
************************

   The Emacs commands that are used often or that must be quick to type
are bound to keys--short sequences of characters--for convenient use.
Other Emacs commands that are used more rarely are not bound to keys;
to run them, you must refer to them by name.

   A command name consists, by convention, of one or more words,
separated by hyphens: for example, `auto-fill-mode' or `manual-entry'.
The use of English words makes the command name easier to remember than
a key made up of obscure characters, even though it results in more
characters to type.  You can run any command by name, even if it can be
run by keys as well.

   To run a command by name, start with `M-x', then type the command
name, and finish with <RET>.  `M-x' uses the minibuffer to read the
command name.  <RET> exits the minibuffer and runs the command.

   Emacs uses the minibuffer for reading input for many different
purposes; on this occasion, the string `M-x' is displayed at the
beginning of the minibuffer as a "prompt" to remind you that your input
should be the name of a command to be run.  *Note Minibuffer::, for
full information on the features of the minibuffer.

   You can use completion to enter a command name.  For example, to
invoke the command `forward-char', type:

     M-x forward-char <RET>
   or
     M-x fo <TAB> c <RET>

After you type in `M-x fo TAB' emacs will give you a possible list of
completions from which you can choose. Note that `forward-char' is the
same command that you invoke with the key `C-f'.  You can call any
command (interactively callable function) defined in Emacs by its name
using `M-x' regardless of whether or not any keys are bound to it.

   If you type `C-g' while Emacs reads the command name, you cancel the
`M-x' command and get out of the minibuffer, ending up at top level.

   To pass a numeric argument to a command you are invoking with `M-x',
specify the numeric argument before the `M-x'.  `M-x' passes the
argument along to the function that it calls.  The argument value
appears in the prompt while the command name is being read.

   You can use the command `M-x interactive' to specify a way of
parsing arguments for interactive use of a function.  For example,
write:

       (defun foo (arg) "Doc string" (interactive "p") ...use arg...)

   to make `arg' be the prefix argument when `foo' is called as a
command.  The call to `interactive' is actually a declaration rather
than a function; it tells `call-interactively' how to read arguments to
pass to the function.  When actually called, `interactive' returns
`nil'.

   The argument of INTERACTIVE is usually a string containing a code
letter followed by a prompt.  Some code letters do not use I/O to get
the argument and do not need prompts.  To prompt for multiple arguments,
you must provide a code letter, its prompt, a newline, and another code
letter, and so forth.  If the argument is not a string, it is evaluated
to get a list of arguments to pass to the function.  If you do not
provide an argument to `interactive', no arguments are passed when
calling interactively.

   Available code letters are:

`a'
     Function name: symbol with a function definition

`b'
     Name of existing buffer

`B'
     Name of buffer, possibly nonexistent

`c'
     Character

`C'
     Command name: symbol with interactive function definition

`d'
     Value of point as number (does not do I/O)

`D'
     Directory name

`e'
     Last mouse event

`f'
     Existing file name

`F'
     Possibly nonexistent file name

`k'
     Key sequence (string)

`m'
     Value of mark as number (does not do I/O)

`n'
     Number read using minibuffer

`N'
     Prefix arg converted to number, or if none, do like code `n'

`p'
     Prefix arg converted to number (does not do I/O)

`P'
     Prefix arg in raw form (does not do I/O)

`r'
     Region: point and mark as two numeric arguments, smallest first
     (does not do I/O)

`s'
     Any string

`S'
     Any symbol

`v'
     Variable name: symbol that is `user-variable-p'

`x'
     Lisp expression read but not evaluated

`X'
     Lisp expression read and evaluated

   In addition, if the string begins with `*', an error is signaled if
the buffer is read-only.  This happens before reading any arguments.
If the string begins with `@', the window the mouse is over is selected
before anything else is done.  You may use both `@' and `*'; they are
processed in the order that they appear.

   Normally, when describing a command that is run by name, we omit the
<RET> that is needed to terminate the name.  Thus we may refer to `M-x
auto-fill-mode' rather than `M-x auto-fill-mode' <RET>.  We mention the
<RET> only when it is necessary to emphasize its presence, for example,
when describing a sequence of input that contains a command name and
arguments that follow it.

   `M-x' is defined to run the command `execute-extended-command',
which is responsible for reading the name of another command and
invoking it.


File: xemacs.info,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

Help
****

   XEmacs provides extensive help features accessible through a single
character, `C-h'.  `C-h' is a prefix key that is used only for
documentation-printing commands.  The characters that you can type after
`C-h' are called "help options".  One help option is `C-h'; that is how
you ask for help about using `C-h'.  To cancel, type `C-g'.  The
function key <F1> is equivalent to `C-h'.

   `C-h C-h' (`help-for-help') displays a list of the possible help
options, and then asks you to type the desired option.  It prompts with
the string:

     A B C F I K L M N P S T V W C-c C-d C-f C-i C-k C-n C-w;  ? for more help:

You should type one of those characters.

   Typing a third `C-h' displays a description of what the options mean;
Emacs still waits for you to type an option.  To cancel, type `C-g'.

   Most help buffers use a special major mode, Help mode, which lets you
scroll conveniently with <SPC> and <DEL> or <BS>.

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in XEmacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Help Mode::           Special features of Help mode and Help buffers.
* Misc Help::		Other help commands.


File: xemacs.info,  Node: Help Summary,  Next: Key Help,  Prev: Help,  Up: Help

Help Summary
============

   Here is a summary of the defined help commands.

`C-h a REGEXP <RET>'
     Display a list of functions and variables whose names match REGEXP
     (`hyper-apropos').

`C-h A REGEXP'
     Show all commands whose names contain matches for REGEXP
     (`command-apropos').

`C-h b'
     Display a table of all key bindings currently in effect, with local
     bindings of the current major mode first, followed by all global
     bindings (`describe-bindings').

`C-h c KEY'
     Print the name of the command that KEY runs
     (`describe-key-briefly').  Here `c' stands for `character'.  For
     more extensive information on KEY, use `C-h k'.

`C-h d FUNCTION <RET>'
`C-h f FUNCTION <RET>'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Since commands are Lisp functions, a
     command name may be used.

`C-h i'
     Run Info, the program for browsing documentation files (`info').
     The complete XEmacs manual is available online in Info.

`C-h k KEY'
     Display the name and documentation of the command that KEY runs
     (`describe-key').

`C-h l'
     Display a description of the last 100 characters you typed
     (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h n'
`C-h C-n'
     Display documentation of XEmacs changes, most recent first
     (`view-emacs-news').

`C-h p'
     Find packages by topic keyword (`finder-by-keyword').

`C-h C-p'
     Display a table of all mouse bindings currently in effect now, with
     local bindings of the current major mode first, followed by all
     global bindings (`describe-pointer').

`C-h s'
     Display current contents of the syntax table, plus an explanation
     of what they mean (`describe-syntax').  *Note Syntax::.

`C-h t'
     Enter the XEmacs interactive tutorial (`help-with-tutorial').

`C-h v VAR <RET>'
     Display the documentation of the Lisp variable VAR
     (`describe-variable').

`C-h w COMMAND <RET>'
     Print which keys run the command named COMMAND (`where-is').

`C-h B <RET>'
     Display info on how to deal with Beta versions of XEmacs
     (`describe-beta').

`C-h C GROUP <RET>'
     Select customization buffer for GROUP (`customize').

`C-h F <RET>'
     View the local copy of the XEmacs FAQ (`xemacs-local-faq').

`C-h C-i FILE <RET>'
     Read Info file FILE with Info browser (`Info-query').

`C-h C-c COMMAND <RET>'
     Look up an Emacs command COMMAND in the Emacs manual in the Info
     system (`Info-goto-emacs-command-node').

`C-h C-f FUNCTION <RET>'
     Look up an Emacs Lisp function FUNCTION in the Elisp manual in the
     Info system (`Info-elisp-ref').


File: xemacs.info,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

Documentation for a Key
=======================

   The most basic `C-h' options are `C-h c' (`describe-key-briefly')
and `C-h k' (`describe-key').  `C-h c KEY' prints in the echo area the
name of the command that KEY is bound to.  For example, `C-h c C-f'
prints `forward-char'.  Since command names are chosen to describe what
the commands do, this is a good way to get a very brief description of
what KEY does.

   `C-h k KEY' is similar to `C-h c' but gives more information.  It
displays the documentation string of the function KEY is bound to as
well as its name.  KEY is a string or vector of events.  When called
interactively, KEY may also be a menu selection.  This information does
not usually fit into the echo area, so a window is used for the display.

   `C-h c' and `C-h k' work for any sort of key sequences, including
function keys and mouse events.


File: xemacs.info,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

Help by Command or Variable Name
================================

   `C-h f' (`describe-function') reads the name of a Lisp function
using the minibuffer, then displays that function's documentation
string in a window.  Since commands are Lisp functions, you can use the
argument FUNCTION to get the documentation of a command that you know
by name.  For example,

     C-h f auto-fill-mode <RET>

displays the documentation for `auto-fill-mode'. Using `C-h f' is the
only way to see the documentation of a command that is not bound to any
key, that is, a command you would normally call using `M-x'.  If the
variable `describe-function-show-arglist' is `t', `describe-function'
shows its arglist if the FUNCTION is not an autoload function.

   `C-h f' is also useful for Lisp functions that you are planning to
use in a Lisp program.  For example, if you have just written the
expression `(make-vector len)' and want to make sure you are using
`make-vector' properly, type `C-h f make-vector <RET>'.  Because `C-h
f' allows all function names, not just command names, you may find that
some of your favorite abbreviations that work in `M-x' don't work in
`C-h f'.  An abbreviation may be unique among command names, yet fail
to be unique when other function names are allowed.

   The function name for `C-h f' to describe has a default which is
used if you type <RET> leaving the minibuffer empty.  The default is
the function called by the innermost Lisp expression in the buffer
around point, _provided_ that is a valid, defined Lisp function name.
For example, if point is located following the text `(make-vector (car
x)', the innermost list containing point is the one that starts with
`(make-vector', so the default is to describe the function
`make-vector'.

   `C-h f' is often useful just to verify that you have the right
spelling for the function name.  If `C-h f' mentions a name from the
buffer as the default, that name must be defined as a Lisp function.  If
that is all you want to know, just type `C-g' to cancel the `C-h f'
command, then go on editing.

   `C-h w COMMAND <RET>' (`where-is') tells you what keys are bound to
COMMAND.  It prints a list of the keys in the echo area. Alternatively,
it informs you that a command is not bound to any keys, which implies
that you must use `M-x' to call the command.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a known Lisp variable.
*Note Variables::.


File: xemacs.info,  Node: Apropos,  Next: Library Keywords,  Prev: Name Help,  Up: Help

Apropos
=======

`C-h A'
     Show only symbols that are names of commands (`command-apropos').

`M-x apropos REGEXP'
     Show all symbols whose names contain matches for REGEXP.

   A more sophisticated sort of question to ask is, "What are the
commands for working with files?"  To ask this question, type `C-h a
file <RET>', which displays a list of all command names that contain
`file', including `copy-file', `find-file', and so on.  With each
command name appears a brief description of how to use the command, and
what keys you can currently invoke it with.  For example, it would say
that you can invoke `find-file' by typing `C-x C-f'.  The `A' in `C-h
A' stands for `Apropos'; `C-h A' runs the command `command-apropos'.
This command normally checks only commands (interactive functions); if
you specify a prefix argument, it checks noninteractive functions as
well.

   Because `C-h A' looks only for functions whose names contain the
string you specify, you must use ingenuity in choosing the string.  If
you are looking for commands for killing backwards and `C-h a
kill-backwards <RET>' doesn't reveal any, don't give up.  Try just
`kill', or just `backwards', or just `back'.  Be persistent.  Pretend
you are playing Adventure.  Also note that you can use a regular
expression as the argument, for more flexibility (*note Regexps::).

   Here is a set of arguments to give to `C-h a' that covers many
classes of XEmacs commands, since there are strong conventions for
naming the standard XEmacs commands.  By giving you a feel for the
naming conventions, this set should also serve to aid you in developing
a technique for picking `apropos' strings.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe, default.

   To list all Lisp symbols that contain a match for a regexp, not just
the ones that are defined as commands, use the command `M-x apropos'
instead of `C-h A'.  This command does not check key bindings by
default; specify a numeric argument if you want it to check them.

   The `apropos-documentation' command is like `apropos' except that it
searches documentation strings for matches for the specified regular
expression.

   The `apropos-value' command is like `apropos' except that it
searches symbols' values for matches for the specified regular
expression.  This command does not check function definitions or
property lists by default; specify a numeric argument if you want it to
check them.

   If the variable `apropos-do-all' is non-`nil', the commands above
all behave as if they had been given a prefix argument.

   If you want more information about a function definition, variable or
symbol property listed in the Apropos buffer, you can click on it with
`Mouse-2' or move there and type <RET>.

