This is ../info/xemacs.info, produced by makeinfo version 4.6 from
xemacs/xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Top,  Next: License,  Up: (dir)

The XEmacs Editor
*****************

XEmacs is the extensible, customizable, self-documenting real-time
display editor.  This Info file describes how to edit with Emacs and
some of how to customize it, but not how to extend it.  It corresponds
to XEmacs version 21.0.

   This manual is intended as a detailed reference to XEmacs.  If you
are looking for an introductory manual, see the New User's Guide.

* Menu:

* License::     The GNU General Public License gives you permission
		to redistribute XEmacs on certain terms; and also
		explains that there is no warranty.
* Distrib::     How to get XEmacs.
* Intro::       An introduction to XEmacs concepts.
* Glossary::    The glossary.
* Manifesto::   What's GNU?  Gnu's Not Unix!

Indices, nodes containing large menus
* Key Index::      An item for each standard XEmacs key sequence.
* Command Index::  An item for each command name.
* Variable Index:: An item for each documented variable.
* Concept Index::  An item for each concept.

Important General Concepts
* Frame::      How to interpret what you see on the screen.
* Keystrokes::  Keyboard gestures XEmacs recognizes.
* Pull-down Menus::
                The XEmacs Pull-down Menus available under X.
* Entering Emacs::
                Starting Emacs from the shell.
* Exiting::     Stopping or killing XEmacs.
* Command Switches::
                Hairy startup options.
* Startup Paths::
                How XEmacs finds Directories and Files.
* Packages::    How XEmacs organizes its high-level functionality.

Fundamental Editing Commands
* Basic::       The most basic editing commands.
* Undo::        Undoing recently made changes in the text.
* Minibuffer::  Entering arguments that are prompted for.
* M-x::         Invoking commands by their names.
* Help::        Commands for asking XEmacs about its commands.

Important Text-Changing Commands
* Mark::        The mark: how to delimit a ``region'' of text.
* Mouse Selection::
                Selecting text with the mouse.
* Additional Mouse Operations::
                Other operations available from the mouse.
* Killing::     Killing text.
* Yanking::     Recovering killed text.  Moving text.
* Using X Selections::
                Using primary selection, cut buffers, and highlighted regions.
* Accumulating Text::
                Other ways of copying text.
* Rectangles::  Operating on the text inside a rectangle on the screen.
* Registers::   Saving a text string or a location in the buffer.
* Display::     Controlling what text is displayed.
* Search::      Finding or replacing occurrences of a string.
* Fixit::       Commands especially useful for fixing typos.

Larger Units of Text
* Files::       All about handling files.
* Buffers::     Multiple buffers; editing several files at once.
* Windows::     Viewing two pieces of text at once.
* Mule::	Using world scripts.

Advanced Features
* Major Modes:: Text mode vs. Lisp mode vs. C mode ...
* Indentation:: Editing the white space at the beginnings of lines.
* Text::        Commands and modes for editing English.
* Programs::    Commands and modes for editing programs.
* Running::     Compiling, running and debugging programs.
* Abbrevs::     How to define text abbreviations to reduce
                 the number of characters you must type.
* Picture::     Editing pictures made up of characters
                 using the quarter-plane screen model.
* Sending Mail:: Sending mail in XEmacs.
* Reading Mail:: Reading mail in XEmacs.
* Calendar/Diary:: A Calendar and diary facility in XEmacs.
* Sorting::	Sorting lines, paragraphs or pages within XEmacs.
* Shell::       Executing shell commands from XEmacs.
* Narrowing::   Restricting display and editing to a portion
                 of the buffer.
* Hardcopy::	Printing buffers or regions.
* Recursive Edit::
                A command can allow you to do editing
                 "within the command".  This is called a
                 `recursive editing level'.
* Dissociated Press::  Dissociating text for fun.
* CONX::	       A different kind of dissociation.
* Amusements::         Various games and hacks.
* Emulation::	       Emulating some other editors with XEmacs.
* Customization::      Modifying the behavior of XEmacs.

Recovery from Problems.
* Quitting::    Quitting and aborting.
* Lossage::     What to do if XEmacs is hung or malfunctioning.
* Bugs::        How and when to report a bug.

Here are some other nodes which are really inferiors of the ones
already listed, mentioned here so you can get to them in one step:

 --- The Detailed Node Listing ---

The Organization of the Frame

* Point::	        The place in the text where editing commands operate.
* Echo Area::           Short messages appear at the bottom of the frame.
* Mode Line::	        Interpreting the mode line.
* XEmacs under X::      Some information on using XEmacs under the X
                        Window System.

Keystrokes

* Intro to Keystrokes::      Keystrokes as building blocks of key sequences.
* Representing Keystrokes::  Using lists of modifiers and keysyms to
                             represent keystrokes.
* Key Sequences::            Combine key strokes into key sequences you can
                             bind to commands.
* String Key Sequences::     Available for upward compatibility.
* Meta Key::                 Using <ESC> to represent <Meta>
* Super and Hyper Keys::     Adding modifier keys on certain keyboards.
* Character Representation:: How characters appear in XEmacs buffers.
* Commands::                 How commands are bound to key sequences.

Pull-down Menus

* File Menu::           Items on the File menu.
* Edit Menu::           Items on the Edit menu.
* Apps Menu::		Items on the Apps menu.
* Options Menu::        Items on the Options menu.
* Buffers Menu::        Information about the Buffers menu.
* Tools Menu::		Items on the Tools menu.
* Help Menu::           Items on the Help menu.
* Menu Customization::  Adding and removing menu items and related
                        operations.

Packages

* Packages::            Introduction to XEmacs Packages.
* Package Terminology:: Understanding different kinds of packages.
* Installing Packages:: How to install packages.
* Building Packages::   Building packages from sources.
* Local.rules File::    An important part of building packages.
* Available Packages::  A brief directory of packaged LISP.

Basic Editing Commands

* Blank Lines::        Commands to make or delete blank lines.
* Continuation Lines:: Lines too wide for the frame.
* Position Info::      What page, line, row, or column is point on?
* Arguments::	       Numeric arguments for repeating a command.

The Minibuffer

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Repetition::		  Re-executing commands that used the minibuffer.

The Mark and the Region

* Setting Mark::	Commands to set the mark.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.

Yanking

* Kill Ring::       Where killed text is stored.  Basic yanking.
* Appending Kills:: Several kills in a row all yank together.
* Earlier Kills::   Yanking something killed some time ago.

Using X Selections

* X Clipboard Selection::     	Pasting to the X clipboard.
* X Selection Commands::	Other operations on the selection.
* X Cut Buffers::       	X cut buffers are available for compatibility.
* Active Regions::      	Using zmacs-style highlighting of the
                        	 selected region.

Registers

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.

Controlling the Display

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* Display Vars::           Information on variables for customizing display.

Searching and Replacement

* Incremental Search::     Search happens as you type the string.
* Non-Incremental Search:: Specify entire string and then search.
* Word Search::            Search for sequence of words.
* Regexp Search::          Search for match for a regexp.
* Regexps::                Syntax of regular expressions.
* Search Case::            To ignore case while searching, or not.
* Replace::                Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.

Replacement Commands

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.

Commands for Fixing Typos

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.

File Handling

* File Names::       How to type and edit file name arguments.
* Visiting::         Visiting a file prepares XEmacs to edit the file.
* Saving::           Saving makes your changes permanent.
* Reverting::        Reverting cancels all the changes not saved.
* Auto Save::        Auto Save periodically protects against loss of data.
* Version Control::  Version control systems (RCS and SCCS).
* ListDir::          Listing the contents of a file directory.
* Comparing Files::  Finding where two files differ.
* Dired::            ``Editing'' a directory to delete, rename, etc.
                     the files in it.
* Misc File Ops::    Other things you can do on files.

Saving Files

* Backup::       How XEmacs saves the old version of your file.
* Interlocking:: How XEmacs protects against simultaneous editing
                  of one file by two users.

Backup Files

* Names: Backup Names.		How backup files are named;
				Choosing single or numbered backup files.
* Deletion: Backup Deletion.	XEmacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.

Auto-Saving: Protection Against Disasters

* Files: Auto Save Files.
* Control: Auto Save Control.
* Recover::		Recovering text from auto-save files.

Version Control

* Concepts of VC::		Basic version control information;
				  checking files in and out.
* Editing with VC::		Commands for editing a file maintained
				  with version control.
* Variables for Check-in/out::	Variables that affect the commands used
				  to check files in or out.
* Log Entries::			Logging your changes.
* Change Logs and VC::		Generating a change log file from log
				  entries.
* Old Versions::		Examining and comparing old versions.
* VC Status::			Commands to view the VC status of files and
				  look at log entries.
* Renaming and VC::		A command to rename both the source and
				  master file correctly.
* Snapshots::			How to make and use snapshots, a set of
				  file versions that can be treated as a unit.
* Version Headers::		Inserting version control headers into
				  working files.

Snapshots

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.

Dired, the Directory Editor

* Enter: Dired Enter.         How to invoke Dired.
* Edit: Dired Edit.           Editing the Dired buffer.
* Deletion: Dired Deletion.   Deleting files with Dired.
* Immed: Dired Immed.         Other file operations through Dired.

Using Multiple Buffers

* Select Buffer::   Creating a new buffer or reselecting an old one.
* List Buffers::    Getting a list of buffers that exist.
* Misc Buffer::     Renaming; changing read-onliness; copying text.
* Kill Buffer::     Killing buffers you no longer need.
* Several Buffers:: How to go through the list of all buffers
                     and operate variously on several of them.

Multiple Windows

* Basic Window::     Introduction to XEmacs windows.
* Split Window::     New windows are made by splitting existing windows.
* Other Window::     Moving to another window or doing something to it.
* Pop Up Window::    Finding a file or buffer in another window.
* Change Window::    Deleting windows and changing their sizes.

Major Modes

* Choosing Modes::     How major modes are specified or chosen.

Indentation

* Indentation Commands:: Various commands and techniques for indentation.
* Tab Stops::            You can set arbitrary "tab stops" and then
                         indent to the next tab stop when you want to.
* Just Spaces::          You can request indentation using just spaces.

Commands for Human Languages

* Text Mode::   The major modes for editing text files.
* Nroff Mode::  The major mode for editing input to the formatter nroff.
* TeX Mode::    The major modes for editing input to the formatter TeX.
* Outline Mode:: The major mode for editing outlines.
* Words::       Moving over and killing words.
* Sentences::   Moving over and killing sentences.
* Paragraphs::	Moving over paragraphs.
* Pages::	Moving over pages.
* Filling::     Filling or justifying text
* Case::        Changing the case of text

TeX Mode

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* Printing: TeX Print.    Commands for printing part of a file with TeX.

Outline Mode

* Format: Outline Format.	  What the text of an outline looks like.
* Motion: Outline Motion.	  Special commands for moving through outlines.
* Visibility: Outline Visibility. Commands to control what is visible.

Filling Text

* Auto Fill::	  Auto Fill mode breaks long lines automatically.
* Fill Commands:: Commands to refill paragraphs and center lines.
* Fill Prefix::   Filling when every line is indented or in a comment, etc.

Editing Programs

* Program Modes::       Major modes for editing programs.
* Lists::               Expressions with balanced parentheses.
                         There are editing commands to operate on them.
* Defuns::              Each program is made up of separate functions.
                         There are editing commands to operate on them.
* Grinding::            Adjusting indentation to show the nesting.
* Matching::            Insertion of a close-delimiter flashes matching open.
* Comments::            Inserting, filling and aligning comments.
* Balanced Editing::    Inserting two matching parentheses at once, etc.
* Lisp Completion::     Completion on symbol names in Lisp code.
* Documentation::       Getting documentation of functions you plan to call.
* Change Log::          Maintaining a change history for your program.
* Tags::                Go directly to any function in your program in one
                         command.  Tags remembers which file it is in.
* Fortran::		Fortran mode and its special features.
* Asm Mode::            Asm mode and its special features.

Indentation for Programs

* Basic Indent::
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Choosing an indentation style for C code.

Tags Tables

* Tag Syntax::		Tag syntax for various types of code and text files.
* Create Tags Table::	Creating a tags table with `etags'.
* Select Tags Table::	How to visit a tags table.
* Find Tag::		Commands to find the definition of a specific tag.
* Tags Search::		Using a tags table for searching and replacing.
* List Tags::		Listing and finding tags defined in a file.

Fortran Mode

* Motion: Fortran Motion.     Moving point by statements or subprograms.
* Indent: Fortran Indent.     Indentation commands for Fortran.
* Comments: Fortran Comments. Inserting and aligning comments.
* Columns: Fortran Columns.   Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.     Built-in abbrevs for Fortran keywords.

Fortran Indentation

* Commands: ForIndent Commands. Commands for indenting Fortran.
* Numbers:  ForIndent Num.      How line numbers auto-indent.
* Conv:     ForIndent Conv.     Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.     Variables controlling Fortran indent style.

Compiling and Testing Programs

* Compilation::        Compiling programs in languages other than Lisp
                        (C, Pascal, etc.)
* Modes: Lisp Modes.   Various modes for editing Lisp programs, with
                       different facilities for running the Lisp programs.
* Libraries: Lisp Libraries.      Creating Lisp programs to run in XEmacs.
* Eval: Lisp Eval.     Executing a single Lisp expression in XEmacs.
* Debug: Lisp Debug.   Debugging Lisp programs running in XEmacs.
* Interaction: Lisp Interaction.  Executing Lisp in an XEmacs buffer.
* External Lisp::      Communicating through XEmacs with a separate Lisp.

Lisp Libraries

* Loading::		Loading libraries of Lisp code into XEmacs for use.
* Compiling Libraries:: Compiling a library makes it load and run faster.
* Mocklisp::		Converting Mocklisp to Lisp so XEmacs can run it.

Abbrevs

* Defining Abbrevs::  Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs:: Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::   Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::    Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::   Abbreviations for words already in the buffer.

Editing Pictures

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                           after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.

Sending Mail

* Format: Mail Format.    Format of the mail being composed.
* Headers: Mail Headers.  Details of allowed mail header fields.
* Mode: Mail Mode.        Special commands for editing mail being composed.

Running Shell Commands from XEmacs

* Single Shell::         How to run one shell command and return.
* Interactive Shell::    Permanent shell taking input via XEmacs.
* Shell Mode::           Special XEmacs commands used with permanent shell.

Customization

* Minor Modes::     Each minor mode is one feature you can turn on
                     independently of any others.
* Variables::       Many XEmacs commands examine XEmacs variables
                     to decide what to do; by setting variables,
                     you can control their functioning.
* Keyboard Macros:: A keyboard macro records a sequence of keystrokes
                     to be replayed with a single command.
* Key Bindings::    The keymaps say what command each key runs.
                     By changing them, you can "redefine keys".
* Syntax::          The syntax table controls how words and expressions
                     are parsed.
* Init File::       How to write common customizations in the init file.
* Audible Bell::    Changing how XEmacs sounds the bell.
* Faces::           Changing the fonts and colors of a region of text.
* X Resources::	    X resources controlling various aspects of the
                     behavior of XEmacs.

Variables

* Examining::           Examining or setting one variable's value.
* Easy Customization::  Convenient and easy customization of variables.
* Edit Options::        Examining or editing list of all variables' values.
* Locals::              Per-buffer values of variables.
* File Variables::      How files can specify variable values.

Keyboard Macros

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Keyboard macros that do different things each use.

Customizing Key Bindings

* Keymaps::    Definition of the keymap data structure.
               Names of XEmacs's standard keymaps.
* Rebinding::  How to redefine one key's meaning conveniently.
* Disabling::  Disabling a command means confirmation is required
                before it can be executed.  This is done to protect
                beginners from surprises.

The Syntax Table

* Entry: Syntax Entry.    What the syntax table records for each character.
* Change: Syntax Change.  How to change the information.

The Init File

* Init Syntax::     Syntax of constants in Emacs Lisp.
* Init Examples::   How to do some things with an init file.
* Terminal Init::   Each terminal type can have an init file.

Dealing with XEmacs Trouble

* Stuck Recursive::    `[...]' in mode line around the parentheses.
* Screen Garbled::     Garbage on the screen.
* Text Garbled::       Garbage in the text.
* Unasked-for Search:: Spontaneous entry to incremental search.
* Emergency Escape::   Emergency escape---
                        What to do if XEmacs stops responding.
* Total Frustration::  When you are at your wits' end.


File: xemacs.info,  Node: License,  Next: Distrib,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                       Version 1, February 1989

     Copyright (C) 1989 Free Software Foundation, Inc.
     675 Mass Ave, Cambridge, MA 02139, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The license agreements of most software companies try to keep users at
the mercy of those companies.  By contrast, our General Public License
is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it.
You can use it for your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   The precise terms and conditions for copying, distribution and
modification follow.

                         TERMS AND CONDITIONS
  1. This License Agreement applies to any program or other work which
     contains a notice placed by the copyright holder saying it may be
     distributed under the terms of this General Public License.  The
     "Program", below, refers to any such program or work, and a "work
     based on the Program" means either the Program or any work
     containing the Program or a portion of it, either verbatim or with
     modifications.  Each licensee is addressed as "you".

  2. You may copy and distribute verbatim copies of the Program's source
     code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this General Public License
     and to the absence of any warranty; and give any other recipients
     of the Program a copy of this General Public License along with
     the Program.  You may charge a fee for the physical act of
     transferring a copy.

  3. You may modify your copy or copies of the Program or any portion of
     it, and copy and distribute such modifications under the terms of
     Paragraph 1 above, provided that you also do the following:

        * cause the modified files to carry prominent notices stating
          that you changed the files and the date of any change; and

        * cause the whole of any work that you distribute or publish,
          that in whole or in part contains the Program or any part
          thereof, either with or without modifications, to be licensed
          at no charge to all third parties under the terms of this
          General Public License (except that you may choose to grant
          warranty protection to some or all third parties, at your
          option).

        * If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the simplest and most usual way, to print
          or display an announcement including an appropriate copyright
          notice and a notice that there is no warranty (or else,
          saying that you provide a warranty) and that users may
          redistribute the program under these conditions, and telling
          the user how to view a copy of this General Public License.

        * You may charge a fee for the physical act of transferring a
          copy, and you may at your option offer warranty protection in
          exchange for a fee.

     Mere aggregation of another independent work with the Program (or
     its derivative) on a volume of a storage or distribution medium
     does not bring the other work under the scope of these terms.

  4. You may copy and distribute the Program (or a portion or
     derivative of it, under Paragraph 2) in object code or executable
     form under the terms of Paragraphs 1 and 2 above provided that you
     also do one of the following:

        * accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Paragraphs 1 and 2 above; or,

        * accompany it with a written offer, valid for at least three
          years, to give any third party free (except for a nominal
          charge for the cost of distribution) a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Paragraphs 1 and 2 above; or,

        * accompany it with the information you received as to where the
          corresponding source code may be obtained.  (This alternative
          is allowed only for noncommercial distribution and only if you
          received the program in object code or executable form alone.)

     Source code for a work means the preferred form of the work for
     making modifications to it.  For an executable file, complete
     source code means all the source code for all modules it contains;
     but, as a special exception, it need not include source code for
     modules which are standard libraries that accompany the operating
     system on which the executable file runs, or for standard header
     files or definitions files that accompany that operating system.

  5. You may not copy, modify, sublicense, distribute or transfer the
     Program except as expressly provided under this General Public
     License.  Any attempt otherwise to copy, modify, sublicense,
     distribute or transfer the Program is void, and will automatically
     terminate your rights to use the Program under this License.
     However, parties who have received copies, or rights to use
     copies, from you under this General Public License will not have
     their licenses terminated so long as such parties remain in full
     compliance.

  6. By copying, distributing or modifying the Program (or any work
     based on the Program) you indicate your acceptance of this license
     to do so, and all its terms and conditions.

  7. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.

  8. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of the license which applies to
     it and "any later version", you have the option of following the
     terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of the license, you may choose
     any version ever published by the Free Software Foundation.

  9. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY

 10. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 11. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR
     
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 1, or (at your option)
     any later version.
     
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the
     program `Gnomovision' (a program to direct compilers to make passes
     at assemblers) written by James Hacker.
     
     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   That's all there is to it!


File: xemacs.info,  Node: Distrib,  Next: Intro,  Prev: License,  Up: Top

Distribution
************

XEmacs is "free"; this means that everyone is free to use it and free
to redistribute it on a free basis.  XEmacs is not in the public
domain; it is copyrighted and there are restrictions on its
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of XEmacs
that they might get from you.  The precise conditions are found in the
GNU General Public License that comes with XEmacs and also appears
following this section.

   The easiest way to get a copy of XEmacs is from someone else who has
it.  You need not ask for permission to do so, or tell any one else;
just copy it.

   If you have access to the Internet, you can get the latest version of
XEmacs from the anonymous FTP server `ftp.xemacs.org' in the directory
`/pub/xemacs'.  It can also be found at numerous other archive sites
around the world; check the file `etc/DISTRIB' in an XEmacs
distribution for the latest known list.

Getting Other Versions of Emacs
===============================

The Free Software Foundation's version of Emacs (called "FSF Emacs" in
this manual and often referred to as "GNU Emacs") is available by
anonymous FTP from `prep.ai.mit.edu'.

   Win-Emacs, an older version of XEmacs that runs on Microsoft Windows
and Windows NT, is available by anonymous FTP from `ftp.netcom.com' in
the directory `/pub/pe/pearl', or from `ftp.cica.indiana.edu' as the
files `wemdemo*.zip' in the directory `/pub/pc/win3/demo'.


File: xemacs.info,  Node: Intro,  Next: Glossary,  Prev: Distrib,  Up: Top

Introduction
************

You are reading about XEmacs, an incarnation of the advanced,
self-documenting, customizable, extensible real-time display editor
Emacs.  XEmacs provides many powerful display and user-interface
capabilities not found in other Emacsen and is mostly upwardly
compatible with GNU Emacs from the Free Software Foundation (referred
to as "FSF Emacs" in this manual).  XEmacs also comes standard with a
great number of useful packages.

   We say that XEmacs is a "display" editor because normally the text
being edited is visible on the screen and is updated automatically as
you type.  *Note Display: Frame.

   We call XEmacs a "real-time" editor because the display is updated
very frequently, usually after each character or pair of characters you
type.  This minimizes the amount of information you must keep in your
head as you edit.  *Note Real-time: Basic.

   We call XEmacs advanced because it provides facilities that go beyond
simple insertion and deletion: filling of text; automatic indentation of
programs; viewing two or more files at once; and dealing in terms of
characters, words, lines, sentences, paragraphs, and pages, as well as
expressions and comments in several different programming languages.
It is much easier to type one command meaning "go to the end of the
paragraph" than to find that spot with simple cursor keys.

   "Self-documenting" means that at any time you can type a special
character, `Control-h', to find out what your options are.  You can
also use `C-h' to find out what a command does, or to find all the
commands relevant to a topic.  *Note Help::.

   "Customizable" means you can change the definitions of XEmacs
commands.  For example, if you use a programming language in which
comments start with `<**' and end with `**>', you can tell the XEmacs
comment manipulation commands to use those strings (*note Comments::).
Another sort of customization is rearrangement of the command set.  For
example, you can set up the four basic cursor motion commands (up,
down, left and right) on keys in a diamond pattern on the keyboard if
you prefer.  *Note Customization::.

   "Extensible" means you can go beyond simple customization and write
entirely new commands, programs in the Lisp language to be run by
XEmacs's own Lisp interpreter.  XEmacs is an "on-line extensible"
system: it is divided into many functions that call each other.  You can
redefine any function in the middle of an editing session and replace
any part of XEmacs without making a separate copy of all of XEmacs.
Most of the editing commands of XEmacs are written in Lisp; the few
exceptions could have been written in Lisp but are written in C for
efficiency.  Only a programmer can write an extension to XEmacs, but
anybody can use it afterward.


File: xemacs.info,  Node: Frame,  Next: Keystrokes,  Prev: Concept Index,  Up: Top

The XEmacs Frame
****************

Frame
     In many environments, such as a tty terminal, an XEmacs frame
     literally takes up the whole screen.  If you are running XEmacs in
     a multi-window system like the X Window System, the XEmacs frame
     takes up one X window.  *Note XEmacs under X::, for more
     information.

Window
     No matter what environment you are running in, XEmacs allows you
     to look at several buffers at the same time by having several
     windows be part of the frame.  Often, the whole frame is taken up
     by just one window, but you can split the frame into two or more
     subwindows.  If you are running XEmacs under the X window system,
     that means you can have several "XEmacs windows" inside the X
     window that contains the XEmacs frame.  You can even have multiple
     frames in different X windows, each with their own set of
     subwindows.


   Each XEmacs frame displays a variety of information:
   * The biggest area usually displays the text you are editing.  It may
     consist of one window or of two or more windows if you need to
     look at two buffers a the same time.

   * Below each text window's last line is a "mode line" (*note Mode
     Line::), which describes what is going on in that window.  The
     mode line is in inverse video if the terminal supports that.  If
     there are several XEmacs windows in one frame, each window has its
     own mode line.

   * At the bottom of each XEmacs frame is the "echo area" or
     "minibuffer window"(*note Echo Area::).  It is used by XEmacs to
     exchange information with the user.  There is only one echo area
     per XEmacs frame.

   * If you are running XEmacs under a graphical windowing system, a
     menu bar at the top of the frame makes shortcuts to several of the
     commands available (*note Pull-down Menus::).

   * Under a graphical windowing system, a toolbar at the top of the
     frame, just under the menu bar if it exists, provides "one-touch"
     shortcuts to several commands.  (Not yet documented.)

   * Under a graphical windowing system, a gutter at the top (under the
     toolbar) and/or bottom of the frame provides advanced GUI
     facilities like tab controls for rapid switching among related
     windows and progress bars for time-consuming operations like
     downloads across the Internet.  Gutters are an experimental feature
     introduced in XEmacs version 21.2.  (Not yet documented.)

   You can subdivide the XEmacs frame into multiple text windows, and
use each window for a different file (*note Windows::).  Multiple XEmacs
windows are tiled vertically on the XEmacs frame.  The upper XEmacs
window is separated from the lower window by its mode line.

   When there are multiple, tiled XEmacs windows on a single XEmacs
frame, the XEmacs window receiving input from the keyboard has the
"keyboard focus" and is called the "selected window".  The selected
window contains the cursor, which indicates the insertion point.  If
you are working in an environment that permits multiple XEmacs frames,
and you move the focus from one XEmacs frame into another, the selected
window is the one that was last selected in that frame.

   The same text can be displayed simultaneously in several XEmacs
windows, which can be in different XEmacs frames.  If you alter the text
in an XEmacs buffer by editing it in one XEmacs window, the changes are
visible in all XEmacs windows containing that buffer.

* Menu:

* Point::	        The place in the text where editing commands operate.
* Echo Area::           Short messages appear at the bottom of the frame.
* Mode Line::	        Interpreting the mode line.
* GUI Components::      Menubar, toolbars, gutters.
* XEmacs under X::      Some information on using XEmacs under the X
                        Window System.
* XEmacs under MS Windows:: Some information on using XEmacs under
                        Microsoft Windows.


File: xemacs.info,  Node: Point,  Next: Echo Area,  Prev: Frame,  Up: Frame

Point
=====

When XEmacs is running, the cursor shows the location at which editing
commands will take effect.  This location is called "point".  You can
use keystrokes or the mouse cursor to move point through the text and
edit the text at different places.

   While the cursor appears to point AT a character, you should think
of point as BETWEEN two characters: it points BEFORE the character on
which the cursor appears.  The exception is at the end of the line,
where the cursor appears after the last character of the line.  Where
the display is capable, the cursor at the end of the line will appear
differently from a cursor over whitespace at the end of the line.  (In
an X Windows frame, the end-of-line cursor is half the width of a
within-line cursor.)  Sometimes people speak of "the cursor" when they
mean "point," or speak of commands that move point as "cursor motion"
commands.

   Each XEmacs frame has only one cursor.  When output is in progress,
the cursor must appear where the typing is being done.  This does not
mean that point is moving.  It is only that XEmacs has no way to show
you the location of point except when the terminal is idle.

   If you are editing several files in XEmacs, each file has its own
point location.  A file that is not being displayed remembers where
point is.  Point becomes visible at the correct location when you look
at the file again.

   When there are multiple text windows, each window has its own point
location.  The cursor shows the location of point in the selected
window.  The visible cursor also shows you which window is selected.  If
the same buffer appears in more than one window, point can be moved in
each window independently.

   The term `point' comes from the character `.', which was the command
in TECO (the language in which the original Emacs was written) for
accessing the value now called `point'.


File: xemacs.info,  Node: Echo Area,  Next: Mode Line,  Prev: Point,  Up: Frame

The Echo Area
=============

The line at the bottom of the frame (below the mode line) is the "echo
area".  XEmacs uses this area to communicate with the user:

   *   "Echoing" means printing out the characters that the user types.
     XEmacs never echoes single-character commands.  Multi-character
     commands are echoed only if you pause while typing them: As soon
     as you pause for more than one second in the middle of a command,
     all the characters of the command so far are echoed.  This is
     intended to "prompt" you for the rest of the command.  Once
     echoing has started, the rest of the command is echoed immediately
     as you type it.  This behavior is designed to give confident users
     fast response, while giving hesitant users maximum feedback.  You
     can change this behavior by setting a variable (*note Display
     Vars::).

   *   If you issue a command that cannot be executed, XEmacs may print
     an "error message" in the echo area.  Error messages are
     accompanied by a beep or by flashing the frame.  Any input you
     have typed ahead is thrown away when an error happens.

   *   Some commands print informative messages in the echo area.  These
     messages look similar to error messages, but are not announced
     with a beep and do not throw away input.  Sometimes a message
     tells you what the command has done, when this is not obvious from
     looking at the text being edited.  Sometimes the sole purpose of a
     command is to print a message giving you specific information.
     For example, the command `C-x =' is used to print a message
     describing the character position of point in the text and its
     current column in the window.  Commands that take a long time
     often display messages ending in `...' while they are working, and
     add `done' at the end when they are finished.

   *   The echo area is also used to display the "minibuffer", a window
     that is used for reading arguments to commands, such as the name
     of a file to be edited.  When the minibuffer is in use, the echo
     area displays with a prompt string that usually ends with a colon.
     The cursor appears after the prompt.  You can always get out of
     the minibuffer by typing `C-g'.  *Note Minibuffer::.


File: xemacs.info,  Node: Mode Line,  Next: GUI Components,  Prev: Echo Area,  Up: Frame

The Mode Line
=============

Each text window's last line is a "mode line" which describes what is
going on in that window.  When there is only one text window, the mode
line appears right above the echo area.  The mode line is in inverse
video if the terminal supports that, starts and ends with dashes, and
contains text like `XEmacs: SOMETHING'.

   If a mode line has something else in place of `XEmacs: SOMETHING',
the window above it is in a special subsystem such as Dired.  The mode
line then indicates the status of the subsystem.

   Normally, the mode line has the following appearance:

     --CH-XEmacs: BUF      (MAJOR MINOR)----POS------

This gives information about the buffer being displayed in the window:
the buffer's name, what major and minor modes are in use, whether the
buffer's text has been changed, and how far down the buffer you are
currently looking.

   CH contains two stars (`**') if the text in the buffer has been
edited (the buffer is "modified"), or two dashes (`--') if the buffer
has not been edited.  Exception: for a read-only buffer, it is `%%'.

   BUF is the name of the window's chosen "buffer".  The chosen buffer
in the selected window (the window that the cursor is in) is also
XEmacs's selected buffer, the buffer in which editing takes place.  When
we speak of what some command does to "the buffer", we mean the
currently selected buffer.  *Note Buffers::.

   POS tells you whether there is additional text above the top of the
screen or below the bottom.  If your file is small and it is completely
visible on the screen, POS is `All'.  Otherwise, POS is `Top' if you
are looking at the beginning of the file, `Bot' if you are looking at
the end of the file, or `NN%', where NN is the percentage of the file
above the top of the screen.

   MAJOR is the name of the "major mode" in effect in the buffer.  At
any time, each buffer is in one and only one major mode.  The available
major modes include Fundamental mode (the least specialized), Text
mode, Lisp mode, and C mode.  *Note Major Modes::, for details on how
the modes differ and how you select one.

   MINOR is a list of some of the "minor modes" that are turned on in
the window's chosen buffer.  For example, `Fill' means that Auto Fill
mode is on.  `Abbrev' means that Word Abbrev mode is on.  `Ovwrt' means
that Overwrite mode is on.  *Note Minor Modes::, for more information.
`Narrow' means that the buffer being displayed has editing restricted
to only a portion of its text.  This is not really a minor mode, but is
like one.  *Note Narrowing::.  `Def' means that a keyboard macro is
being defined.  *Note Keyboard Macros::.

   Some buffers display additional information after the minor modes.
For example, Rmail buffers display the current message number and the
total number of messages.  Compilation buffers and Shell mode display
the status of the subprocess.

   If XEmacs is currently inside a recursive editing level, square
brackets (`[...]') appear around the parentheses that surround the
modes.  If XEmacs is in one recursive editing level within another,
double square brackets appear, and so on.  Since information on
recursive editing applies to XEmacs in general and not to any one
buffer, the square brackets appear in every mode line on the screen or
not in any of them.  *Note Recursive Edit::.

   XEmacs can optionally display the time and system load in all mode
lines.  To enable this feature, type `M-x display-time'.  The
information added to the mode line usually appears after the file name,
before the mode names and their parentheses.  It looks like this:

     HH:MMpm L.LL [D]

(Some fields may be missing if your operating system cannot support
them.)  HH and MM are the hour and minute, followed always by `am' or
`pm'.  L.LL is the average number of running processes in the whole
system recently.  D is an approximate index of the ratio of disk
activity to CPU activity for all users.

   The word `Mail' appears after the load level if there is mail for
you that you have not read yet.

   Customization note: the variable `mode-line-inverse-video' controls
whether the mode line is displayed in inverse video (assuming the
terminal supports it); `nil' means no inverse video.  The default is
`t'.  For X frames, simply set the foreground and background colors
appropriately.


File: xemacs.info,  Node: GUI Components,  Next: XEmacs under X,  Prev: Mode Line,  Up: Frame

GUI Components
==============

When executed in a graphical windowing environment such as the X Window
System or Microsoft Windows, XEmacs displays several graphical user
interface components such as scrollbars, menubars, toolbars, and
gutters.  By default there is a vertical scrollbar at the right of each
frame, and at the top of the frame there is a menubar, a toolbar, and a
gutter, in that order.  Gutters can contain any of several widgets, but
the default configuration puts a set of "notebook tabs" which you can
use as a shortcut for selecting any of several related buffers in a
given frame.  Operating the GUI components is "obvious":  click on the
menubar to pull down a menu, on a button in the toolbar to invoke a
function, and on a tab in the gutter to switch buffers.

* Menu:

* Menubar Basics::      How XEmacs uses the menubar.
* Scrollbar Basics::    How XEmacs uses scrollbars.
* Mode Line Basics::    How XEmacs uses modelines.
* Toolbar Basics::      How XEmacs uses toolbars.
* Gutter Basics::       How XEmacs uses gutters.
* Inhibiting::          What if you don't like GUI?
* Customizing::         Position, orientation, and appearance of GUI objects.


File: xemacs.info,  Node: Menubar Basics,  Next: Scrollbar Basics,  Up: GUI Components

The XEmacs Menubar
==================

The XEmacs menubar is intended to be conformant to the usual conventions
for menubars, although conformance is not yet perfect.  The menu at the
extreme right is the `Help' menu, which should always be available.  It
provides access to all the XEmacs help facilities available through
`C-h', as well as samples of various configuration files like
`~/.Xdefaults' and `~/.emacs'.  At the extreme left is the `Files'
menu, which provides the usual file reading, writing, and printing
operations, as well as operations like revert buffer from most recent
save.  The next menu from the left is the `Edit' menu, which provides
the `Undo' operation as well as cutting and pasting, searching, and
keyboard macro definition and execution.

   XEmacs provides a very dynamic environment, and the Lisp language
makes for highly flexible applications.  The menubar reflects this:
many menus (eg, the `Buffers' menu, *note Buffers Menu::) contain items
determined by the current state of XEmacs, and most major modes and many
minor modes add items to menus and even whole menus to the menubar.  In
fact, some applications like w3.el and VM provide so many menus that
they define a whole new menubar and add a button that allows convenient
switching between the "XEmacs menubar" and the "application menubar".
Such applications normally bind themselves to a particular frame, and
this switching only takes place on frames where such an application is
active (ie, the current window of the frame is displaying a buffer in
the appropriate major mode).

   Other menus which are typically available are the `Options',
`Tools', `Buffers', `Apps', and `Mule' menus.  For detailed
descriptions of these menus, *Note Pull-down Menus::.  (In 21.2
XEmacsen, the `Mule' menu will be moved under `Options'.)


File: xemacs.info,  Node: Scrollbar Basics,  Next: Mode Line Basics,  Prev: Menubar Basics,  Up: GUI Components

XEmacs Scrollbars
=================

XEmacs scrollbars provide the usual interface.  Arrow buttons at either
end allow for line by line scrolling, including autorepeat.  Clicking in
the scrollbar itself provides scrolling by windowsfull, depending on
which side of the slider is clicked.  The slider itself may be dragged
for smooth scrolling.

   The position of the slider corresponds to the position of the window
in the buffer.  In particular, the length of the slider is proportional
to the fraction of the buffer which appears in the window.

   The presence of the scrollbars is under control of the application or
may be customized by the user.  By default a vertical scrollbar is
present in all windows (except the minibuffer), and there is no
horizontal scrollbar.


File: xemacs.info,  Node: Mode Line Basics,  Next: Toolbar Basics,  Prev: Scrollbar Basics,  Up: GUI Components

XEmacs Mode Lines
=================

When used in a windowing system, the XEmacs modelines can be dragged
vertically. The effect is to resize the windows above and below the
modeline (this includes the minibuffer window).

   Additionally, a modeline can be dragged horizontally, in which case
it scrolls its own text. This behavior is not enabled by default
because it could be considered as disturbing when dragging vertically.
When this behavior is enabled, the modeline's text can be dragged
either in the same direction as the mouse, or in the opposite sense,
making the modeline act as a scrollbar for its own text.

   You can select the behavior you want from the `Display' submenu of
the `Options' menu.


File: xemacs.info,  Node: Toolbar Basics,  Next: Gutter Basics,  Prev: Mode Line Basics,  Up: GUI Components

XEmacs Toolbars
===============

XEmacs has a default toolbar which provides shortcuts for some of the
commonly used operations (such as opening files) and applications (such
as the Info manual reader).  Operations which require arguments will pop
up dialogs to get them.

   The position of the default toolbar can be customized.  Also, several
toolbars may be present simultaneously (in different positions).  VM,
for example, provides an application toolbar which shortcuts for
mail-specific operations like sending, saving, and deleting messages.


File: xemacs.info,  Node: Gutter Basics,  Next: Inhibiting,  Prev: Toolbar Basics,  Up: GUI Components

XEmacs Gutters
==============

Gutters are the most flexible of the GUI components described in this
section.  In theory, the other GUI components could be implemented by
customizing a gutter, but in practice the other components were
introduced earlier and have their own special implementations.  Gutters
tend to be more transient than the other components.  Buffer tabs, for
example, change every time the selected buffer in the frame changes.
And for progress gauges a gutter to contain the gauge is typically
created on the fly when needed, then destroyed when the operation whose
staus is being displayed is completed.

   Buffer tabs, having somewhat complex behavior, deserve a closer look.
By default, a row of buffer tabs is displayed at the top of every frame.
(The tabs could be placed in the bottom gutter, but would be oriented
the same way and look rather odd.  The horizontal orientation makes
putting them in a side gutter utterly impractical.)  The buffer
displayed in the current window of a frame can be changed to a specific
buffer by clicking [mouse-1] on the corresponding tab in the gutter.

   Each tab contains the name of its buffer.  The tab for the current
buffer in each frame is displayed in raised relief.  The list of buffers
chosen for display in the buffer tab row is derived by filtering the
buffer list (like the `Buffers' menu).  The list starts out with all
existing buffers, with more recently selected buffers coming earlier in
the list.

   Then "uninteresting" buffers, like internal XEmacs buffers, the
`*Message Log*' buffer, and so on are deleted from the list.  Next, the
frame's selected buffer is determined.  Buffers with a different major
mode from the selected buffer are removed from the list.  Finally, if
the list is too long, the least recently used buffers are deleted from
the list.  By default up to 6 most recently used buffers with the same
mode are displayed on tabs in the gutter.

   This behavior can be altered by customizing
`buffers-tab-filter-functions'.  Setting this variable to `nil' forces
display of all buffers, up to `buffers-tab-max-size' (also
customizable).  More complex behavior may be available in 3rd party
libraries.  These, and some more rarely customized options, are in the
`buffers-tab' Customize group.


File: xemacs.info,  Node: Inhibiting,  Next: Customizing,  Prev: Gutter Basics,  Up: GUI Components

Inhibiting Display of GUI Components
====================================

Use of GUI facilities is a personal thing.  Almost everyone agrees that
drawing via keyboard-based "turtle graphics" is acceptable to hardly
anyone if a mouse is available, but conversely emulating a keyboard with
a screenful of buttons is a painful experience.  But between those
extremes the complete novice will require a fair amount of time before
toolbars and menus become dispensable, but many an "Ancien Haquer" sees
them as a complete waste of precious frame space that could be filled
with text.

   Display of all of the GUI components created by XEmacs can be
inhibited through the use of Customize.  Customize can be accessed
through `Options | Customize' in the menu bar, or via `M-x customize'.
Then navigate through the Customize tree to `Emacs | Environment'.
Scrollbar and toolbar visibility is controlled via the `Display' group,
options `Scrollbars visible' and  `Toolbar visible' respectively.
Gutter visibility is controlled by group `Gutter', option `Visible'.

   Or they can be controlled directly by `M-x customize-variable', by
changing the values of the variables `menubar-visible-p',
`scrollbars-visible-p', `toolbar-visible-p', or
`gutter-buffers-tab-visible-p' respectively.  (The strange form of the
last variable is due to the fact that gutters are often used to display
transient widgets like progress gauges, which you probably don't want
to inhibit.  It is more likely that you want to inhibit the default
display of the buffers tab widget, which is what that variable controls.
This interface is subject to change depending on developer experience
and user feedback.)

   Control of frame configuration can controlled automatically
according to various parameters such as buffer or frame because these
are "specifiers" *Note Specifiers: (lispref)Specifiers.  Using these
features requires programming in Lisp; Customize is not yet that
sophisticated.  Also, components that appear in various positions and
orientations can have display suppressed according to position.  `C-h a
visible-p' gives a list of variables which can be customized.  E.g., to
control the visibility of specifically the left-side toolbar only,
customize `left-toolbar-visible-p'.


File: xemacs.info,  Node: Customizing,  Prev: Inhibiting,  Up: GUI Components

Changing the Position, Orientation, and Appearance of GUI Components
====================================================================

#### Not documented yet.


File: xemacs.info,  Node: XEmacs under X,  Next: XEmacs under MS Windows,  Prev: GUI Components,  Up: Frame

Using XEmacs Under the X Window System
======================================

XEmacs can be used with the X Window System and a window manager like
MWM or TWM.  In that case, the X window manager opens, closes, and
resizes XEmacs frames.  You use the window manager's mouse gestures to
perform the operations.  Consult your window manager guide or reference
manual for information on manipulating X windows.

   When you are working under X, each X window (that is, each XEmacs
frame) has a menu bar for mouse-controlled operations (*note Pull-down
Menus::).

   XEmacs under X is also a multi-frame XEmacs.  You can use the New
Frame menu item from the File menu to create a new XEmacs frame in a
new X window from the same process.  The different frames will share the
same buffer list, but you can look at different buffers in the different
frames.

   The function `find-file-other-frame' is just like `find-file', but
creates a new frame to display the buffer in first.  This is normally
bound to `C-x 5 C-f', and is what the Open File, New Frame menu item
does.

   The function `switch-to-buffer-other-frame' is just like
`switch-to-buffer', but creates a new frame to display the buffer in
first.  This is normally bound to `C-x 5 b'.

   You can specify a different default frame size other than the one
provided.  Use the variable `default-frame-plist', which is a plist of
default values for frame creation other than the first one.  These may
be set in your init file, like this:

       (setq default-frame-plist '(width 80 height 55))

   This variable has replaced `default-frame-alist', which is
considered obsolete.

   For values specific to the first XEmacs frame, you must use X
resources.  The variable `x-frame-defaults' takes an alist of default
frame creation parameters for X window frames.  These override what is
specified in `~/.Xdefaults' but are overridden by the arguments to the
particular call to `x-create-frame'.

   When you create a new frame, the variable `create-frame-hook' is
called with one argument, the frame just created.

   If you want to close one or more of the X windows you created using
New Frame, use the Delete Frame menu item from the File menu.

   If you are working with multiple frames, some special information
applies:
   * Two variables, `frame-title-format' and `frame-icon-title-format'
     determine the title of the frame and the title of the icon that
     results if you shrink the frame.

   * The variables `auto-lower-frame' and `auto-raise-frame' position a
     frame. If true, `auto-lower-frame' lowers a frame to the bottom
     when it is no longer selected. If true, `auto-raise-frame' raises
     a frame to the top when it is selected. Under X, most
     ICCCM-compliant window managers will have options to do this for
     you, but these variables are provided in case you are using a
     broken window manager.

   * There is a new frame/modeline format directive, %S, which expands
     to the name of the current frame (a frame's name is distinct from
     its title; the name is used for resource lookup, among other
     things, and the title is simply what appears above the window.)


File: xemacs.info,  Node: XEmacs under MS Windows,  Prev: XEmacs under X,  Up: Frame

Using XEmacs Under Microsoft Windows
====================================

Use of XEmacs under MS Windows is not separately documented here, but
most operations available under the X Window System are also available
with MS Windows.

   Where possible, native MS Windows GUI components and capabilities are
used in XEmacs.


File: xemacs.info,  Node: Keystrokes,  Next: Pull-down Menus,  Prev: Frame,  Up: Top

Keystrokes, Key Sequences, and Key Bindings
*******************************************

* Menu:

* Intro to Keystrokes::      Keystrokes as building blocks of key sequences.
* Representing Keystrokes::  Using lists of modifiers and keysyms to
                             represent keystrokes.
* Key Sequences::            Combine key strokes into key sequences you can
                             bind to commands.
* String Key Sequences::     Available for upward compatibility.
* Meta Key::                 Using <ESC> to represent <Meta>
* Super and Hyper Keys::     Adding modifier keys on certain keyboards.
* Character Representation:: How characters appear in Emacs buffers.
* Commands::                 How commands are bound to key sequences.


File: xemacs.info,  Node: Intro to Keystrokes,  Next: Representing Keystrokes,  Prev: Keystrokes,  Up: Keystrokes

Keystrokes as Building Blocks of Key Sequences
==============================================

Earlier versions of Emacs used only the ASCII character set, which
defines 128 different character codes.  Some of these codes are
assigned graphic symbols like `a' and `='; the rest are control
characters, such as `Control-a' (also called `C-a').  `C-a' means you
hold down the <CTRL> key and then press `a'.

   Keybindings in XEmacs are not restricted to the set of keystrokes
that can be represented in ASCII.  XEmacs can tell the difference
between, for example, `Control-h', `Control-Shift-h', and `Backspace'.

   A keystroke is like a piano chord: you get it by simultaneously
striking several keys.  To be more precise, a keystroke consists of a
possibly empty set of modifiers followed by a single "keysym".  The set
of modifiers is small; it consists of `Control', `Meta', `Super',
`Hyper', and `Shift'.

   The rest of the keys on your keyboard, along with the mouse buttons,
make up the set of keysyms.  A keysym is usually what is printed on the
keys on your keyboard.  Here is a table of some of the symbolic names
for keysyms:
`a,b,c...'
     alphabetic keys

`f1,f2...'
     function keys

`button1'
     left mouse button

`button2'
     middle mouse button

`button3'
     right mouse button

`button1up'
     upstroke on the left mouse button

`button2up'
     upstroke on the middle mouse button

`button3up'
     upstroke on the right mouse button

`return'
     Return key

   Use the variable `keyboard-translate-table' only if you are on a
dumb tty, as it cannot handle input that cannot be represented as ASCII.
The value of this variable is a string used as a translate table for
keyboard input or `nil'.  Each character is looked up in this string
and the contents used instead.  If the string is of length `n',
character codes `N' and up are untranslated.  If you are running Emacs
under X, you should do the translations with the `xmodmap' program
instead.


File: xemacs.info,  Node: Representing Keystrokes,  Next: Key Sequences,  Prev: Intro to Keystrokes,  Up: Keystrokes

Representing Keystrokes
-----------------------

XEmacs represents keystrokes as lists. Each list consists of an
arbitrary combination of modifiers followed by a single keysym at the
end of the list.  If the keysym corresponds to an ASCII character, you
can use its character code.  (A keystroke may also be represented by an
event object, as returned by the `read-key-sequence' function;
non-programmers need not worry about this.)

   The following table gives some examples of how to list
representations for keystrokes.  Each list consists of sets of
modifiers followed by keysyms:

`(control a)'
     Pressing <CTRL> and `a' simultaneously.

`(control ?a)'
     Another way of writing the keystroke `C-a'.

`(control 65)'
     Yet another way of writing the keystroke `C-a'.

`(break)'
     Pressing the <BREAK> key.

`(control meta button2up)'
     Release the middle mouse button, while pressing <CTRL> and <META>.
     Note: As you define keystrokes, you can use the `shift' key only
as a modifier with characters that do not have a second keysym on the
same key, such as `backspace' and `tab'.  It is an error to define a
keystroke using the <shift> modifier with keysyms such as `a' and `='.
The correct forms are `A' and `+'.


File: xemacs.info,  Node: Key Sequences,  Next: String Key Sequences,  Prev: Representing Keystrokes,  Up: Keystrokes

Representing Key Sequences
--------------------------

A "complete key sequence" is a sequence of keystrokes that Emacs
understands as a unit.  Key sequences are significant because you can
bind them to commands.  Note that not all sequences of keystrokes are
possible key sequences.  In particular, the initial keystrokes in a key
sequence must make up a "prefix key sequence".

   Emacs represents a key sequence as a vector of keystrokes.  Thus, the
schematic representation of a complete key sequence is as follows:

       [(modifier .. modifier keysym) ... (modifier .. modifier keysym)]

   Here are some examples of complete key sequences:

`[(control c) (control a)]'
     Typing `C-c' followed by `C-a'

`[(control c) (control 65)]'
     Typing `C-c' followed by `C-a'. (Using the ASCII code for the
     character `a')

`[(control c) (break)]'
     Typing `C-c' followed by the `break' character.

   A "prefix key sequence" is the beginning of a series of longer
sequences that are valid key sequences; adding any single keystroke to
the end of a prefix results in a valid key sequence.  For example,
`control-x' is standardly defined as a prefix.  Thus there is a
two-character key sequence starting with `C-x' for each valid
keystroke, giving numerous possibilities.  Here are some samples:

   * `[(control x) (c)]'

   * `[(control x) (control c)]'

   Adding one character to a prefix key does not have to form a complete
key.  It could make another, longer prefix.  For example, `[(control x)
(\4)]' is itself a prefix that leads to any number of different
three-character keys, including `[(control x) (\4) (f)]', `[(control x)
(\4) (b)]' and so on.  It would be possible to define one of those
three-character sequences as a prefix, creating a series of
four-character keys, but we did not define any of them this way.

   By contrast, the two-character sequence `[(control f) (control k)]'
is not a key, because the `(control f)' is a complete key sequence in
itself.  You cannot give `[(control f (control k)]' an independent
meaning as a command while `(control f)' is a complete sequence,
because Emacs would understand <C-f C-k> as two commands.

   The predefined prefix key sequences in Emacs are `(control c)',
`(control x)', `(control h)', `[(control x) (\4)]', and `escape'.  You
can customize Emacs and could make new prefix keys or eliminate the
default key sequences.  *Note Key Bindings::.  For example, if you
redefine `(control f)' as a prefix, `[(control f) (control k)]'
automatically becomes a valid key sequence (complete, unless you define
it as a prefix as well).  Conversely, if you remove the prefix
definition of `[(control x) (\4)]', `[(control x) (\4) (f)]' (or
`[(control x) (\4) ANYTHING]') is no longer a valid key sequence.

   Note that the above paragraphs uses \4 instead of simply 4, because
\4 is the symbol whose name is "4", and plain 4 is the integer 4, which
would have been interpreted as the ASCII value.  Another way of
representing the symbol whose name is "4" is to write ?4, which would be
interpreted as the number 52, which is the ASCII code for the character
"4".  We could therefore actually have written 52 directly, but that is
far less clear.


File: xemacs.info,  Node: String Key Sequences,  Next: Meta Key,  Prev: Key Sequences,  Up: Keystrokes

String Key Sequences
--------------------

For backward compatibility, you may also represent a key sequence using
strings.  For example, we have the following equivalent representations:

`"\C-c\C-c"'
     `[(control c) (control c)]'

`"\e\C-c"'
     `[(meta control c)]'


File: xemacs.info,  Node: Meta Key,  Next: Super and Hyper Keys,  Prev: String Key Sequences,  Up: Keystrokes

Assignment of the <META> Key
----------------------------

Not all terminals have the complete set of modifiers.  Terminals that
have a <Meta> key allow you to type Meta characters by just holding
that key down.  To type `Meta-a', hold down <META> and press `a'.  On
those terminals, the <META> key works like the <SHIFT> key.  Such a key
is not always labeled <META>, however, as this function is often a
special option for a key with some other primary purpose.

   If there is no <META> key, you can still type Meta characters using
two-character sequences starting with <ESC>.  To enter `M-a', you could
type `<ESC> a'.  To enter `C-M-a', you would type `ESC C-a'.  <ESC> is
allowed on terminals with Meta keys, too, in case you have formed a
habit of using it.

   If you are running under X and do not have a <META> key, it is
possible to reconfigure some other key to be a <META> key.  *Note Super
and Hyper Keys::.

   Emacs believes the terminal has a <META> key if the variable
`meta-flag' is non-`nil'.  Normally this is set automatically according
to the termcap entry for your terminal type.  However, sometimes the
termcap entry is wrong, and then it is useful to set this variable
yourself.  *Note Variables::, for how to do this.

   Note: If you are running under the X window system, the setting of
the `meta-flag' variable is irrelevant.


File: xemacs.info,  Node: Super and Hyper Keys,  Next: Character Representation,  Prev: Meta Key,  Up: Keystrokes

Assignment of the <SUPER> and <HYPER> Keys
------------------------------------------

Most keyboards do not, by default, have <SUPER> or <HYPER> modifier
keys.  Under X, you can simulate the <SUPER> or <HYPER> key if you want
to bind keys to sequences using `super' and `hyper'.  You can use the
`xmodmap' program to do this.

   For example, to turn your <CAPS-LOCK> key into a <SUPER> key, do the
following:

   Create a file called `~/.xmodmap'.  In this file, place the lines

             remove Lock = Caps_Lock
             keysym Caps_Lock = Super_L
             add Mod2 = Super_L

   The first line says that the key that is currently called `Caps_Lock'
should no longer behave as a "lock" key.  The second line says that
this should now be called `Super_L' instead.  The third line says that
the key called `Super_L' should be a modifier key, which produces the
`Mod2' modifier.

   To create a <META> or <HYPER> key instead of a <SUPER> key, replace
the word `Super' above with `Meta' or `Hyper'.

   Just after you start up X, execute the command `xmodmap /.xmodmap'.
You can add this command to the appropriate initialization file to have
the command executed automatically.

   If you have problems, see the documentation for the `xmodmap'
program.  The X keyboard model is quite complicated, and explaining it
is beyond the scope of this manual.  However, we reprint the following
description from the X Protocol document for your convenience:

   A list of keysyms is associated with each keycode. If that list
(ignoring trailing `NoSymbol' entries) is a single keysym `K', then the
list is treated as if it were the list ```K NoSymbol K NoSymbol'''. If
the list (ignoring trailing `NoSymbol' entries) is a pair of keysyms
`K1 K2', then the list is treated as if it were the list ```K1 K2 K1
K2'''. If the list (ignoring trailing `NoSymbol' entries) is a triple
of keysyms `K1 K2 K3', then the list is treated as if it were the list
```K1 K2 K3 NoSymbol'''.

   The first four elements of the list are split into two groups of
keysyms. Group 1 contains the first and second keysyms; Group 2 contains
third and fourth keysyms. Within each group, if the second element of
the group is NoSymbol, then the group should be treated as if the second
element were the same as the first element, except when the first
element is an alphabetic keysym `K' for which both lowercase and
uppercase forms are defined. In that case, the group should be treated
as if the first element were the lowercase form of `K' and the second
element were the uppercase form of `K'.

   The standard rules for obtaining a keysym from a KeyPress event make
use of only the Group 1 and Group 2 keysyms; no interpretation of other
keysyms in the list is given here. (That is, the last four keysyms are
unused.)

   Which group to use is determined by modifier state. Switching between
groups is controlled by the keysym named `Mode_switch'. Attach that
keysym to some keycode and attach that keycode to any one of the
modifiers Mod1 through Mod5. This modifier is called the "group
modifier". For any keycode, Group 1 is used when the group modifier is
off, and Group 2 is used when the group modifier is on.

   Within a group, which keysym to use is also determined by modifier
state. The first keysym is used when the `Shift' and `Lock' modifiers
are off. The second keysym is used when the `Shift' modifier is on, or
when the `Lock' modifier is on and the second keysym is uppercase
alphabetic, or when the `Lock' modifier is on and is interpreted as
`ShiftLock'. Otherwise, when the `Lock' modifier is on and is
interpreted as `CapsLock', the state of the `Shift' modifier is applied
first to select a keysym, but if that keysym is lower-case alphabetic,
then the corresponding upper-case keysym is used instead.

   In addition to the above information on keysyms, we also provide the
following description of modifier mapping from the InterClient
Communications Conventions Manual:

   X11 supports 8 modifier bits, of which 3 are pre-assigned to
`Shift', `Lock', and `Control'. Each modifier bit is controlled by the
state of a set of keys, and these sets are specified in a table
accessed by `GetModifierMapping()' and `SetModifierMapping()'.

   A client needing to use one of the pre-assigned modifiers should
assume that the modifier table has been set up correctly to control
these modifiers. The `Lock' modifier should be interpreted as `Caps
Lock' or `Shift Lock' according to whether the keycodes in its
controlling set include `XK_Caps_Lock' or `XK_Shift_Lock'.

   Clients should determine the meaning of a modifier bit from the
keysyms being used to control it.

   A client needing to use an extra modifier, for example `Meta',
should:

  1. Scan the existing modifier mappings.

       1. If it finds a modifier that contains a keycode whose set of
          keysyms includes `XK_Meta_L' or `XK_Meta_R', it should use
          that modifier bit.

       2. If there is no existing modifier controlled by `XK_Meta_L' or
          `XK_Meta_R', it should select an unused modifier bit (one with
          an empty controlling set) and:

  2. If there is a keycode with `XL_Meta_L' in its set of keysyms, add
     that keycode to the set for the chosen modifier, and then:

       1. If there is a keycode with `XL_Meta_R' in its set of keysyms,
          add that keycode to the set for the chosen modifier, and then:

       2. If the controlling set is still empty, interact with the user
          to select one or more keys to be `Meta'.

  3. If there are no unused modifier bits, ask the user to take
     corrective action.

   This means that the `Mod1' modifier does not necessarily mean
`Meta', although some applications (such as twm and emacs 18) assume
that. Any of the five unassigned modifier bits could mean `Meta'; what
matters is that a modifier bit is generated by a keycode which is bound
to the keysym `Meta_L' or `Meta_R'.

   Therefore, if you want to make a <META> key, the right way is to
make the keycode in question generate both a `Meta' keysym and some
previously-unassigned modifier bit.


File: xemacs.info,  Node: Character Representation,  Next: Commands,  Prev: Super and Hyper Keys,  Up: Keystrokes

Representation of Characters
============================

This section briefly discusses how characters are represented in Emacs
buffers.  *Note Key Sequences::, for information on representing key
sequences to create key bindings.

   ASCII graphic characters in Emacs buffers are displayed with their
graphics.  <LFD> is the same as a newline character; it is displayed by
starting a new line.  <TAB> is displayed by moving to the next tab stop
column (usually every 8 spaces).  Other control characters are
displayed as a caret (`^') followed by the non-control version of the
character; thus, `C-a' is displayed as `^A'.  Non-ASCII characters 128
and up are displayed with octal escape sequences; thus, character code
243 (octal), also called `M-#' when used as an input character, is
displayed as `\243'.

   The variable `ctl-arrow' may be used to alter this behavior.  *Note
Display Vars::.


File: xemacs.info,  Node: Commands,  Prev: Character Representation,  Up: Keystrokes

Keys and Commands
=================

This manual is full of passages that tell you what particular keys do.
But Emacs does not assign meanings to keys directly.  Instead, Emacs
assigns meanings to "functions", and then gives keys their meanings by
"binding" them to functions.

   A function is a Lisp object that can be executed as a program.
Usually it is a Lisp symbol that has been given a function definition;
every symbol has a name, usually made of a few English words separated
by dashes, such as `next-line' or `forward-word'.  It also has a
"definition", which is a Lisp program.  Only some functions can be the
bindings of keys; these are functions whose definitions use
`interactive' to specify how to call them interactively.  Such
functions are called "commands", and their names are "command names".
More information on this subject will appear in the XEmacs Lisp
Reference Manual.

   The bindings between keys and functions are recorded in various
tables called "keymaps".  *Note Key Bindings::, for more information on
key sequences you can bind commands to.  *Note Keymaps::, for
information on creating keymaps.

   When we say  "`C-n' moves down vertically one line" we are glossing
over a distinction that is irrelevant in ordinary use but is vital in
understanding how to customize Emacs.  The function `next-line' is
programmed to move down vertically.  `C-n' has this effect because it
is bound to that function.  If you rebind `C-n' to the function
`forward-word' then `C-n' will move forward by words instead.
Rebinding keys is a common method of customization.

   The rest of this manual usually ignores this subtlety to keep things
simple.  To give the customizer the information needed, we often state
the name of the command that really does the work in parentheses after
mentioning the key that runs it.  For example, we will say that "The
command `C-n' (`next-line') moves point vertically down," meaning that
`next-line' is a command that moves vertically down and `C-n' is a key
that is standardly bound to it.

   While we are on the subject of information for customization only,
it's a good time to tell you about "variables".  Often the description
of a command will say, "To change this, set the variable `mumble-foo'."
A variable is a name used to remember a value.  Most of the variables
documented in this manual exist just to facilitate customization: some
command or other part of Emacs uses the variable and behaves
differently depending on its setting.  Until you are interested in
customizing, you can ignore the information about variables.  When you
are ready to be interested, read the basic information on variables, and
then the information on individual variables will make sense.  *Note
Variables::.


File: xemacs.info,  Node: Pull-down Menus,  Next: Entering Emacs,  Prev: Keystrokes,  Up: Top

XEmacs Pull-down Menus
======================

If you are running XEmacs under X, a menu bar on top of the Emacs frame
provides access to pull-down menus of file, edit, and help-related
commands. The menus provide convenient shortcuts and an easy interface
for novice users.  They do not provide additions to the functionality
available via key commands; you can still invoke commands from the
keyboard as in previous versions of Emacs.

File
     Perform file and buffer-related operations, such as opening and
     closing files, saving and printing buffers, as well as exiting
     Emacs.

Edit
     Perform standard editing operations, such as cutting, copying,
     pasting, and killing selected text.

Apps
     Access to sub-applications implemented within XEmacs, such as the
     mail reader, the World Wide Web browser, the spell-checker, and
     the calendar program.

Options
     Control various options regarding the way XEmacs works, such as
     controlling which elements of the frame are visible, selecting the
     fonts to be used for text, specifying whether searches are
     case-sensitive, etc.

Buffers
     Present a menu of buffers for selection as well as the option to
     display a buffer list.

Tools
     Perform various actions designed to automate software development
     and similar technical work, such as searching through many files,
     compiling a program, and comparing or merging two or three files.

Help
     Access to Emacs Info.

   There are two ways of selecting an item from a pull-down menu:

   * Select an item in the menu bar by moving the cursor over it and
     click the left mouse-button.  Then move the cursor over the menu
     item you want to choose and click left again.

   * Select an item in the menu bar by moving the cursor over it and
     click and hold the left mouse-button.  With the mouse-button
     depressed, move the cursor over the menu item you want, then
     release it to make your selection.

   If a command in the pull-down menu is not applicable in a given
situation, the command is disabled and its name appears faded.  You
cannot invoke items that are faded.  For example, many commands on the
Edit menu appear faded until you select text on which they are to
operate; after you select a block of text, edit commands are enabled.
*Note Mouse Selection::, for information on using the mouse to select
text.  *Note Using X Selections::, for related information.

   There are also `M-x' equivalents for each menu item.  To find the
equivalent for any left-button menu item, do the following:

  1. Type `C-h k' to get the `Describe Key' prompt.

  2. Select the menu item and click.

   Emacs displays the function associated with the menu item in a
separate window, usually together with some documentation.

* Menu:

* File Menu::           Items on the File menu.
* Edit Menu::           Items on the Edit menu.
* Apps Menu::		Items on the Apps menu.
* Options Menu::        Items on the Options menu.
* Buffers Menu::        Information about the Buffers menu.
* Tools Menu::		Items on the Tools menu.
* Help Menu::           Items on the Help menu.
* Menu Customization::  Adding and removing menu items and related
                        operations.


File: xemacs.info,  Node: File Menu,  Next: Edit Menu,  Up: Pull-down Menus

The File Menu
-------------

The File menu bar item contains the items New Frame, Open File..., Save
Buffer, Save Buffer As..., Revert Buffer, Print Buffer, Delete Frame,
Kill Buffer and Exit Emacs on the pull-down menu.  If you select a menu
item, Emacs executes the equivalent command.

Open File, New Frame...
     Prompts you for a filename and loads that file into a new buffer
     in a new Emacs frame, that is, a new X window running under the
     same Emacs process.  You can remove the frame using the Delete
     Frame menu item.  When you remove the last frame, you exit Emacs
     and are prompted for confirmation.

Open File...
     Prompts you for a filename and loads that file into a new buffer.
     Open File... is equivalent to the Emacs command `find-file' (`C-x
     C-f').

Insert File...
     Prompts you for a filename and inserts the contents of that file
     into the current buffer.  The file associated with the current
     buffer is not changed by this command.  This is equivalent to the
     Emacs command `insert-file' (`C-x i').

Save Buffer
     Writes and saves the current Emacs buffer as the latest version of
     the current visited file.  Save Buffer is equivalent to the Emacs
     command `save-buffer' (`C-x C-s').

Save Buffer As...
     Writes and saves the current Emacs buffer to the filename you
     specify.  Save Buffer As... is equivalent to the Emacs command
     `write-file' (`C-x C-w').

Revert Buffer
     Restores the last saved version of the file to the current buffer.
     When you edit a buffer containing a text file, you must save the
     buffer before your changes become effective.  Use Revert Buffer if
     you do not want to keep the changes you have made in the buffer.
     Revert Buffer is equivalent to the Emacs command `revert-file'
     (`M-x revert-buffer').

Kill Buffer
     Kills the current buffer, prompting you first if there are unsaved
     changes.  This is roughly equivalent to the Emacs command
     `kill-buffer' (`C-x k'), except that `kill-buffer' prompts for the
     name of a buffer to kill.

Print Buffer
     Prints a hardcopy of the current buffer.  Equivalent to the Emacs
     command `print-buffer' (`M-x print-buffer').

New Frame
     Creates a new Emacs frame displaying the `*scratch*' buffer.  This
     is like the Open File, New Frame... menu item, except that it does
     not prompt for or load a file.

Delete Frame
     Allows you to close all but one of the frames created by New Frame.
     If you created several Emacs frames belonging to the same Emacs
     process, you can close all but one of them.  When you attempt to
     close the last frame, Emacs informs you that you are attempting to
     delete the last frame.  You have to choose Exit Emacs for that.

Split Frame
     Divides the current window on the current frame into two
     equal-sized windows, both displaying the same buffer.  Equivalent
     to the Emacs command `split-window-vertically' (`C-x 2').

Un-split (Keep This)
     If the frame is divided into multiple windows, this removes all
     windows other than the selected one.  Equivalent to the Emacs
     command `delete-other-windows' (`C-x 1').

Un-split (Keep Others)
     If the frame is divided into multiple windows, this removes the
     selected window from the frame, giving the space back to one of the
     other windows.  Equivalent to the Emacs command `delete-window'
     (`C-x 0').

Exit Emacs
     Shuts down (kills) the Emacs process.  Equivalent to the Emacs
     command `save-buffers-kill-emacs' (`C-x C-c').  Before killing the
     Emacs process, the system asks which unsaved buffers to save by
     going through the list of all buffers in that Emacs process.


File: xemacs.info,  Node: Edit Menu,  Next: Apps Menu,  Prev: File Menu,  Up: Pull-down Menus

The Edit Menu
-------------

The Edit pull-down menu contains the Undo, Cut, Copy, Paste, and Clear
menu items.  When you select a menu item, Emacs executes the equivalent
command.  Most commands on the Edit menu work on a block of text, the X
selection.  They appear faded until you select a block of text
(activate a region) with the mouse.  *Note Using X Selections::, *note
Killing::, and *note Yanking:: for more information.

Undo
     Undoes the previous command.  Undo is equivalent to the Emacs
     command `undo' (`C-x u').

Cut
     Removes the selected text block from the current buffer, makes it
     the X clipboard selection, and places it in the kill ring.  Before
     executing this command, you have to select a region using Emacs
     region selection commands or with the mouse.

Copy
     Makes a selected text block the X clipboard selection, and places
     it in the kill ring.  You can select text using one of the Emacs
     region selection commands or by selecting a text region with the
     mouse.

Paste
     Inserts the current value of the X clipboard selection in the
     current buffer.  Note that this is not necessarily the same as the
     Emacs `yank' command, because the Emacs kill ring and the X
     clipboard selection are not the same thing.  You can paste in text
     you have placed in the clipboard using Copy or Cut.  You can also
     use Paste to insert text that was pasted into the clipboard from
     other applications.

Clear
     Removes the selected text block from the current buffer but does
     not place it in the kill ring or the X clipboard selection.

Start Macro Recording
     After selecting this, Emacs will remember every keystroke you type
     until End Macro Recording is selected.  This is the same as the
     Emacs command `start-kbd-macro' (`C-x (').

End Macro Recording
     Selecting this tells emacs to stop remembering your keystrokes.
     This is the same as the Emacs command `end-kbd-macro' (`C-x )').

Execute Last Macro
     Selecting this item will cause emacs to re-interpret all of the
     keystrokes which were saved between selections of the Start Macro
     Recording and End Macro Recording menu items.  This is the same as
     the Emacs command `call-last-kbd-macro' (`C-x e').


File: xemacs.info,  Node: Apps Menu,  Next: Options Menu,  Prev: Edit Menu,  Up: Pull-down Menus

The Apps Menu
-------------

The Apps pull-down menu contains the Read Mail (VM)..., Read Mail
(MH)..., Send Mail..., Usenet News, Browse the Web, Gopher, Spell-Check
Buffer and Emulate VI menu items, and the Calendar and Games sub-menus.
When you select a menu item, Emacs executes the equivalent command.
For some of the menu items, there are sub-menus which you will need to
select.


File: xemacs.info,  Node: Options Menu,  Next: Buffers Menu,  Prev: Apps Menu,  Up: Pull-down Menus

The Options Menu
----------------

The Options pull-down menu contains the Read Only, Case Sensitive
Search, Overstrike, Auto Delete Selection, Teach Extended Commands,
Syntax Highlighting, Paren Highlighting, Font, Size, Weight, Buffers
Menu Length..., Buffers Sub-Menus and Save Options menu items.  When
you select a menu item, Emacs executes the equivalent command.  For
some of the menu items, there are sub-menus which you will need to
select.

Read Only
     Selecting this item will cause the buffer to visit the file in a
     read-only mode. Changes to the file will not be allowed. This is
     equivalent to the Emacs command `toggle-read-only' (`C-x C-q').

Case Sensitive Search
     Selecting this item will cause searches to be case-sensitive. If
     its not selected then searches will ignore case. This option is
     local to the buffer.

Overstrike
     After selecting this item, when you type letters they will replace
     existing text on a one-to-one basis, rather than pushing it to the
     right. At the end of a line, such characters extend the line.
     Before a tab, such characters insert until the tab is filled in.
     This is the same as Emacs command `quoted-insert' (`C-q').

Auto Delete Selection
     Selecting this item will cause automatic deletion of the selected
     region. The typed text will replace the selection if the selection
     is active (i.e. if its highlighted). If the option is not selected
     then the typed text is just inserted at the point.

Teach Extended Commands
     After you  select this item, any time you execute a command with
     `M-x'which has a shorter keybinding, you will be shown the
     alternate binding before the command executes.

Syntax Highlighting
     You can customize your init file to include the font-lock mode so
     that when you select this item, the comments will be displayed in
     one face, strings in another, reserved words in another, and so
     on. *Note Init File::.  When Fonts is selected, different parts of
     the program will appear in different Fonts. When Colors is
     selected, then the program will be displayed in different colors.
     Selecting None causes the program to appear in just one Font and
     Color. Selecting Less resets the Fonts and Colors to a fast,
     minimal set of decorations. Selecting More resets the Fonts and
     Colors to a larger set of decorations. For example, if Less is
     selected (which is the default setting) then you might have all
     comments in green color.  Whereas, if More is selected then a
     function name in the comments themselves might appear in a
     different Color or Font.

Paren Highlighting
     After selecting Blink from this item, if you place the cursor on a
     parenthesis, the matching parenthesis will blink. If you select
     Highlight and place the cursor on a parenthesis, the whole
     expression of the parenthesis under the cursor will be highlighted.
     Selecting None will turn off the options (regarding Paren
     Highlighting) which you had selected earlier.

Font
     You can select any Font for your program by choosing from one of
     the available Fonts.

Size
     You can select any size ranging from 2 to 24 by selecting the
     appropriate option.

Weight
     You can choose either Bold or Medium for the weight.

Buffers Menu Length...
     Prompts you for the number of buffers to display. Then it will
     display that number of most recently selected buffers.

Buffers Sub-Menus
     After selection of this item the Buffers menu will contain several
     commands, as submenus of each buffer line. If this item is
     unselected, then there are no submenus for each buffer line, the
     only command available will be selecting that buffer.

Save Options
     Selecting this item will save the current settings of your Options
     menu to your init file.  *Note Init File::.


File: xemacs.info,  Node: Buffers Menu,  Next: Tools Menu,  Prev: Options Menu,  Up: Pull-down Menus

The Buffers Menu
----------------

The Buffers menu provides a selection of up to ten buffers and the item
List All Buffers, which provides a Buffer List. *Note List Buffers::,
for more information.


File: xemacs.info,  Node: Tools Menu,  Next: Help Menu,  Prev: Buffers Menu,  Up: Pull-down Menus

The Tools Menu
--------------

The Tools pull-down menu contains the Grep..., Compile..., Shell
Command..., Shell Command on Region..., Debug(GDB)...  and
Debug(DBX)... menu items, and the Compare, Merge, Apply Patch and Tags
sub-menus.  When you select a menu item, Emacs executes the equivalent
command.  For some of the menu items, there are sub-menus which you
will need to select.


File: xemacs.info,  Node: Help Menu,  Next: Menu Customization,  Prev: Tools Menu,  Up: Pull-down Menus

The Help Menu
-------------

The Help Menu gives you access to Emacs Info and provides a menu
equivalent for each of the choices you have when using `C-h'.  *Note
Help::, for more information.

   The Help menu also gives access to UNIX online manual pages via the
UNIX Manual Page option.


File: xemacs.info,  Node: Menu Customization,  Prev: Help Menu,  Up: Pull-down Menus

Customizing XEmacs Menus
------------------------

You can customize any of the pull-down menus by adding or removing menu
items and disabling or enabling existing menu items.

   The following functions are available:
`add-menu: (MENU-PATH MENU-NAME MENU-ITEMS &optional BEFORE)'
     Add a menu to the menu bar or one of its submenus.

`add-menu-item: (MENU-PATH ITEM-NAME FUNCTION'
     ENABLED-P &optional BEFORE) Add a menu item to a menu, creating
     the menu first if necessary.

`delete-menu-item: (PATH)'
     Remove the menu item defined by PATH from the menu hierarchy.

`disable-menu-item: (PATH)'
     Disable the specified menu item.

`enable-menu-item: (PATH)'
     Enable the specified previously disabled menu item.

`relabel-menu-item: (PATH NEW-NAME)'
     Change the string of the menu item specified by PATH to NEW-NAME.


   Use the function `add-menu' to add a new menu or submenu.  If a menu
or submenu of the given name exists already, it is changed.

   MENU-PATH identifies the menu under which the new menu should be
inserted.  It is a list of strings; for example, `("File")' names the
top-level File menu.  `("File" "Foo")' names a hypothetical submenu of
File.  If MENU-PATH is `nil', the menu is added to the menu bar itself.

   MENU-NAME is the string naming the menu to be added.

   MENU-ITEMS is a list of menu item descriptions.  Each menu item
should be a vector of three elements:

   * A string, which is the name of the menu item

   * A symbol naming a command, or a form to evaluate

   * `t' or `nil' to indicate whether the item is selectable

   The optional argument BEFORE is the name of the menu before which
the new menu or submenu should be added.  If the menu is already
present, it is not moved.

   The function `add-menu-item' adds a menu item to the specified menu,
creating the menu first if necessary.  If the named item already
exists, the menu remains unchanged.

   MENU-PATH identifies the menu into which the new menu item should be
inserted.  It is a list of strings; for example, `("File")' names the
top-level File menu.  `("File" "Foo")' names a hypothetical submenu of
File.

   ITEM-NAME is the string naming the menu item to add.

   FUNCTION is the command to invoke when this menu item is selected.
If it is a symbol, it is invoked with `call-interactively', in the same
way that functions bound to keys are invoked.  If it is a list, the
list is simply evaluated.

   ENABLED-P controls whether the item is selectable or not.  It should
be `t', `nil', or a form to evaluate to decide.  This form will be
evaluated just before the menu is displayed, and the menu item will be
selectable if that form returns non-`nil'.

   For example, to make the `rename-file' command available from the
File menu, use the following code:

     (add-menu-item '("File") "Rename File" 'rename-file t)

   To add a submenu of file management commands using a File Management
item, use the following code:

     (add-menu-item '("File" "File Management") "Copy File" 'copy-file t)
     (add-menu-item '("File" "File Management") "Delete File" 'delete-file t)
     (add-menu-item '("File" "File Management") "Rename File" 'rename-file t)

   The optional BEFORE argument is the name of a menu item before which
the new item should be added.  If the item is already present, it is
not moved.

   To remove a specified menu item from the menu hierarchy, use
`delete-menu-item'.

   PATH is a list of strings that identify the position of the menu
item in the menu hierarchy.  `("File" "Save")' means the menu item
called Save under the top level File menu.  `("Menu" "Foo" "Item")'
means the menu item called Item under the Foo submenu of Menu.

   To disable a menu item, use `disable-menu-item'.  The disabled menu
item is grayed and can no longer be selected.  To make the item
selectable again, use `enable-menu-item'.  `disable-menu-item' and
`enable-menu-item' both have the argument PATH.

   To change the string of the specified menu item, use
`relabel-menu-item'. This function also takes the argument PATH.

   NEW-NAME is the string to which the menu item will be changed.


File: xemacs.info,  Node: Entering Emacs,  Next: Exiting,  Prev: Pull-down Menus,  Up: Top

Entering and Exiting Emacs
**************************

The usual way to invoke XEmacs is to type `xemacs <RET>' at the shell.
XEmacs clears the screen and then displays an initial advisory message
and copyright notice.  You can begin typing XEmacs commands immediately
afterward.

   Some operating systems insist on discarding all type-ahead when
XEmacs starts up; they give XEmacs no way to prevent this.  Therefore,
it is advisable to wait until XEmacs clears the screen before typing
your first editing command.

   If you run XEmacs from a shell window under the X Window System, run
it in the background with `xemacs&'.  This way, XEmacs does not tie up
the shell window, so you can use that to run other shell commands while
XEmacs operates its own X windows.  You can begin typing XEmacs commands
as soon as you direct your keyboard input to the XEmacs frame.

   Before Emacs reads the first command, you have not had a chance to
give a command to specify a file to edit.  Since Emacs must always have
a current buffer for editing, it presents a buffer, by default, a buffer
named `*scratch*'.  The buffer is in Lisp Interaction mode; you can use
it to type Lisp expressions and evaluate them, or you can ignore that
capability and simply doodle.  (You can specify a different major mode
for this buffer by setting the variable `initial-major-mode' in your
init file.  *Note Init File::.)

   It is possible to specify files to be visited, Lisp files to be
loaded, and functions to be called, by giving Emacs arguments in the
shell command line.  *Note Command Switches::.  But we don't recommend
doing this.  The feature exists mainly for compatibility with other
editors.

   Many other editors are designed to be started afresh each time you
want to edit.  You edit one file and then exit the editor.  The next
time you want to edit either another file or the same one, you must run
the editor again.  With these editors, it makes sense to use a
command-line argument to say which file to edit.

   But starting a new Emacs each time you want to edit a different file
does not make sense.  For one thing, this would be annoyingly slow.  For
another, this would fail to take advantage of Emacs's ability to visit
more than one file in a single editing session.  And it would lose the
other accumulated context, such as registers, undo history, and the mark
ring.

   The recommended way to use XEmacs is to start it only once, just
after you log in, and do all your editing in the same Emacs session.
Each time you want to edit a different file, you visit it with the
existing Emacs, which eventually comes to have many files in it ready
for editing.  Usually you do not kill the Emacs until you are about to
log out.  *Note Files::, for more information on visiting more than one
file.


File: xemacs.info,  Node: Exiting,  Next: Command Switches,  Prev: Entering Emacs,  Up: Top

Exiting Emacs
=============

There are two commands for exiting Emacs because there are two kinds of
exiting: "suspending" Emacs and "killing" Emacs.

   "Suspending" means stopping Emacs temporarily and returning control
to its parent process (usually a shell), allowing you to resume editing
later in the same Emacs job, with the same buffers, same kill ring,
same undo history, and so on.  This is the usual way to exit.

   "Killing" Emacs means destroying the Emacs job.  You can run Emacs
again later, but you will get a fresh Emacs; there is no way to resume
the same editing session after it has been killed.

`C-z'
     Suspend Emacs or iconify a frame
     (`suspend-emacs-or-iconify-frame').  If used under the X window
     system, shrink the X window containing the Emacs frame to an icon
     (see below).

`C-x C-c'
     Kill Emacs (`save-buffers-kill-emacs').

   If you use XEmacs under the X window system, `C-z' shrinks the X
window containing the Emacs frame to an icon.  The Emacs process is
stopped temporarily, and control is returned to the window manager.  If
more than one frame is associated with the Emacs process, only the
frame from which you used `C-z' is iconified.

   To activate the "suspended" Emacs, use the appropriate window manager
mouse gestures.  Usually left-clicking on the icon reactivates and
reopens the X window containing the Emacs frame, but the window manager
you use determines what exactly happens.  To actually kill the Emacs
process, use `C-x C-c' or the Exit XEmacs item on the File menu.

   To suspend Emacs, type `C-z' (`suspend-emacs').  This takes you back
to the shell from which you invoked Emacs.  You can resume Emacs with
the shell command `%xemacs' in most common shells.

   On systems that do not support suspending programs, `C-z' starts an
inferior shell that communicates directly with the terminal.  Emacs
waits until you exit the subshell.  (The way to do that is probably
with `C-d' or `exit', but it depends on which shell you use.)  The only
way on these systems to get back to the shell from which Emacs was run
(to log out, for example) is to kill Emacs.

   Suspending also fails if you run Emacs under a shell that doesn't
support suspending programs, even if the system itself does support it.
In such a case, you can set the variable `cannot-suspend' to a
non-`nil' value to force `C-z' to start an inferior shell.  (One might
also describe Emacs's parent shell as "inferior" for failing to support
job control properly, but that is a matter of taste.)

   When Emacs communicates directly with an X server and creates its own
dedicated X windows, `C-z' has a different meaning.  Suspending an
applications that uses its own X windows is not meaningful or useful.
Instead, `C-z' runs the command `iconify-or-deiconify-frame', which
temporarily closes up the selected Emacs frame.  The way to get back to
a shell window is with the window manager.

   To kill Emacs, type `C-x C-c' (`save-buffers-kill-emacs').  A
two-character key is used for this to make it harder to type.  Selecting
the Exit XEmacs option of the File menu is an alternate way of issuing
the command.

   Unless a numeric argument is used, this command first offers to save
any modified file-visiting buffers.  If you do not save all buffers,
you are asked for reconfirmation with `yes' before killing Emacs, since
any changes not saved will be lost forever.  If any subprocesses are
still running, `C-x C-c' asks you to confirm killing them, since killing
Emacs will kill the subprocesses immediately.

   There is no way to restart an Emacs session once you have killed it.
You can, however, arrange for Emacs to record certain session
information, such as which files are visited, when you kill it, so that
the next time you restart Emacs it will try to visit the same files and
so on.

   The operating system usually listens for certain special characters
whose meaning is to kill or suspend the program you are running.  This
operating system feature is turned off while you are in Emacs.  The
meanings of `C-z' and `C-x C-c' as keys in Emacs were inspired by the
use of `C-z' and `C-c' on several operating systems as the characters
for stopping or killing a program, but that is their only relationship
with the operating system.  You can customize these keys to run any
commands of your choice (*note Keymaps::).


File: xemacs.info,  Node: Command Switches,  Next: Startup Paths,  Prev: Exiting,  Up: Top

Command Line Switches and Arguments
===================================

XEmacs supports command line arguments you can use to request various
actions when invoking Emacs.  The commands are for compatibility with
other editors and for sophisticated activities.  If you are using
XEmacs under the X window system, you can also use a number of standard
Xt command line arguments. Command line arguments are not usually
needed for editing with Emacs; new users can skip this section.

   Many editors are designed to be started afresh each time you want to
edit.  You start the editor to edit one file; then exit the editor.  The
next time you want to edit either another file or the same one, you
start the editor again.  Under these circumstances, it makes sense to
use a command line argument to say which file to edit.

   The recommended way to use XEmacs is to start it only once, just
after you log in, and do all your editing in the same Emacs process.
Each time you want to edit a file, you visit it using the existing
Emacs.  Emacs creates a new buffer for each file, and (unless you kill
some of the buffers) Emacs eventually has many files in it ready for
editing.  Usually you do not kill the Emacs process until you are about
to log out.  Since you usually read files by typing commands to Emacs,
command line arguments for specifying a file when Emacs is started are
seldom needed.

   Emacs accepts command-line arguments that specify files to visit,
functions to call, and other activities and operating modes.  If you
are running XEmacs under the X window system, a number of standard Xt
command line arguments are available, as well as a few X parameters
that are XEmacs-specific.

   Options with long names with a single initial hyphen are also
recognized with the GNU double initial hyphen syntax.  (The reverse is
not true.)

   The following subsections list:
   * Command line arguments that you can always use

   * Command line arguments that have to appear at the beginning of the
     argument list

   * Command line arguments that are only relevant if you are running
     XEmacs under X

Command Line Arguments for Any Position
---------------------------------------

Command line arguments are processed in the order they appear on the
command line; however, certain arguments (the ones in the second table)
must be at the front of the list if they are used.

   Here are the arguments allowed:

`FILE'
     Visit FILE using `find-file'.  *Note Visiting::.

`+LINENUM FILE'
     Visit FILE using `find-file', then go to line number LINENUM in it.

`-load FILE'
`-l FILE'
     Load a file FILE of Lisp code with the function `load'.  *Note
     Lisp Libraries::.

`-funcall FUNCTION'
`-f FUNCTION'
     Call Lisp function FUNCTION with no arguments.

`-eval FUNCTION'
     Interpret the next argument as a Lisp expression, and evaluate it.
     You must be very careful of the shell quoting here.

`-insert FILE'
`-i FILE'
     Insert the contents of FILE into the current buffer.  This is like
     what `M-x insert-buffer' does; *Note Misc File Ops::.

`-kill'
     Exit from Emacs without asking for confirmation.  Always the last
     argument processed, no matter where it appears in the command line.

`-version'
`-V'
     Prints version information.  This implies `-batch'.

          % xemacs -version
          XEmacs 19.13 of Mon Aug 21 1995 on willow (usg-unix-v) [formerly Lucid Emacs]

`-help'
     Prints a summary of command-line options and then exits.

Command Line Arguments (Beginning of Line Only)
-----------------------------------------------

The following arguments are recognized only at the beginning of the
command line.  If more than one of them appears, they must appear in the
order in which they appear in this table.

`--show-dump-id'
`-sd'
     Print the ID for the new portable dumper's dump file on the
     terminal and exit.  (Prints an error message and exits if XEmacs
     was not configured `--pdump'.)

`--no-dump-file'
`-nd'
     Don't load the dump file.  Roughly equivalent to old temacs.
     (Ignored if XEmacs was not configured `--pdump'.)

`--terminal FILE'
`-t FILE'
     Use FILE instead of the terminal for input and output.  This
     implies the `-nw' option, documented below.

`-batch'
     Run Emacs in "batch mode", which means that the text being edited
     is not displayed and the standard Unix interrupt characters such as
     `C-z' and `C-c' continue to have their normal effect.  Emacs in
     batch mode outputs to `stderr' only what would normally be printed
     in the echo area under program control.

     Batch mode is used for running programs written in Emacs Lisp from
     shell scripts, makefiles, and so on.  Normally the `-l' switch or
     `-f' switch will be used as well, to invoke a Lisp program to do
     the batch processing.

     `-batch' implies `-q' (do not load an init file).  It also causes
     Emacs to kill itself after all command switches have been
     processed.  In addition, auto-saving is not done except in buffers
     for which it has been explicitly requested.

`--no-windows'
`-nw'
     Start up XEmacs in TTY mode (using the TTY XEmacs was started
     from), rather than trying to connect to an X display.  Note that
     this happens automatically if the `DISPLAY' environment variable
     is not set.

`-debug-init'
     Enter the debugger if an error in the init file occurs.

`-debug-paths'
     Displays information on how XEmacs constructs the various paths
     into its hierarchy on startup.  (See also *note Startup Paths::.)

`-unmapped'
     Do not map the initial frame.  This is useful if you want to start
     up XEmacs as a server (e.g. for gnuserv screens or external client
     widgets).

`-no-init-file'
`-q'
     Do not load your Emacs init file.  *Note Init File::.

`-no-site-file'
     Do not load the site-specific init file `lisp/site-start.el'.

`-no-autoloads'
     Do not load global symbol files (`auto-autoloads') at startup.
     This implies `-vanilla'.

`-no-early-packages'
     Do not process early packages.  (For more information on startup
     issues concerning the package system, *Note Startup Paths::.)

`-vanilla'
     This is equivalent to `-q -no-site-file -no-early-packages'.

`-user-init-file FILE'
     Load FILE as your Emacs init file instead of
     `~/.xemacs/init.el'/`~/.emacs'.

`-user-init-directory DIRECTORY'
     Use DIRECTORY as the location of your early package hierarchies
     and the various user-specific initialization files.

`-user USER'
`-u USER'
     Equivalent to `-user-init-file ~USER/.xemacs/init.el
     -user-init-directory ~USER/.xemacs', or `-user-init-file
     ~USER/.emacs -user-init-directory ~USER/.xemacs', whichever init
     file comes first.  *Note Init File::.


   Note that the init file can get access to the command line argument
values as the elements of a list in the variable `command-line-args'.
(The arguments in the second table above will already have been
processed and will not be in the list.)  The init file can override the
normal processing of the other arguments by setting this variable.

   One way to use command switches is to visit many files automatically:

     xemacs *.c

passes each `.c' file as a separate argument to Emacs, so that Emacs
visits each file (*note Visiting::).

   Here is an advanced example that assumes you have a Lisp program file
called `hack-c-program.el' which, when loaded, performs some useful
operation on the current buffer, expected to be a C program.

     xemacs -batch foo.c -l hack-c-program -f save-buffer -kill > log

Here Emacs is told to visit `foo.c', load `hack-c-program.el' (which
makes changes in the visited file), save `foo.c' (note that
`save-buffer' is the function that `C-x C-s' is bound to), and then
exit to the shell from which the command was executed.  `-batch'
guarantees there will be no problem redirecting output to `log',
because Emacs will not assume that it has a display terminal to work
with.

Command Line Arguments (for XEmacs Under X)
-------------------------------------------

If you are running XEmacs under X, a number of options are available to
control color, border, and window title and icon name:

`-title TITLE'
`-wn TITLE'
`-T TITLE'
     Use TITLE as the window title. This sets the `frame-title-format'
     variable, which controls the title of the X window corresponding
     to the selected frame.  This is the same format as
     `mode-line-format'.

`-iconname TITLE'
`-in TITLE'
     Use TITLE as the icon name. This sets the
     `frame-icon-title-format' variable, which controls the title of
     the icon corresponding to the selected frame.

`-mc COLOR'
     Use COLOR as the mouse color.

`-cr COLOR'
     Use COLOR as the text-cursor foreground color.

`-private'
     Install a private colormap for XEmacs.

   In addition, XEmacs allows you to use a number of standard Xt
command line arguments.

`-background COLOR'
`-bg COLOR'
     Use COLOR as the background color.

`-bordercolor COLOR'
`-bd COLOR'
     Use COLOR as the border color.

`-borderwidth WIDTH'
`-bw WIDTH'
     Use WIDTH as the border width.

`-display DISPLAY'
`-d DISPLAY'
     When running under the X window system, create the window
     containing the Emacs frame on the display named DISPLAY.

`-foreground COLOR'
`-fg COLOR'
     Use COLOR as the foreground color.

`-font NAME'
`-fn NAME'
     Use NAME as the default font.

`-geometry SPEC'
`-geom SPEC'
`-g SPEC'
     Use the geometry (window size and/or position) specified by SPEC.

`-iconic'
     Start up iconified.

`-rv'
     Bring up Emacs in reverse video.

`-name NAME'
     Use the resource manager resources specified by NAME.  The default
     is to use the name of the program (`argv[0]') as the resource
     manager name.

`-xrm'
     Read something into the resource database for this invocation of
     Emacs only.



File: xemacs.info,  Node: Startup Paths,  Next: Packages,  Prev: Command Switches,  Up: Top

How XEmacs finds Directories and Files
======================================

XEmacs deals with a multitude of files during operation.  These files
are spread over many directories, and XEmacs determines the location of
most of these directories at startup and organizes them into various
paths.  (A "path", for the purposes of this section, is simply a list
of directories which XEmacs searches successively in order to locate a
file.)

XEmacs Directory Hierarchies
----------------------------

Many of the files XEmacs looks for are located within the XEmacs
installation itself.  However, there are several views of what actually
constitutes the "XEmacs installation": XEmacs may be run from the
compilation directory, it may be installed into arbitrary directories,
spread over several directories unrelated to each other.  Moreover, it
may subsequently be moved to a different place.  (This last case is not
as uncommon as it sounds.  Binary kits work this way.)  Consequently,
XEmacs has quite complex procedures in place to find directories, no
matter where they may be hidden.

   XEmacs will always respect directory options passed to `configure'.
However, if it cannot locate a directory at the configured place, it
will initiate a search for the directory in any of a number of
"hierarchies" rooted under a directory which XEmacs assumes contain
parts of the XEmacs installation; it may locate several such hierarchies
and search across them.  (Typically, there are just one or two
hierarchies: the hierarchy where XEmacs was or will be installed, and
the one where it is being built.)  Such a directory containing a
hierarchy is called a "root".  Whenever this section refers to a
directory using the shorthand `<root>', it means that XEmacs searches
for it under all hierarchies XEmacs was able to scrounge up.  In a
running XEmacs, the hierarchy roots are stored in the variable
`emacs-roots'.

Package Hierarchies
-------------------

Many relevant directories and files XEmacs uses are actually not part of
the core installation.  They are part of any of the many packages
usually installed on top of an XEmacs installation.  (*Note Packages::.)
Hence, they play a prominent role in the various paths XEmacs sets up.

   XEmacs locates packages in any of a number of package hierarchies.
Package hierarchies fall into three groups: "early", "late", and "last",
according to the relative location at which they show up in the various
XEmacs paths.  Early package hierarchies are at the very front, late
ones somewhere in the middle, and last hierarchies are (you guessed it)
last.

   By default, XEmacs expects an early package hierarchy in the
subdirectory `.xemacs/xemacs-packages' of the user's home directory.

   Moreover, XEmacs expects late hierarchies in the subdirectories
`site-packages', `mule-packages', and `xemacs-packages' (in that order)
of the `<root>/lib/xemacs' subdirectory of one of the installation
hierarchies.  (If you run in-place, these are direct subdirectories of
the build directory.)  Furthermore, XEmacs will also search these
subdirectories in the `<root>/lib/xemacs-<VERSION>' subdirectory and
prefer directories found there.

   By default, XEmacs does not have a pre-configured last package
hierarchy.  Last hierarchies are primarily for using package hierarchies
of outdated versions of XEmacs as a fallback option.  For example, it is
possible to run XEmacs 21 with the 20.4 package hierarchy as a last
hierarchy.

   It is possible to specify at configure-time the location of the
various package hierarchies with the `--package-path' option to
configure.  The early, late, and last components of the package path
are separated by double instead of single colons.  If all three
components are present, they locate the early, late, and last package
hierarchies respectively.  If two components are present, they locate
the early and late hierarchies.  If only one component is present, it
locates the late hierarchy.  At run time, the package path may also be
specified via the `EMACSPACKAGEPATH' environment variable.

   An XEmacs package is laid out just like a normal installed XEmacs
lisp directory.  It may have `lisp', `etc', `info', and `lib-src'
subdirectories.  XEmacs adds these at appropriate places within the
various system-wide paths.

   There may be any number of package hierarchy directories.

Directories and Paths
---------------------

Here is a list of the various directories and paths XEmacs tries to
locate during startup.  XEmacs distinguishes between directories and
paths specific to "version", "site", and "architecture" when looking
for them.

`version-specific'
     directories are specific to the version of XEmacs they belong to
     and typically reside under `<root>/lib/xemacs-<VERSION>'.

`site-specific'
     directories are independent of the version of XEmacs they belong
     to and typically reside under `<root>/lib/xemacs'

`architecture-specific'
     directories are specific both to the version of XEmacs and the
     architecture it runs on and typically reside under
     `<root>/lib/xemacs-<VERSION>/<ARCHITECTURE>'.

   During installation, all of these directories may also reside
directly under `<root>', because that is where they are in the XEmacs
tarball.

   If XEmacs runs with the `-debug-paths' option (*note Command
Switches::), it will print the values of these variables, hopefully
aiding in debugging any problems which come up.

`lisp-directory'
     Contains the version-specific location of the Lisp files that come
     with the core distribution of XEmacs.  XEmacs will search it
     recursively to a depth of 1 when setting up `load-path'.

`load-path'
     Is where XEmacs searches for XEmacs Lisp files with commands like
     `load-library'.  It contains the package lisp directories (see
     further down) and the version-specific core Lisp directories.  If
     the environment variable `EMACSLOADPATH' is set at startup, its
     directories are prepended to `load-path'.

`Info-directory-list'
     Contains the location of info files.  (See *Note (info)::.)  It
     contains the package info directories and the version-specific core
     documentation.  Moreover, XEmacs will add `/usr/info',
     `/usr/local/info' as well as the directories of the environment
     variable `INFOPATH' to `Info-directory-list'.

`exec-directory'
     Is the directory of architecture-dependent files that come with
     XEmacs, especially executable programs intended for XEmacs to
     invoke.

`exec-path'
     Is the path for executables which XEmacs may want to start.  It
     contains the package executable paths as well as `exec-directory',
     and the directories of the environment variables `PATH' and
     `EMACSPATH'.

`doc-directory'
     Is the directory containing the architecture-specific `DOC' file
     that contains documentation for XEmacs' commands.

`data-directory'
     Is the version-specific directory that contains core data files
     XEmacs uses.  It may be initialized from the `EMACSDATA'
     environment variable.

`data-directory-list'
     Is the path where XEmacs looks for data files.  It contains
     package data directories as well as `data-directory'.



File: xemacs.info,  Node: Basic,  Next: Undo,  Prev: Packages,  Up: Top

Basic Editing Commands
**********************

We now give the basics of how to enter text, make corrections, and save
the text in a file.  If this material is new to you, you might learn it
more easily by running the Emacs learn-by-doing tutorial.  To use the
tutorial, run Emacs and type `Control-h t' (`help-with-tutorial').  You
can also use Tutorials item from the Help menu.

   XEmacs comes with many translations of tutorial.  If your XEmacs is
with MULE and you set up language environment correctly, XEmacs chooses
right tutorial when available (*note Language Environments::).  If you
want specific translation, give `C-h t' a prefix argument, like `C-u
C-h t'.

   To clear the screen and redisplay, type `C-l' (`recenter').

* Menu:


* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        How to move the cursor to the place where you want to
			  change something.
* Erasing::	        Deleting and killing text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* Blank Lines::	        Commands to make or delete blank lines.
* Continuation Lines::  Lines too wide for the screen.
* Position Info::       What page, line, row, or column is point on?
* Arguments::	        Numeric arguments for repeating a command.


File: xemacs.info,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

Inserting Text
==============

To insert printing characters into the text you are editing, just type
them.  This inserts the characters you type into the buffer at the
cursor (that is, at "point"; *note Point::).  The cursor moves forward,
and any text after the cursor moves forward too.  If the text in the
buffer is `FOOBAR', with the cursor before the `B', then if you type
`XX', you get `FOOXXBAR', with the cursor still before the `B'.

   To "delete" text you have just inserted, use <BS>.  <BS> deletes the
character _before_ the cursor (not the one that the cursor is on top of
or under; that is the character AFTER the cursor).  The cursor and all
characters after it move backwards.  Therefore, if you type a printing
character and then type <BS>, they cancel out.

   To end a line and start typing a new one, type <RET>.  This inserts
a newline character in the buffer.  If point is in the middle of a
line, <RET> splits the line.  Typing <DEL> when the cursor is at the
beginning of a line deletes the preceding newline, thus joining the
line with the preceding line.

   Emacs can split lines automatically when they become too long, if you
turn on a special minor mode called "Auto Fill" mode.  *Note Filling::,
for how to use Auto Fill mode.

   If you prefer to have text characters replace (overwrite) existing
text rather than shove it to the right, you can enable Overwrite mode,
a minor mode.  *Note Minor Modes::.

   Direct insertion works for printing characters and <SPC>, but other
characters act as editing commands and do not insert themselves.  If you
need to insert a control character or a character whose code is above
200 octal, you must "quote" it by typing the character `Control-q'
(`quoted-insert') first.  (This character's name is normally written
`C-q' for short.)  There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.

   * `C-q' followed by a sequence of octal digits inserts the character
     with the specified octal character code.  You can use any number of
     octal digits; any non-digit terminates the sequence.  If the
     terminating character is <RET>, it serves only to terminate the
     sequence; any other non-digit is itself used as input after
     terminating the sequence.  (The use of octal sequences is disabled
     in ordinary non-binary Overwrite mode, to give you a convenient
     way to insert a digit instead of overwriting with it.)

A numeric argument to `C-q' specifies how many copies of the quoted
character should be inserted (*note Arguments::).

   Customization information: <DEL>, in most modes, runs the command
`backward-or-forward-delete-char'; <RET> runs the command `newline',
and self-inserting printing characters run the command `self-insert',
which inserts whatever character was typed to invoke it.  Some major
modes rebind <DEL> to other commands.


File: xemacs.info,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

Changing the Location of Point
==============================

To do more than insert characters, you have to know how to move point
(*note Point::).  The simplest way to do this is with arrow keys, or by
clicking the left mouse button where you want to move to.

   NOTE: Many of the following commands have two versions, one that uses
the function keys (e.g. <LEFT> or <END>) and one that doesn't.  The
former versions may only be available on X terminals (i.e. not on
TTY's), but the latter are available on all terminals.

`C-a'
`HOME'
     Move to the beginning of the line (`beginning-of-line').

`C-e'
`END'
     Move to the end of the line (`end-of-line').

`C-f'
`RIGHT'
     Move forward one character (`forward-char').

`C-b'
`LEFT'
     Move backward one character (`backward-char').

`M-f'
`C-RIGHT'
     Move forward one word (`forward-word').

`M-b'
`C-LEFT'
     Move backward one word (`backward-word').

`C-n'
`DOWN'
     Move down one line, vertically (`next-line').  This command
     attempts to keep the horizontal position unchanged, so if you
     start in the middle of one line, you end in the middle of the
     next.  When on the last line of text, `C-n' creates a new line and
     moves onto it.

`C-p'
`UP'
     Move up one line, vertically (`previous-line').

`C-v'
`PGDN'
     Move down one page, vertically (`scroll-up').

`M-v'
`PGUP'
     Move up one page, vertically (`scroll-down').

`C-l'
     Clear the frame and reprint everything (`recenter').  Text moves
     on the frame to bring point to the center of the window.

`M-r'
     Move point to left margin, vertically centered in the window
     (`move-to-window-line').  Text does not move on the screen.

     A numeric argument says which screen line to place point on.  It
     counts screen lines down from the top of the window (zero for the
     top line).  A negative argument counts lines from the bottom (-1
     for the bottom line).

`C-t'
     Transpose two characters, the ones before and after the cursor
     (`transpose-chars').

`M-<'
`C-HOME'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M->'
`C-END'
     Move to the end of the buffer (`end-of-buffer').

`M-x goto-char'
     Read a number N and move point to buffer position N.  Position 1
     is the beginning of the buffer.

`M-g'
     Read a number N and move point to line number N (`goto-line').
     Line 1 is the beginning of the buffer.

`M-x set-goal-column'
     Use the current column of point as the "semi-permanent goal
     column" for `C-n' and `C-p' (`set-goal-column').  Henceforth, those
     commands always move to this column in each line moved into, or as
     close as possible given the contents of the line.  This goal
     column remains in effect until canceled.

`C-u M-x set-goal-column'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' once again
     try to avoid changing the horizontal position, as usual.

   If you set the variable `track-eol' to a non-`nil' value, then `C-n'
and `C-p' when at the end of the starting line move to the end of
another line.  Normally, `track-eol' is `nil'.  *Note Variables::, for
how to set variables such as `track-eol'.

   Normally, `C-n' on the last line of a buffer appends a newline to
it.  If the variable `next-line-add-newlines' is `nil', then `C-n' gets
an error instead (like `C-p' on the first line).


File: xemacs.info,  Node: Erasing,  Next: Basic Files,  Prev: Moving Point,  Up: Basic

Erasing Text
============

`<DEL>'
     Delete the character before or after point
     (`backward-or-forward-delete-char').  You can customize this
     behavior by setting the variable `delete-key-deletes-forward'.

`C-d'
     Delete the character after point (`delete-char').

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-<DEL>'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   You already know about the <DEL> key which deletes the character
before point (that is, before the cursor).  Another key, `Control-d'
(`C-d' for short), deletes the character after point (that is, the
character that the cursor is on).  This shifts the rest of the text on
the line to the left.  If you type `C-d' at the end of a line, it joins
together that line and the next line.

   To erase a larger amount of text, use the `C-k' key, which kills a
line at a time.  If you type `C-k' at the beginning or middle of a
line, it kills all the text up to the end of the line.  If you type
`C-k' at the end of a line, it joins that line and the next line.

   *Note Killing::, for more flexible ways of killing text.


File: xemacs.info,  Node: Basic Files,  Next: Basic Help,  Prev: Erasing,  Up: Basic

Files
=====

The commands described above are sufficient for creating and altering
text in an Emacs buffer; the more advanced Emacs commands just make
things easier.  But to keep any text permanently you must put it in a
"file".  Files are named units of text which are stored by the
operating system for you to retrieve later by name.  To look at or use
the contents of a file in any way, including editing the file with
Emacs, you must specify the file name.

   Consider a file named `/usr/rms/foo.c'.  To begin editing this file
from Emacs, type:

     C-x C-f /usr/rms/foo.c <RET>

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type <RET> to terminate the argument (*note
Minibuffer::).

   You can also use the Open... menu item from the File menu, then type
the name of the file to the prompt.

   Emacs obeys the command by "visiting" the file: creating a buffer,
copying the contents of the file into the buffer, and then displaying
the buffer for you to edit.  If you alter the text, you can "save" the
new text in the file by typing `C-x C-s' (`save-buffer') or choosing
Save Buffer from the File menu.  This makes the changes permanent by
copying the altered buffer contents back into the file
`/usr/rms/foo.c'.  Until you save, the changes exist only inside Emacs,
and the file `foo.c' is unaltered.

   To create a file, visit the file with `C-x C-f' as if it already
existed or choose Open... from the File menu and provide the name for
the new file.  Emacs will create an empty buffer in which you can
insert the text you want to put in the file.  When you save the buffer
with `C-x C-s', or by choosing Save Buffer from the File menu, the file
is created.

   To learn more about using files, *Note Files::.


File: xemacs.info,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

Help
====

If you forget what a key does, you can find out with the Help
character, which is `C-h' (or <F1>, which is an alias for `C-h').  Type
`C-h k' followed by the key you want to know about; for example, `C-h k
C-n' tells you all about what `C-n' does.  `C-h' is a prefix key; `C-h
k' is just one of its subcommands (the command `describe-key').  The
other subcommands of `C-h' provide different kinds of help.  Type `C-h'
twice to get a description of all the help facilities.  *Note Help::.


File: xemacs.info,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

Blank Lines
===========

Here are special commands and techniques for putting in and taking out
blank lines.

`C-o'
     Insert one or more blank lines after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   When you want to insert a new line of text before an existing line,
you can do it by typing the new line of text, followed by <RET>.
However, it may be easier to see what you are doing if you first make a
blank line and then insert the desired text into it.  This is easy to do
using the key `C-o' (`open-line'), which inserts a newline after point
but leaves point in front of the newline.  After `C-o', type the text
for the new line.  `C-o F O O' has the same effect as `F O O <RET>',
except for the final location of point.

   You can make several blank lines by typing `C-o' several times, or
by giving it a numeric argument to tell it how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, then `C-o'
command inserts the fill prefix on the new line, when you use it at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command
`C-x C-o' (`delete-blank-lines').  `C-x C-o' in a run of several blank
lines deletes all but one of them.  `C-x C-o' on a solitary blank line
deletes that blank line.  When point is on a nonblank line, `C-x C-o'
deletes any blank lines following that nonblank line.


File: xemacs.info,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

Continuation Lines
==================

If you add too many characters to one line without breaking it with
<RET>, the line will grow to occupy two (or more) lines on the screen,
with a curved arrow at the extreme right margin of all but the last of
them.  The curved arrow says that the following screen line is not
really a distinct line in the text, but just the "continuation" of a
line too long to fit the screen.  Continuation is also called "line
wrapping".

   Sometimes it is nice to have Emacs insert newlines automatically when
a line gets too long.  Continuation on the screen does not do that.  Use
Auto Fill mode (*note Filling::) if that's what you want.

   Instead of continuation, long lines can be displayed by "truncation".
This means that all the characters that do not fit in the width of the
frame or window do not appear at all.  They remain in the buffer,
temporarily invisible.  Right arrow in the last column (instead of the
curved arrow) inform you that truncation is in effect.

   Truncation instead of continuation happens whenever horizontal
scrolling is in use, and optionally in all side-by-side windows (*note
Windows::).  You can enable truncation for a particular buffer by
setting the variable `truncate-lines' to non-`nil' in that buffer.
(*Note Variables::.)  Altering the value of `truncate-lines' makes it
local to the current buffer; until that time, the default value is in
effect.  The default is initially `nil'.  *Note Locals::.

   *Note Display Vars::, for additional variables that affect how text
is displayed.


File: xemacs.info,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

Cursor Position Information
===========================

If you are accustomed to other display editors, you may be surprised
that Emacs does not always display the page number or line number of
point in the mode line.  In Emacs, this information is only rarely
needed, and a number of commands are available to compute and print it.
Since text is stored in a way that makes it difficult to compute the
information, it is not displayed all the time.

`M-x what-page'
     Print page number of point, and line number within page.

`M-x what-line'
     Print line number of point in the buffer.

`M-x line-number-mode'
     Toggle automatic display of current line number.

`M-='
     Print number of lines and characters in the current region
     (`count-lines-region').  *Note Mark::, for information about the
     region.

`C-x ='
     Print character code of character after point, character position
     of point, and column of point (`what-cursor-position').

   There are several commands for printing line numbers:

   * `M-x what-line' counts lines from the beginning of the file and
     prints the line number point is on.  The first line of the file is
     line number 1.  You can use these numbers as arguments to `M-x
     goto-line'.

   * `M-x what-page' counts pages from the beginning of the file, and
     counts lines within the page, printing both of them.  *Note
     Pages::, for the command `C-x l', which counts the lines in the
     current page.

   * `M-=' (`count-lines-region') prints the number of lines in the
     region (*note Mark::).  *Note Pages::, for the command `C-x l'
     which counts the lines in the

   The command `C-x =' (`what-cursor-position') can be used to find out
the column that the cursor is in, and other miscellaneous information
about point.  It prints a line in the echo area that looks like this:

     Char: c (0143, 99, 0x63)  point=18862 of 24800(76%)  column 53

(In fact, this is the output produced when point is before `column 53'
in the example.)

   The four values after `Char:' describe the character that follows
point, first by showing it and then by giving its character code in
octal, decimal and hex.

   `point=' is followed by the position of point expressed as a
character count.  The front of the buffer counts as position 1, one
character later as 2, and so on.  The next, larger number is the total
number of characters in the buffer.  Afterward in parentheses comes the
position expressed as a percentage of the total size.

   `column' is followed by the horizontal position of point, in columns
from the left edge of the window.

   If the buffer has been narrowed, making some of the text at the
beginning and the end temporarily invisible, `C-x =' prints additional
text describing the current visible range.  For example, it might say:

     Char: c (0143, 99, 0x63)  point=19674 of 24575(80%) <19591 - 19703>  column 69

where the two extra numbers give the smallest and largest character
position that point is allowed to assume.  The characters between those
two positions are the visible ones.  *Note Narrowing::.

   If point is at the end of the buffer (or the end of the visible
part), `C-x =' omits any description of the character after point.  The
output looks like

     point=563026 of 563025(100%)  column 0


File: xemacs.info,  Node: Arguments,  Prev: Position Info,  Up: Basic

Numeric Arguments
=================

In mathematics and computer usage, the word "argument" means "data
provided to a function or operation."  Any Emacs command can be given a
"numeric argument" (also called a "prefix argument").  Some commands
interpret the argument as a repetition count.  For example, giving an
argument of ten to the key `C-f' (the command `forward-char', move
forward one character) moves forward ten characters.  With these
commands, no argument is equivalent to an argument of one.  Negative
arguments are allowed.  Often they tell a command to move or act  in
the opposite direction.

   If your keyboard has a <META> key (labelled with a diamond on
Sun-type keyboards and labelled `Alt' on some other keyboards), the
easiest way to specify a numeric argument is to type digits and/or a
minus sign while holding down the <META> key.  For example,
     M-5 C-n

would move down five lines.  The characters `Meta-1', `Meta-2', and so
on, as well as `Meta--', do this because they are keys bound to
commands (`digit-argument' and `negative-argument') that are defined to
contribute to an argument for the next command.  Digits and `-'
modified with Control, or Control and Meta, also specify numeric
arguments.

   Another way of specifying an argument is to use the `C-u'
(`universal-argument') command followed by the digits of the argument.
With `C-u', you can type the argument digits without holding down
modifier keys; `C-u' works on all terminals.  To type a negative
argument, type a minus sign after `C-u'.  Just a minus sign without
digits normally means -1.

   `C-u' followed by a character which is neither a digit nor a minus
sign has the special meaning of "multiply by four".  It multiplies the
argument for the next command by four.  `C-u' twice multiplies it by
sixteen.  Thus, `C-u C-u C-f' moves forward sixteen characters.  This
is a good way to move forward "fast", since it moves about 1/5 of a line
in the usual size frame.  Other useful combinations are `C-u C-n', `C-u
C-u C-n' (move down a good fraction of a frame), `C-u C-u C-o' (make "a
lot" of blank lines), and `C-u C-k' (kill four lines).

   Some commands care only about whether there is an argument and not
about its value.  For example, the command `M-q' (`fill-paragraph') with
no argument fills text; with an argument, it justifies the text as well.
(*Note Filling::, for more information on `M-q'.)  Just `C-u' is a
handy way of providing an argument for such commands.

   Some commands use the value of the argument as a repeat count, but do
something peculiar when there is no argument.  For example, the command
`C-k' (`kill-line') with argument N kills N lines, including their
terminating newlines.  But `C-k' with no argument is special: it kills
the text up to the next newline, or, if point is right at the end of
the line, it kills the newline itself.  Thus, two `C-k' commands with
no arguments can kill a non-blank line, just like `C-k' with an
argument of one.  (*Note Killing::, for more information on `C-k'.)

   A few commands treat a plain `C-u' differently from an ordinary
argument.  A few others may treat an argument of just a minus sign
differently from an argument of -1.  These unusual cases are described
when they come up; they are always for reasons of convenience of use of
the individual command.

   You can use a numeric argument to insert multiple copies of a
character.  This is straightforward unless the character is a digit; for
example, `C-u 6 4 a' inserts 64 copies of the character `a'.  But this
does not work for inserting digits; `C-u 6 4 1' specifies an argument
of 641, rather than inserting anything.  To separate the digit to
insert from the argument, type another `C-u'; for example, `C-u 6 4 C-u
1' does insert 64 copies of the character `1'.

   We use the term "prefix argument" as well as "numeric argument" to
emphasize that you type the argument before the command, and to
distinguish these arguments from minibuffer arguments that come after
the command.


File: xemacs.info,  Node: Undo,  Next: Minibuffer,  Prev: Basic,  Up: Top

Undoing Changes
***************

Emacs allows you to undo all changes you make to the text of a buffer,
up to a certain amount of change (8000 characters).  Each buffer records
changes individually, and the undo command always applies to the
current buffer.  Usually each editing command makes a separate entry in
the undo records, but some commands such as `query-replace' make many
entries, and very simple commands such as self-inserting characters are
often grouped to make undoing less tedious.

`C-x u'
     Undo one batch of changes (usually, one command's worth) (`undo').

`C-_'
     The same.

   The command `C-x u' or `C-_' allows you to undo changes.  The first
time you give this command, it undoes the last change.  Point moves to
the text affected by the undo, so you can see what was undone.

   Consecutive repetitions of the `C-_' or `C-x u' commands undo
earlier and earlier changes, back to the limit of what has been
recorded.  If all recorded changes have already been undone, the undo
command prints an error message and does nothing.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting at this moment, the previous undo commands are
considered ordinary changes that can themselves be undone.  Thus, you
can redo changes you have undone by typing `C-f' or any other command
that have no important effect, and then using more undo commands.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  When that happens, all the
modifications you made have been canceled.  If you do not remember
whether you changed the buffer deliberately, type `C-_' once. When you
see Emacs undo the last change you made, you probably remember why you
made it.  If the change was an accident, leave it undone.  If it was
deliberate, redo the change as described in the preceding paragraph.

   Whenever an undo command makes the stars disappear from the mode
line, the buffer contents is the same as it was when the file was last
read in or saved.

   Not all buffers record undo information.  Buffers whose names start
with spaces don't; these buffers are used internally by Emacs and its
extensions to hold text that users don't normally look at or edit.
Minibuffers, help buffers, and documentation buffers also don't record
undo information.

   Emacs can remember at most 8000 or so characters of deleted or
modified text in any one buffer for reinsertion by the undo command.
There is also a limit on the number of individual insert, delete, or
change actions that Emacs can remember.

   There are two keys to run the `undo' command, `C-x u' and `C-_',
because on some keyboards, it is not obvious how to type `C-_'. `C-x u'
is an alternative you can type in the same fashion on any terminal.


File: xemacs.info,  Node: Minibuffer,  Next: M-x,  Prev: Undo,  Up: Top

The Minibuffer
**************

The "minibuffer" is the facility used by XEmacs commands to read
arguments more complicated than a single number.  Minibuffer arguments
can be file names, buffer names, Lisp function names, XEmacs command
names, Lisp expressions, and many other things, depending on the command
reading the argument.  You can use the usual XEmacs editing commands in
the minibuffer to edit the argument text.

   When the minibuffer is in use, it appears in the echo area, and the
cursor moves there.  The beginning of the minibuffer line displays a
"prompt" which says what kind of input you should supply and how it
will be used.  Often this prompt is derived from the name of the command
that the argument is for.  The prompt normally ends with a colon.

   Sometimes a "default argument" appears in parentheses after the
colon; it, too, is part of the prompt.  The default is used as the
argument value if you enter an empty argument (e.g., by just typing
<RET>).  For example, commands that read buffer names always show a
default, which is the name of the buffer that will be used if you type
just <RET>.

   The simplest way to enter a minibuffer argument is to type the text
you want, terminated by <RET> which exits the minibuffer.  You can
cancel the command that wants the argument, and get out of the
minibuffer, by typing `C-g'.

   Since the minibuffer uses the screen space of the echo area, it can
conflict with other ways XEmacs customarily uses the echo area.  Here is
how XEmacs handles such conflicts:

   * If a command gets an error while you are in the minibuffer, this
     does not cancel the minibuffer.  However, the echo area is needed
     for the error message and therefore the minibuffer itself is
     hidden for a while.  It comes back after a few seconds, or as soon
     as you type anything.

   * If in the minibuffer you use a command whose purpose is to print a
     message in the echo area, such as `C-x =', the message is printed
     normally, and the minibuffer is hidden for a while.  It comes back
     after a few seconds, or as soon as you type anything.

   * Echoing of keystrokes does not take place while the minibuffer is
     in use.

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::		  Re-executing commands that used the minibuffer.


File: xemacs.info,  Node: Minibuffer File,  Next: Minibuffer Edit,  Prev: Minibuffer,  Up: Minibuffer

Minibuffers for File Names
==========================

Sometimes the minibuffer starts out with text in it.  For example, when
you are supposed to give a file name, the minibuffer starts out
containing the "default directory", which ends with a slash.  This is
to inform you which directory the file will be found in if you do not
specify a directory.

   For example, the minibuffer might start out with these contents:

     Find File: /u2/emacs/src/

where `Find File: ' is the prompt.  Typing `buffer.c' specifies the
file `/u2/emacs/src/buffer.c'.  To find files in nearby directories,
use `..'; thus, if you type `../lisp/simple.el', you will get the file
named `/u2/emacs/lisp/simple.el'.  Alternatively, you can kill with
`M-<DEL>' the directory names you don't want (*note Words::).

   If you don't want any of the default, you can kill it with `C-a
C-k'.  But you don't need to kill the default; you can simply ignore it.
Insert an absolute file name, one starting with a slash or a tilde,
after the default directory.  For example, to specify the file
`/etc/termcap', just insert that name, giving these minibuffer contents:

     Find File: /u2/emacs/src//etc/termcap

XEmacs gives a special meaning to a double slash (which is not normally
a useful thing to write): it means, "ignore everything before the
second slash in the pair."  Thus, `/u2/emacs/src/' is ignored in the
example above, and you get the file `/etc/termcap'.

   If you set `insert-default-directory' to `nil', the default
directory is not inserted in the minibuffer.  This way, the minibuffer
starts out empty.  But the name you type, if relative, is still
interpreted with respect to the same default directory.


File: xemacs.info,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

Editing in the Minibuffer
=========================

The minibuffer is an XEmacs buffer (albeit a peculiar one), and the
usual XEmacs commands are available for editing the text of an argument
you are entering.

   Since <RET> in the minibuffer is defined to exit the minibuffer, you
can't use it to insert a newline in the minibuffer.  To do that, type
`C-o' or `C-q C-j'.  (Recall that a newline is really the character
control-J.)

   The minibuffer has its own window which always has space on the
screen but acts as if it were not there when the minibuffer is not in
use.  When the minibuffer is in use, its window is just like the
others; you can switch to another window with `C-x o', edit text in
other windows and perhaps even visit more files, before returning to the
minibuffer to submit the argument.  You can kill text in another window,
return to the minibuffer window, and then yank the text to use it in the
argument.  *Note Windows::.

   There are some restrictions on the use of the minibuffer window,
however.  You cannot switch buffers in it--the minibuffer and its
window are permanently attached.  Also, you cannot split or kill the
minibuffer window. But you can make it taller in the normal fashion with
`C-x ^'.  If you enable Resize-Minibuffer mode, then the minibuffer
window expands vertically as necessary to hold the text that you put in
the minibuffer.  Use `M-x resize-minibuffer-mode' to enable or disable
this minor mode (*note Minor Modes::).

   If while in the minibuffer you issue a command that displays help
text of any sort in another window, you can use the `C-M-v' command
while in the minibuffer to scroll the help text.  This lasts until you
exit the minibuffer.  This feature is especially useful if a completing
minibuffer gives you a list of possible completions.  *Note Other
Window::.

   If the variable `minibuffer-confirm-incomplete' is `t', you are
asked for confirmation if there is no known completion for the text you
typed. For example, if you attempted to visit a non-existent file, the
minibuffer might read:
             Find File: chocolate_bar.c [no completions, confirm]
   If you press `Return' again, that confirms the filename. Otherwise,
you can continue editing it.

   XEmacs supports recursive use of the minibuffer.  However, it is easy
to do this by accident (because of autorepeating keyboards, for example)
and get confused.  Therefore, most XEmacs commands that use the
minibuffer refuse to operate if the minibuffer window is selected.  If
the minibuffer is active but you have switched to a different window,
recursive use of the minibuffer is allowed--if you know enough to try
to do this, you probably will not get confused.

   If you set the variable `enable-recursive-minibuffers' to a
non-`nil', recursive use of the minibuffer is always allowed.


File: xemacs.info,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

Completion
==========

For certain kinds of arguments, you can use "completion" to enter the
argument value.  Completion means that you type part of the argument,
then XEmacs visibly fills in the rest, or as much as can be determined
from the part you have typed.

   When completion is available, certain keys--<TAB>, <RET>, and
<SPC>--are rebound to complete the text present in the minibuffer into
a longer string that it stands for, by matching it against a set of
"completion alternatives" provided by the command reading the argument.
`?' is defined to display a list of possible completions of what you
have inserted.

   For example, when `M-x' uses the minibuffer to read the name of a
command, it provides a list of all available XEmacs command names to
complete against.  The completion keys match the text in the minibuffer
against all the command names, find any additional name characters
implied by the ones already present in the minibuffer, and add those
characters to the ones you have given.  This is what makes it possible
to type `M-x inse <SPC> b <RET>' instead of `M-x insert-buffer <RET>'
(for example).

   Case is normally significant in completion because it is significant
in most of the names that you can complete (buffer names, file names and
command names).  Thus, `fo' does not complete to `Foo'.  When you are
completing a name in which case does not matter, case may be ignored
for completion's sake if specified by program.

   When a completion list is displayed, the completions will highlight
as you move the mouse over them.  Clicking the middle mouse button on
any highlighted completion will "select" it just as if you had typed it
in and hit <RET>.

* Menu:

* Example: Completion Example.
* Commands: Completion Commands.
* Strict Completion::
* Options: Completion Options.


File: xemacs.info,  Node: Completion Example,  Next: Completion Commands,  Prev: Completion,  Up: Completion

Completion Example
------------------

A concrete example may help here.  If you type `M-x au <TAB>', the
<TAB> looks for alternatives (in this case, command names) that start
with `au'.  There are several, including `auto-fill-mode' and
`auto-save-mode'--but they are all the same as far as `auto', so the
`au' in the minibuffer changes to `auto'.

   If you type <TAB> again immediately, there are multiple
possibilities for the very next character--it could be any of `c-'--so
no more characters are added; instead, <TAB> displays a list of all
possible completions in another window.

   If you go on to type `-f <TAB>', this <TAB> sees `auto-f'.  The only
command name starting this way is `auto-fill-mode', so completion fills
in the rest of that.  You now have `auto-fill-mode' in the minibuffer
after typing just `au <TAB> f <TAB>'.  Note that <TAB> has this effect
because in the minibuffer it is bound to the command
`minibuffer-complete' when completion is available.


File: xemacs.info,  Node: Completion Commands,  Next: Strict Completion,  Prev: Completion Example,  Up: Completion

Completion Commands
-------------------

Here is a list of the completion commands defined in the minibuffer
when completion is available.

`<TAB>'
     Complete the text in the minibuffer as much as possible
     (`minibuffer-complete').

`<SPC>'
     Complete the minibuffer text, but don't go beyond one word
     (`minibuffer-complete-word').

`<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described below
     (`minibuffer-complete-and-exit').

`?'
     Print a list of all possible completions of the text in the
     minibuffer (`minibuffer-list-completions').

`<button2>'
     Select the highlighted text under the mouse as a minibuffer
     response.  When the minibuffer is being used to prompt the user
     for a completion, any valid completions which are visible on the
     screen will be highlighted when the mouse moves over them.
     Clicking <button2> will select the highlighted completion and exit
     the minibuffer.  (`minibuf-select-highlighted-completion').

   <SPC> completes much like <TAB>, but never goes beyond the next
hyphen or space.  If you have `auto-f' in the minibuffer and type
<SPC>, it finds that the completion is `auto-fill-mode', but it stops
completing after `fill-'.  This gives `auto-fill-'.  Another <SPC> at
this point completes all the way to `auto-fill-mode'.  <SPC> in the
minibuffer when completion is available runs the command
`minibuffer-complete-word'.

   Here are some commands you can use to choose a completion from a
window that displays a list of completions:

`button2up'
     Clicking mouse button 2 on a completion in the list of possible
     completions chooses that completion (`mouse-choose-completion').
     You normally use this command while point is in the minibuffer;
     but you must click in the list of completions, not in the
     minibuffer itself.

`<PRIOR>'
`M-v'
     Typing <PRIOR> or `M-v', while in the minibuffer, selects the
     window showing the completion list buffer
     (`switch-to-completions').  This paves the way for using the
     commands below.  (Selecting that window in the usual ways has the
     same effect, but this way is more convenient.)

`<RET>'
     Typing <RET> _in the completion list buffer_ chooses the
     completion that point is in or next to (`choose-completion').  To
     use this command, you must first switch windows to the window that
     shows the list of completions.

`<RIGHT>'
`<TAB>'
`C-f'
     Typing the right-arrow key <RIGHT>, <TAB> or `C-f' _in the
     completion list buffer_ moves point to the following completion
     (`next-list-mode-item').

`<LEFT>'
`C-b'
     Typing the left-arrow key <LEFT> or `C-b' _in the completion list
     buffer_ moves point toward the beginning of the buffer, to the
     previous completion (`previous-list-mode-item').


File: xemacs.info,  Node: Strict Completion,  Next: Completion Options,  Prev: Completion Commands,  Up: Completion

Strict Completion
-----------------

There are three different ways that <RET> can work in completing
minibuffers, depending on how the argument will be used.

   * "Strict" completion is used when it is meaningless to give any
     argument except one of the known alternatives.  For example, when
     `C-x k' reads the name of a buffer to kill, it is meaningless to
     give anything but the name of an existing buffer.  In strict
     completion, <RET> refuses to exit if the text in the minibuffer
     does not complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     <RET> exits only if the text was an exact match already, not
     needing completion.  If the text is not an exact match, <RET> does
     not exit, but it does complete the text.  If it completes to an
     exact match, a second <RET> will exit.

     Cautious completion is used for reading file names for files that
     must already exist.

   * "Permissive" completion is used when any string whatever is
     meaningful, and the list of completion alternatives is just a
     guide.  For example, when `C-x C-f' reads the name of a file to
     visit, any file name is allowed, in case you want to create a
     file.  In permissive completion, <RET> takes the text in the
     minibuffer exactly as given, without completing it.

   The completion commands display a list of all possible completions in
a window whenever there is more than one possibility for the very next
character.  Also, typing `?' explicitly requests such a list.  If the
list of completions is long, you can scroll it with `C-M-v' (*note
Other Window::).


File: xemacs.info,  Node: Completion Options,  Prev: Strict Completion,  Up: Completion

Completion Options
------------------

When completion is done on file names, certain file names are usually
ignored.  The variable `completion-ignored-extensions' contains a list
of strings; a file whose name ends in any of those strings is ignored
as a possible completion.  The standard value of this variable has
several elements including `".o"', `".elc"', `".dvi"' and `"~"'.  The
effect is that, for example, `foo' can complete to `foo.c' even though
`foo.o' exists as well.  However, if _all_ the possible completions end
in "ignored" strings, then they are not ignored.  Ignored extensions do
not apply to lists of completions--those always mention all possible
completions.

   If a completion command finds the next character is undetermined, it
automatically displays a list of all possible completions.  If the
variable `completion-auto-help' is set to `nil', this does not happen,
and you must type `?' to display the possible completions.

   If the variable `minibuffer-confirm-incomplete' is set to `t', then
in contexts where `completing-read' allows answers that are not valid
completions, an extra <RET> must be typed to confirm the response.
This is helpful for catching typos.

   Icomplete mode presents a constantly-updated display that tells you
what completions are available for the text you've entered so far.  The
command to enable or disable this minor mode is `M-x icomplete-mode'.


File: xemacs.info,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

Minibuffer History
==================

Every argument that you enter with the minibuffer is saved on a
"minibuffer history list" so that you can use it again later in another
argument.  Special commands load the text of an earlier argument in the
minibuffer.  They discard the old minibuffer contents, so you can think
of them as moving through the history of previous arguments.

`<UP>'
`M-p'
     Move to the next earlier argument string saved in the minibuffer
     history (`previous-history-element').

`<DOWN>'
`M-n'
     Move to the next later argument string saved in the minibuffer
     history (`next-history-element').

`M-r REGEXP <RET>'
     Move to an earlier saved argument in the minibuffer history that
     has a match for REGEXP (`previous-matching-history-element').

`M-s REGEXP <RET>'
     Move to a later saved argument in the minibuffer history that has a
     match for REGEXP (`next-matching-history-element').

   The simplest way to reuse the saved arguments in the history list is
to move through the history list one element at a time.  While in the
minibuffer, use `M-p' or up-arrow (`previous-history-element') to "move
to" the next earlier minibuffer input, and use `M-n' or down-arrow
(`next-history-element') to "move to" the next later input.

   The previous input that you fetch from the history entirely replaces
the contents of the minibuffer.  To use it as the argument, exit the
minibuffer as usual with <RET>.  You can also edit the text before you
reuse it; this does not change the history element that you "moved" to,
but your new argument does go at the end of the history list in its own
right.

   For many minibuffer arguments there is a "default" value.  In some
cases, the minibuffer history commands know the default value.  Then you
can insert the default value into the minibuffer as text by using `M-n'
to move "into the future" in the history.

   There are also commands to search forward or backward through the
history; they search for history elements that match a regular
expression that you specify with the minibuffer.  `M-r'
(`previous-matching-history-element') searches older elements in the
history, while `M-s' (`next-matching-history-element') searches newer
elements.  By special dispensation, these commands can use the
minibuffer to read their arguments even though you are already in the
minibuffer when you issue them.  As with incremental searching, an
uppercase letter in the regular expression makes the search
case-sensitive (*note Search Case::).

   All uses of the minibuffer record your input on a history list, but
there are separate history lists for different kinds of arguments.  For
example, there is a list for file names, used by all the commands that
read file names.

   There are several other very specific history lists, including one
for command names read by `M-x', one for buffer names, one for arguments
of commands like `query-replace', and one for compilation commands read
by `compile'.  Finally, there is one "miscellaneous" history list that
most minibuffer arguments use.


File: xemacs.info,  Node: Repetition,  Prev: Minibuffer History,  Up: Minibuffer

Repeating Minibuffer Commands
=============================

Every command that uses the minibuffer at least once is recorded on a
special history list, together with the values of its arguments, so that
you can repeat the entire command.  In particular, every use of `M-x'
is recorded there, since `M-x' uses the minibuffer to read the command
name.

`C-x <ESC> <ESC>'
     Re-execute a recent minibuffer command (`repeat-complex-command').

`M-p'
     Within `C-x <ESC> <ESC>', move to previous recorded command
     (`previous-history-element').

`M-n'
     Within `C-x <ESC> <ESC>', move to the next (more recent) recorded
     command (`next-history-element').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     <ESC> <ESC>' can repeat, most recent first.

   `C-x <ESC> <ESC>' is used to re-execute a recent minibuffer-using
command.  With no argument, it repeats the last such command.  A
numeric argument specifies which command to repeat; one means the last
one, and larger numbers specify earlier ones.

   `C-x <ESC> <ESC>' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  If you type just <RET>, the command is repeated as
before.  You can also change the command by editing the Lisp
expression.  Whatever expression you finally submit is what will be
executed.  The repeated command is added to the front of the command
history unless it is identical to the most recently executed command
already there.

   Even if you don't understand Lisp syntax, it will probably be obvious
which command is displayed for repetition.  If you do not change the
text, you can be sure the command will repeat exactly as before.

   If you are in the minibuffer for `C-x <ESC> <ESC>' and the command
shown to you is not the one you want to repeat, you can move around the
list of previous commands using `M-n' and `M-p'.  `M-p' replaces the
contents of the minibuffer with the next earlier recorded command, and
`M-n' replaces it with the next later command.  After finding the
desired previous command, you can edit its expression and then resubmit
it by typing <RET>.  Any editing you have done on the command to be
repeated is lost if you use `M-n' or `M-p'.

   `M-n' and `M-p' are specially defined within `C-x <ESC> <ESC>' to
run the commands `previous-history-element' and `next-history-element'.

   The list of previous commands using the minibuffer is stored as a
Lisp list in the variable `command-history'.  Each element of the list
is a Lisp expression which describes one command and its arguments.
Lisp programs can reexecute a command by feeding the corresponding
`command-history' element to `eval'.


File: xemacs.info,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

Running Commands by Name
************************

The Emacs commands that are used often or that must be quick to type are
bound to keys--short sequences of characters--for convenient use.  Other
Emacs commands that are used more rarely are not bound to keys; to run
them, you must refer to them by name.

   A command name consists, by convention, of one or more words,
separated by hyphens: for example, `auto-fill-mode' or `manual-entry'.
The use of English words makes the command name easier to remember than
a key made up of obscure characters, even though it results in more
characters to type.  You can run any command by name, even if it can be
run by keys as well.

   To run a command by name, start with `M-x', then type the command
name, and finish with <RET>.  `M-x' uses the minibuffer to read the
command name.  <RET> exits the minibuffer and runs the command.

   Emacs uses the minibuffer for reading input for many different
purposes; on this occasion, the string `M-x' is displayed at the
beginning of the minibuffer as a "prompt" to remind you that your input
should be the name of a command to be run.  *Note Minibuffer::, for
full information on the features of the minibuffer.

   You can use completion to enter a command name.  For example, to
invoke the command `forward-char', type:

     M-x forward-char <RET>
   or
     M-x fo <TAB> c <RET>

After you type in `M-x fo TAB' emacs will give you a possible list of
completions from which you can choose. Note that `forward-char' is the
same command that you invoke with the key `C-f'.  You can call any
command (interactively callable function) defined in Emacs by its name
using `M-x' regardless of whether or not any keys are bound to it.

   If you type `C-g' while Emacs reads the command name, you cancel the
`M-x' command and get out of the minibuffer, ending up at top level.

   To pass a numeric argument to a command you are invoking with `M-x',
specify the numeric argument before the `M-x'.  `M-x' passes the
argument along to the function that it calls.  The argument value
appears in the prompt while the command name is being read.

   You can use the command `M-x interactive' to specify a way of
parsing arguments for interactive use of a function.  For example,
write:

       (defun foo (arg) "Doc string" (interactive "p") ...use arg...)

   to make `arg' be the prefix argument when `foo' is called as a
command.  The call to `interactive' is actually a declaration rather
than a function; it tells `call-interactively' how to read arguments to
pass to the function.  When actually called, `interactive' returns
`nil'.

   The argument of INTERACTIVE is usually a string containing a code
letter followed by a prompt.  Some code letters do not use I/O to get
the argument and do not need prompts.  To prompt for multiple arguments,
you must provide a code letter, its prompt, a newline, and another code
letter, and so forth.  If the argument is not a string, it is evaluated
to get a list of arguments to pass to the function.  If you do not
provide an argument to `interactive', no arguments are passed when
calling interactively.

   Available code letters are:

`a'
     Function name: symbol with a function definition

`b'
     Name of existing buffer

`B'
     Name of buffer, possibly nonexistent

`c'
     Character

`C'
     Command name: symbol with interactive function definition

`d'
     Value of point as number (does not do I/O)

`D'
     Directory name

`e'
     Last mouse event

`f'
     Existing file name

`F'
     Possibly nonexistent file name

`k'
     Key sequence (string)

`m'
     Value of mark as number (does not do I/O)

`n'
     Number read using minibuffer

`N'
     Prefix arg converted to number, or if none, do like code `n'

`p'
     Prefix arg converted to number (does not do I/O)

`P'
     Prefix arg in raw form (does not do I/O)

`r'
     Region: point and mark as two numeric arguments, smallest first
     (does not do I/O)

`s'
     Any string

`S'
     Any symbol

`v'
     Variable name: symbol that is `user-variable-p'

`x'
     Lisp expression read but not evaluated

`X'
     Lisp expression read and evaluated

   In addition, if the string begins with `*', an error is signaled if
the buffer is read-only.  This happens before reading any arguments.
If the string begins with `@', the window the mouse is over is selected
before anything else is done.  You may use both `@' and `*'; they are
processed in the order that they appear.

   Normally, when describing a command that is run by name, we omit the
<RET> that is needed to terminate the name.  Thus we may refer to `M-x
auto-fill-mode' rather than `M-x auto-fill-mode' <RET>.  We mention the
<RET> only when it is necessary to emphasize its presence, for example,
when describing a sequence of input that contains a command name and
arguments that follow it.

   `M-x' is defined to run the command `execute-extended-command',
which is responsible for reading the name of another command and
invoking it.


File: xemacs.info,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

Help
****

XEmacs provides extensive help features accessible through a single
character, `C-h'.  `C-h' is a prefix key that is used only for
documentation-printing commands.  The characters that you can type after
`C-h' are called "help options".  One help option is `C-h'; that is how
you ask for help about using `C-h'.  To cancel, type `C-g'.  The
function key <F1> is equivalent to `C-h'.

   `C-h C-h' (`help-for-help') displays a list of the possible help
options, and then asks you to type the desired option.  It prompts with
the string:

     A B C F I K L M N P S T V W C-c C-d C-f C-i C-k C-n C-w;  ? for more help:

You should type one of those characters.

   Typing a third `C-h' displays a description of what the options mean;
Emacs still waits for you to type an option.  To cancel, type `C-g'.

   Most help buffers use a special major mode, Help mode, which lets you
scroll conveniently with <SPC> and <DEL> or <BS>.

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in XEmacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Help Mode::           Special features of Help mode and Help buffers.
* Misc Help::		Other help commands.


File: xemacs.info,  Node: Help Summary,  Next: Key Help,  Prev: Help,  Up: Help

Help Summary
============

   Here is a summary of the defined help commands.

`C-h a REGEXP <RET>'
     Display a list of functions and variables whose names match REGEXP
     (`hyper-apropos').

`C-h A REGEXP'
     Show all commands whose names contain matches for REGEXP
     (`command-apropos').

`C-h b'
     Display a table of all key bindings currently in effect, with local
     bindings of the current major mode first, followed by all global
     bindings (`describe-bindings').

`C-h c KEY'
     Print the name of the command that KEY runs
     (`describe-key-briefly').  Here `c' stands for `character'.  For
     more extensive information on KEY, use `C-h k'.

`C-h d FUNCTION <RET>'
`C-h f FUNCTION <RET>'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Since commands are Lisp functions, a
     command name may be used.

`C-h i'
     Run Info, the program for browsing documentation files (`info').
     The complete XEmacs manual is available online in Info.

`C-h k KEY'
     Display the name and documentation of the command that KEY runs
     (`describe-key').

`C-h l'
     Display a description of the last 100 characters you typed
     (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h n'
`C-h C-n'
     Display documentation of XEmacs changes, most recent first
     (`view-emacs-news').

`C-h p'
     Find packages by topic keyword (`finder-by-keyword').

`C-h C-p'
     Display a table of all mouse bindings currently in effect now, with
     local bindings of the current major mode first, followed by all
     global bindings (`describe-pointer').

`C-h s'
     Display current contents of the syntax table, plus an explanation
     of what they mean (`describe-syntax').  *Note Syntax::.

`C-h t'
     Enter the XEmacs interactive tutorial (`help-with-tutorial').

`C-h v VAR <RET>'
     Display the documentation of the Lisp variable VAR
     (`describe-variable').

`C-h w COMMAND <RET>'
     Print which keys run the command named COMMAND (`where-is').

`C-h B <RET>'
     Display info on how to deal with Beta versions of XEmacs
     (`describe-beta').

`C-h C GROUP <RET>'
     Select customization buffer for GROUP (`customize').

`C-h F <RET>'
     View the local copy of the XEmacs FAQ (`xemacs-local-faq').

`C-h C-i FILE <RET>'
     Read Info file FILE with Info browser (`Info-query').

`C-h C-c COMMAND <RET>'
     Look up an Emacs command COMMAND in the Emacs manual in the Info
     system (`Info-goto-emacs-command-node').

`C-h C-f FUNCTION <RET>'
     Look up an Emacs Lisp function FUNCTION in the Elisp manual in the
     Info system (`Info-elisp-ref').


File: xemacs.info,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

Documentation for a Key
=======================

The most basic `C-h' options are `C-h c' (`describe-key-briefly') and
`C-h k' (`describe-key').  `C-h c KEY' prints in the echo area the name
of the command that KEY is bound to.  For example, `C-h c C-f' prints
`forward-char'.  Since command names are chosen to describe what the
commands do, this is a good way to get a very brief description of what
KEY does.

   `C-h k KEY' is similar to `C-h c' but gives more information.  It
displays the documentation string of the function KEY is bound to as
well as its name.  KEY is a string or vector of events.  When called
interactively, KEY may also be a menu selection.  This information does
not usually fit into the echo area, so a window is used for the display.

   `C-h c' and `C-h k' work for any sort of key sequences, including
function keys and mouse events.


File: xemacs.info,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

Help by Command or Variable Name
================================

`C-h f' (`describe-function') reads the name of a Lisp function using
the minibuffer, then displays that function's documentation string in a
window.  Since commands are Lisp functions, you can use the argument
FUNCTION to get the documentation of a command that you know by name.
For example,

     C-h f auto-fill-mode <RET>

displays the documentation for `auto-fill-mode'. Using `C-h f' is the
only way to see the documentation of a command that is not bound to any
key, that is, a command you would normally call using `M-x'.  If the
variable `describe-function-show-arglist' is `t', `describe-function'
shows its arglist if the FUNCTION is not an autoload function.

   `C-h f' is also useful for Lisp functions that you are planning to
use in a Lisp program.  For example, if you have just written the
expression `(make-vector len)' and want to make sure you are using
`make-vector' properly, type `C-h f make-vector <RET>'.  Because `C-h
f' allows all function names, not just command names, you may find that
some of your favorite abbreviations that work in `M-x' don't work in
`C-h f'.  An abbreviation may be unique among command names, yet fail
to be unique when other function names are allowed.

   The function name for `C-h f' to describe has a default which is
used if you type <RET> leaving the minibuffer empty.  The default is
the function called by the innermost Lisp expression in the buffer
around point, _provided_ that is a valid, defined Lisp function name.
For example, if point is located following the text `(make-vector (car
x)', the innermost list containing point is the one that starts with
`(make-vector', so the default is to describe the function
`make-vector'.

   `C-h f' is often useful just to verify that you have the right
spelling for the function name.  If `C-h f' mentions a name from the
buffer as the default, that name must be defined as a Lisp function.  If
that is all you want to know, just type `C-g' to cancel the `C-h f'
command, then go on editing.

   `C-h w COMMAND <RET>' (`where-is') tells you what keys are bound to
COMMAND.  It prints a list of the keys in the echo area. Alternatively,
it informs you that a command is not bound to any keys, which implies
that you must use `M-x' to call the command.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a known Lisp variable.
*Note Variables::.


File: xemacs.info,  Node: Apropos,  Next: Library Keywords,  Prev: Name Help,  Up: Help

Apropos
=======

`C-h A'
     Show only symbols that are names of commands (`command-apropos').

`M-x apropos REGEXP'
     Show all symbols whose names contain matches for REGEXP.

   A more sophisticated sort of question to ask is, "What are the
commands for working with files?"  To ask this question, type `C-h a
file <RET>', which displays a list of all command names that contain
`file', including `copy-file', `find-file', and so on.  With each
command name appears a brief description of how to use the command, and
what keys you can currently invoke it with.  For example, it would say
that you can invoke `find-file' by typing `C-x C-f'.  The `A' in `C-h
A' stands for `Apropos'; `C-h A' runs the command `command-apropos'.
This command normally checks only commands (interactive functions); if
you specify a prefix argument, it checks noninteractive functions as
well.

   Because `C-h A' looks only for functions whose names contain the
string you specify, you must use ingenuity in choosing the string.  If
you are looking for commands for killing backwards and `C-h a
kill-backwards <RET>' doesn't reveal any, don't give up.  Try just
`kill', or just `backwards', or just `back'.  Be persistent.  Pretend
you are playing Adventure.  Also note that you can use a regular
expression as the argument, for more flexibility (*note Regexps::).

   Here is a set of arguments to give to `C-h a' that covers many
classes of XEmacs commands, since there are strong conventions for
naming the standard XEmacs commands.  By giving you a feel for the
naming conventions, this set should also serve to aid you in developing
a technique for picking `apropos' strings.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe, default.

   To list all Lisp symbols that contain a match for a regexp, not just
the ones that are defined as commands, use the command `M-x apropos'
instead of `C-h A'.  This command does not check key bindings by
default; specify a numeric argument if you want it to check them.

   The `apropos-documentation' command is like `apropos' except that it
searches documentation strings for matches for the specified regular
expression.

   The `apropos-value' command is like `apropos' except that it
searches symbols' values for matches for the specified regular
expression.  This command does not check function definitions or
property lists by default; specify a numeric argument if you want it to
check them.

   If the variable `apropos-do-all' is non-`nil', the commands above
all behave as if they had been given a prefix argument.

   If you want more information about a function definition, variable or
symbol property listed in the Apropos buffer, you can click on it with
`Mouse-2' or move there and type <RET>.


File: xemacs.info,  Node: Library Keywords,  Next: Help Mode,  Prev: Apropos,  Up: Help

Keyword Search for Lisp Libraries
=================================

The `C-h p' command lets you search the standard Emacs Lisp libraries
by topic keywords.  Here is a partial list of keywords you can use:

     abbrev        abbreviation handling, typing shortcuts, macros
     bib           code related to the `bib' bibliography processor
     c             C, C++, and Objective-C language support
     calendar      calendar and time management support
     comm          communications, networking, remote access to files
     data          support for editing files of data
     docs          support for Emacs documentation
     dumped        files preloaded into Emacs
     emulations    emulations of other editors
     extensions    Emacs Lisp language extensions
     faces         support for multiple fonts
     frames        support for Emacs frames and window systems
     games         games, jokes and amusements
     hardware      support for interfacing with exotic hardware
     help          support for on-line help systems
     hypermedia    support for links between text or other media types
     i18n          internationalization and alternate character-set support
     internal      code for Emacs internals, build process, defaults
     languages     specialized modes for editing programming languages
     lisp          Lisp support, including Emacs Lisp
     local         code local to your site
     maint         maintenance aids for the Emacs development group
     mail          modes for electronic-mail handling
     matching      various sorts of searching and matching
     mouse         mouse support
     mule          multi-language extensions
     news          support for netnews reading and posting
     oop           support for object-oriented programming
     outlines      support for hierarchical outlining
     processes     process, subshell, compilation, and job control support
     terminals     support for terminal types
     tex           code related to the TeX formatter
     tools         programming tools
     unix          front-ends/assistants for, or emulators of, UNIX features
     vms           support code for vms
     wp            word processing


File: xemacs.info,  Node: Help Mode,  Next: Misc Help,  Prev: Library Keywords,  Up: Help

Help Mode Commands
==================

Help buffers provide the commands of View mode (*note Misc File Ops::),
plus a few special commands of their own.

`<SPC>'
     Scroll forward.

`<DEL>'
`<BS>'
     Scroll backward.

   When a command name (*note Running Commands by Name: M-x.) or
variable name (*note Variables::) appears in the documentation, it
normally appears inside paired single-quotes.


File: xemacs.info,  Node: Misc Help,  Prev: Help Mode,  Up: Help

Other Help Commands
===================

`C-h i' (`info') runs the Info program, which is used for browsing
through structured documentation files.  The entire XEmacs manual is
available within Info.  Eventually all the documentation of the GNU
system will be available.  Type `h' after entering Info to run a
tutorial on using Info.

   If you specify a numeric argument, `C-h i' prompts for the name of a
documentation file.  This way, you can browse a file which doesn't have
an entry in the top-level Info menu.  It is also handy when you need to
get to the documentation quickly, and you know the exact name of the
file.

   There are two special help commands for accessing XEmacs
documentation through Info.  `C-h C-f FUNCTION <RET>' enters Info and
goes straight to the documentation of the XEmacs function FUNCTION.
`C-h C-k KEY' enters Info and goes straight to the documentation of the
key KEY.  These two keys run the commands `Info-elisp-ref' and
`Info-goto-emacs-key-command-node'.

   If something surprising happens, and you are not sure what commands
you typed, use `C-h l' (`view-lossage').  `C-h l' prints the last 100
command characters you typed in.  If you see commands that you don't
know, you can use `C-h c' to find out what they do.

   XEmacs has several major modes.  Each mode redefines a few keys and
makes a few other changes in how editing works.  `C-h m'
(`describe-mode') prints documentation on the current major mode, which
normally describes all the commands that are changed in this mode.

   `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax')
present information about the current XEmacs mode that is not covered
by `C-h m'.  `C-h b' displays a list of all the key bindings currently
in effect, with the local bindings of the current major mode first,
followed by the global bindings (*note Key Bindings::).  `C-h s'
displays the contents of the syntax table with explanations of each
character's syntax (*note Syntax::).

   You can get a similar list for a particular prefix key by typing
`C-h' after the prefix key.  (There are a few prefix keys for which
this does not work--those that provide their own bindings for `C-h'.
One of these is <ESC>, because `<ESC> C-h' is actually `C-M-h', which
marks a defun.)

   The other `C-h' options display various files of useful information.
`C-h C-w' (`describe-no-warranty') displays the full details on the
complete absence of warranty for XEmacs.  `C-h n' (`view-emacs-news')
displays the file `xemacs/etc/NEWS', which contains documentation on
XEmacs changes arranged chronologically.  `C-h F' (`xemacs-local-faq')
displays local version of the XEmacs
frequently-answered-questions-list.  `C-h t' (`help-with-tutorial')
displays the learn-by-doing XEmacs tutorial. `C-h C-c'
(`describe-copying') displays the file `xemacs/etc/COPYING', which
tells you the conditions you must obey in distributing copies of
XEmacs.  `C-h C-d' (`describe-distribution') displays another file named
`xemacs/etc/DISTRIB', which tells you how you can order a copy of the
latest version of XEmacs.


File: xemacs.info,  Node: Mark,  Next: Mouse Selection,  Prev: Help,  Up: Top

Selecting Text
**************

Many Emacs commands operate on an arbitrary contiguous part of the
current buffer. You can select text in two ways:

   * You use special keys to select text by defining a region between
     point and the mark.

   * If you are running XEmacs under X, you can also select text with
     the mouse.

The Mark and the Region
=======================

To specify the text for a command to operate on, set "the mark" at one
end of it, and move point to the other end.  The text between point and
the mark is called "the region".  You can move point or the mark to
adjust the boundaries of the region.  It doesn't matter which one is
set first chronologically, or which one comes earlier in the text.

   Once the mark has been set, it remains until it is set again at
another place.  The mark remains fixed with respect to the preceding
character if text is inserted or deleted in a buffer.  Each Emacs
buffer has its own mark; when you return to a buffer that had been
selected previously, it has the same mark it had before.

   Many commands that insert text, such as `C-y' (`yank') and `M-x
insert-buffer', position the mark at one end of the inserted text--the
opposite end from where point is positioned, so that the region
contains the text just inserted.

   Aside from delimiting the region, the mark is useful for marking a
spot that you may want to go back to.  To make this feature more useful,
Emacs remembers 16 previous locations of the mark in the `mark ring'.

* Menu:

* Setting Mark::	Commands to set the mark.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.


File: xemacs.info,  Node: Setting Mark,  Next: Using Region,  Prev: Mark,  Up: Mark

Setting the Mark
----------------

Here are some commands for setting the mark:

`C-<SPC>'
     Set the mark where point is (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

`C-<'
     Pushes a mark at the beginning of the buffer.

`C->'
     Pushes a mark at the end of the buffer.

   For example, to convert part of the buffer to all upper-case, you
can use the `C-x C-u' (`upcase-region') command, which operates on the
text in the region.  First go to the beginning of the text you want to
capitalize and type `C-<SPC>' to put the mark there, then move to the
end, and then type `C-x C-u' to capitalize the selected region.  You
can also set the mark at the end of the text, move to the beginning,
and then type `C-x C-u'.  Most commands that operate on the text in the
region have the word `region' in their names.

   The most common way to set the mark is with the `C-<SPC>' command
(`set-mark-command').  This command sets the mark where point is. You
can then move point away, leaving the mark behind.  It is actually
incorrect to speak of the character `C-<SPC>'; there is no such
character.  When you type <SPC> while holding down <CTRL>, you get the
character `C-@' on most terminals. This character is actually bound to
`set-mark-command'.  But unless you are unlucky enough to have a
terminal where typing `C-<SPC>' does not produce `C-@', you should
think of this character as `C-<SPC>'.

   Since terminals have only one cursor, Emacs cannot show you where the
mark is located. Most people use the mark soon after they set it, before
they forget where it is. But you can see where the mark is with the
command `C-x C-x' (`exchange-point-and-mark') which puts the mark where
point was and point where the mark was.  The extent of the region is
unchanged, but the cursor and point are now at the previous location of
the mark.

   Another way to set the mark is to push the mark to the beginning of a
buffer while leaving point at its original location. If you supply an
argument to `C-<' (`mark-beginning-of-buffer'), the mark is pushed N/10
of the way from the true beginning of the buffer. You can also set the
mark at the end of a buffer with `C->' (`mark-end-of-buffer'). It
pushes the mark to the end of the buffer, leaving point alone.
Supplying an argument to the command pushes the mark N/10 of the way
from the true end of the buffer.

   If you are using XEmacs under the X window system, you can set the
variable `zmacs-regions' to `t'. This makes the current region (defined
by point and mark) highlight and makes it available as the X clipboard
selection, which means you can use the menu bar items on it.  *Note
Active Regions::, for more information.

   `C-x C-x' is also useful when you are satisfied with the location of
point but want to move the mark; do `C-x C-x' to put point there and
then you can move it.  A second use of `C-x C-x', if necessary, puts
the mark at the new location with point back at its original location.


File: xemacs.info,  Node: Using Region,  Next: Marking Objects,  Prev: Setting Mark,  Up: Mark

Operating on the Region
-----------------------

Once you have created an active region, you can do many things to the
text in it:
   * Kill it with `C-w' (*note Killing::).

   * Save it in a register with `C-x r s' (*note Registers::).

   * Save it in a buffer or a file (*note Accumulating Text::).

   * Convert case with `C-x C-l' or `C-x C-u'
     (*note Case::).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::).

   * Fill it as text with `M-q' (*note Filling::).

   * Print hardcopy with `M-x print-region' (*note Hardcopy::).

   * Indent it with `C-x <TAB>' or `C-M-\' (*note Indentation::).


File: xemacs.info,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

Commands to Mark Textual Objects
--------------------------------

There are commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of next Lisp expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current Lisp defun (`mark-defun').

`C-x h'
     Put region around entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

   `M-@' (`mark-word') puts the mark at the end of the next word, while
`C-M-@' (`mark-sexp') puts it at the end of the next Lisp expression.
These characters sometimes save you some typing.

   A number of commands are available that set both point and mark and
thus delimit an object in the buffer.  `M-h' (`mark-paragraph') moves
point to the beginning of the paragraph that surrounds or follows
point, and puts the mark at the end of that paragraph (*note
Paragraphs::).  You can then indent, case-convert, or kill the whole
paragraph.  In the same fashion, `C-M-h' (`mark-defun') puts point
before and the mark after the current or following defun (*note
Defuns::).  `C-x C-p' (`mark-page') puts point before the current page
(or the next or previous, depending on the argument), and mark at the
end (*note Pages::).  The mark goes after the terminating page
delimiter (to include it), while point goes after the preceding page
delimiter (to exclude it).  Finally, `C-x h' (`mark-whole-buffer') sets
up the entire buffer as the region by putting point at the beginning
and the mark at the end.


File: xemacs.info,  Node: Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
-------------

Aside from delimiting the region, the mark is also useful for marking a
spot that you may want to go back to.  To make this feature more
useful, Emacs remembers 16 previous locations of the mark in the "mark
ring".  Most commands that set the mark push the old mark onto this
ring.  To return to a marked location, use `C-u C-<SPC>' (or `C-u
C-@'); this is the command `set-mark-command' given a numeric argument.
The command moves point to where the mark was, and restores the mark
from the ring of former marks. Repeated use of this command moves point
to all the old marks on the ring, one by one.  The marks you have seen
go to the end of the ring, so no marks are lost.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-<SPC>' always stays
in the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This makes it easier for you to move back
later.  Searches set the mark, unless they do not actually move point.
When a command sets the mark, `Mark Set' is printed in the echo area.

   The variable `mark-ring-max' is the maximum number of entries to
keep in the mark ring.  If that many entries exist and another entry is
added, the last entry in the list is discarded.  Repeating `C-u
C-<SPC>' circulates through the entries that are currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.


File: xemacs.info,  Node: Mouse Selection,  Next: Additional Mouse Operations,  Prev: Mark,  Up: Top

Selecting Text with the Mouse
=============================

If you are using XEmacs under X, you can use the mouse pointer to
select text. (The normal mouse pointer is an I-beam, the same pointer
that `xterm' uses.)

   The glyph variable `text-pointer-glyph' controls the shape of the
mouse pointer when over text.  You can also control the shape of the
mouse pointer when over nontext using `nontext-pointer-glyph', and the
shape of the mouse pointer when over the modeline using
`modeline-pointer-glyph'. (Remember, you should use `set-glyph-image',
not `setq', to set one of these variables.)

   If you want to get fancy, you can set the foreground and background
colors of the mouse pointer by setting the `pointer' face.

   There are two ways to select a region of text with the mouse:

   To select a word in text, double-click with the left mouse button
while the mouse cursor is over the word.  The word is highlighted when
selected. On monochrome monitors, a stippled background indicates that a
region of text has been highlighted. On color monitors, a color
background indicates highlighted text. You can triple-click to select
whole lines.

   To select an arbitrary region of text:

  1. Move the mouse cursor over the character at the beginning of the
     region of text you want to select.

  2. Press and hold the left mouse button.

  3. While holding the left mouse button down, drag the cursor to the
     character at the end of the region of text you want to select.

  4. Release the left mouse button.
        The selected region of text is highlighted.

   Once a region of text is selected, it becomes the primary X selection
(*note Using X Selections::) as well as the Emacs selected region. You
can paste it into other X applications and use the options from the
Edit pull-down menu on it.  Since it is also the Emacs region, you can
use Emacs region commands on it.


File: xemacs.info,  Node: Additional Mouse Operations,  Next: Killing,  Prev: Mouse Selection,  Up: Top

Additional Mouse Operations
===========================

XEmacs also provides the following mouse functions.  Most of these are
not bound to mouse gestures by default, but they are provided for your
customization pleasure.  For example, if you wanted `shift-left' (that
is, holding down the <Shift> key and clicking the left mouse button) to
delete the character at which you are pointing, then you could do this:

     (global-set-key '(shift button1) 'mouse-del-char)

`mouse-del-char'
     Delete the character pointed to by the mouse.

`mouse-delete-window'
     Delete the Emacs window that the mouse is on.

`mouse-keep-one-window'
     Select the Emacs window that the mouse is on, then delete all other
     windows on this frame.

`mouse-kill-line'
     Kill the line pointed to by the mouse.

`mouse-line-length'
     Print the length of the line indicated by the pointer.

`mouse-scroll'
     Scroll point to the mouse position.

`mouse-select'
     Select the Emacs window the mouse is on.

`mouse-select-and-split'
     Select the Emacs window mouse is on, then split it vertically in
     half.

`mouse-set-mark'
     Select the Emacs window the mouse is on and set the mark at the
     mouse position.  Display the cursor at that position for a second.

`mouse-set-point'
     Select the Emacs window that the mouse is on and move point to the
     mouse position.

`mouse-track'
     Make a selection with the mouse.   This is the default binding of
     the left mouse button (<button1>).

`mouse-track-adjust'
     Extend the existing selection.  This is the default binding of
     <Shift-button1>.

`mouse-track-and-copy-to-cutbuffer'
     Make a selection like `mouse-track', but also copy it to the cut
     buffer.

`mouse-track-delete-and-insert'
     Make a selection with the mouse and insert it at point.  This is
     the default binding of <control-shift-button1>.

`mouse-track-insert'
     Make a selection with the mouse and insert it at point.  This is
     the default binding of <control-button1>.

`mouse-window-to-region'
     Narrow a window to the region between the cursor and the mouse
     pointer.

   The `M-x mouse-track' command should be bound to a mouse button.  If
you click-and-drag, the selection is set to the region between the
point of the initial click and the point at which you release the
button.  These positions do not need to be ordered.

   If you click-and-release without moving the mouse, the point is
moved, and the selection is disowned (there will be no selection
owner.)  The mark will be set to the previous position of point.

   If you double-click, the selection will extend by symbols instead of
by characters.  If you triple-click, the selection will extend by lines.

   If you drag the mouse off the top or bottom of the window, you can
select pieces of text that are larger than the visible part of the
buffer; the buffer will scroll as necessary.

   The selected text becomes the current X selection, and is also
copied to the top of the kill ring.  Point will be left at the position
at which you released the button and the mark will be left at the
initial click position.  Bind a mouse click to
`mouse-track-and-copy-to-cutbuffer' to copy selections to the cut
buffer.  (See also the `mouse-track-adjust' command, on
`Shift-button1'.)

   The `M-x mouse-track-adjust' command should be bound to a mouse
button.  The selection will be enlarged or shrunk so that the point of
the mouse click is one of its endpoints.  This is only meaningful after
the `mouse-track' command (<button1>) has been executed.

   The `M-x mouse-track-delete-and-insert' command is exactly the same
as the `mouse-track' command on <button1>, except that point is not
moved; the selected text is immediately inserted after being selected;
and the text of the selection is deleted.

   The `M-x mouse-track-insert' command is exactly the same as the
`mouse-track' command on <button1>, except that point is not moved; the
selected text is immediately inserted after being selected; and the
selection is immediately disowned afterwards.


File: xemacs.info,  Node: Killing,  Next: Yanking,  Prev: Additional Mouse Operations,  Up: Top

Deletion and Killing
====================

Most commands that erase text from the buffer save it. You can get the
text back if you change your mind, or you can move or copy it to other
parts of the buffer.  Commands which erase text and save it in the kill
ring are known as "kill" commands.  Some other commands erase text but
do not save it; they are known as "delete" commands.  (This distinction
is made only for erasing text in the buffer.)

   The commands' names and individual descriptions use the words `kill'
and `delete' to indicate what they do.  If you perform a kill or delete
command by mistake, use the `C-x u' (`undo') command to undo it (*note
Undo::). The delete commands include `C-d' (`delete-char') and <DEL>
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands that
can destroy significant amounts of nontrivial data usually kill.

Deletion
--------

`C-d'
     Delete next character (`delete-char').

`<DEL>'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-<SPC>'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, and any
     indentation following it (`delete-indentation').

   The most basic delete commands are `C-d' (`delete-char') and <DEL>
(`delete-backward-char').  `C-d' deletes the character after point, the
one the cursor is "on top of".  Point doesn't move.  <DEL> deletes the
character before the cursor, and moves point back.  You can delete
newlines like any other characters in the buffer; deleting a newline
joins two lines.  Actually, `C-d' and <DEL> aren't always delete
commands; if you give them an argument, they kill instead, since they
can erase more than one character this way.

   The other delete commands delete only formatting characters: spaces,
tabs and newlines.  `M-\' (`delete-horizontal-space') deletes all
spaces and tab characters before and after point.  `M-<SPC>'
(`just-one-space') does the same but leaves a single space after point,
regardless of the number of spaces that existed previously (even zero).

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line. If the current line is blank, it deletes all blank lines
preceding the current line as well as leaving one blank line, the
current line.  `M-^' (`delete-indentation') joins the current line and
the previous line, or, if given an argument, joins the current line and
the next line by deleting a newline and all surrounding spaces, possibly
leaving a single space.  *Note M-^: Indentation.

Killing by Lines
----------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

   The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving the line blank.  If
given on a blank line, the blank line disappears.  As a consequence, a
line disappears completely if you go to the front of a non-blank line
and type `C-k' twice.

   More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case, it kills the newline
following the line, thus merging the next line into the current one.
Emacs ignores invisible spaces and tabs at the end of the line when
deciding which case applies: if point appears to be at the end of the
line, you can be sure the newline will be killed.

   If you give `C-k' a positive argument, it kills that many lines and
the newlines that follow them (however, text on the current line before
point is not killed).  With a negative argument, `C-k' kills back to a
number of line beginnings.  An argument of -2 means kill back to the
second line beginning.  If point is at the beginning of a line, that
line beginning doesn't count, so `C-u - 2 C-k' with point at the front
of a line kills the two previous lines.

   `C-k' with an argument of zero kills all the text before point on the
current line.

Other Kill Commands
-------------------

`C-w'
     Kill region (from point to the mark) (`kill-region').  *Note
     Words::.

`M-d'
     Kill word (`kill-word').

`M-<DEL>'
     Kill word backwards (`backward-kill-word').

`C-x <DEL>'
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill sexp (`kill-sexp').  *Note Lists::.

`M-z CHAR'
     Kill up to next occurrence of CHAR (`zap-to-char').

   `C-w' (`kill-region') is a very general kill command; it kills
everything between point and the mark. You can use this command to kill
any contiguous sequence of characters by first setting the mark at one
end of a sequence of characters, then going to the other end and typing
`C-w'.

   A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (but not
including) the next occurrence of that character in the buffer.  If
there is no next occurrence, killing goes to the end of the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.

   Other syntactic units can be killed: words, with `M-<DEL>' and `M-d'
(*note Words::); sexps, with `C-M-k' (*note Lists::); and sentences,
with `C-x <DEL>' and `M-k' (*note Sentences::).


File: xemacs.info,  Node: Yanking,  Next: Using X Selections,  Prev: Killing,  Up: Top

Yanking
=======

"Yanking" means getting back text which was killed. Some systems call
this "pasting".  The usual way to move or copy text is to kill it and
then yank it one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace re-inserted killed text with the previously killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`copy-region-as-kill').

`C-M-w'
     Append next kill to last batch of killed text (`append-next-kill').

* Menu:

* Kill Ring::       Where killed text is stored.  Basic yanking.
* Appending Kills:: Several kills in a row all yank together.
* Earlier Kills::   Yanking something killed some time ago.


File: xemacs.info,  Node: Kill Ring,  Next: Appending Kills,  Prev: Yanking,  Up: Yanking

The Kill Ring
-------------

All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, used in all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

   If you have two separate Emacs processes, you cannot use the kill
ring to move text. If you are using XEmacs under X, however, you can
use the X selection mechanism to move text from one to another.

   If you are using XEmacs under X and have one Emacs process with
multiple frames, they do share the same kill ring.  You can kill or
copy text in one Emacs frame, then yank it in the other frame belonging
to the same process.

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text and sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' yanks the text, leaves the cursor in front of the text,
and sets the mark after it, if the argument is with just a `C-u'.  Any
other argument, including `C-u' and digits, has different results,
described below, under "Yanking Earlier Kills".

   To copy a block of text, you can also use `M-w'
(`copy-region-as-kill'), which copies the region into the kill ring
without removing it from the buffer. `M-w' is similar to `C-w' followed
by `C-y' but does not mark the buffer as "modified" and does not
actually cut anything.


File: xemacs.info,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

Normally, each kill command pushes a new block onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks it all back. This means you
don't have to kill all the text you want to yank in one command; you
can kill line after line, or word after word, until you have killed what
you want, then get it all back at once using `C-y'. (Thus we join
television in leading people to kill thoughtlessly.)

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add onto
the beginning.  This way, any sequence of mixed forward and backward
kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains:

     This is the first
     line of sample text
     and here is the third.

with point at the beginning of the second line.  If you type `C-k C-u 2
M-<DEL> C-k', the first `C-k' kills the text `line of sample text',
`C-u 2 M-<DEL>' kills `the first' with the newline that followed it,
and the second `C-k' kills the newline after the second line.  The
result is that the buffer contains `This is and here is the third.' and
a single kill entry contains `the first<RET>line of sample
text<RET>'--all the killed text, in its original order.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  To force a kill command to append, first type the command `C-M-w'
(`append-next-kill'). `C-M-w' tells the following command, if it is a
kill command, to append the text it kills to the last killed text,
instead of starting a new entry.  With `C-M-w', you can kill several
separated pieces of text and accumulate them to be yanked back in one
place.


File: xemacs.info,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

To recover killed text that is no longer the most recent kill, you need
the `Meta-y' (`yank-pop') command.  You can use `M-y' only after a
`C-y' or another `M-y'.  It takes the text previously yanked and
replaces it with the text from an earlier kill.  To recover the text of
the next-to-the-last kill, first use `C-y' to recover the last kill,
then `M-y' to replace it with the previous kill.

   You can think in terms of a "last yank" pointer which points at an
item in the kill ring.  Each time you kill, the "last yank" pointer
moves to the new item at the front of the ring.  `C-y' yanks the item
which the "last yank" pointer points to.  `M-y' moves the "last yank"
pointer to a different item, and the text in the buffer changes to
match.  Enough `M-y' commands can move the pointer to any item in the
ring, so you can get any item into the buffer.  Eventually the pointer
reaches the end of the ring; the next `M-y' moves it to the first item
again.

   Yanking moves the "last yank" pointer around the ring, but does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   Use `M-y' with a numeric argument to advance the "last yank" pointer
by the specified number of items.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves to the last entry and starts moving forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and the text will stay there. Since the text
is just a copy of the kill ring item, editing it in the buffer does not
change what's in the ring.  As long you don't kill additional text, the
"last yank" pointer remains at the same place in the kill ring:
repeating `C-y' will yank another copy of the same old kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a numeric
argument.  `C-y' with an argument greater than one restores the text
the specified number of entries back in the kill ring.  Thus, `C-u 2
C-y' gets the next to the last block of killed text.  It is equivalent
to `C-y M-y'.  `C-y' with a numeric argument starts counting from the
"last yank" pointer, and sets the "last yank" pointer to the entry that
it yanks.

   The variable `kill-ring-max' controls the length of the kill ring;
no more than that many blocks of killed text are saved.


File: xemacs.info,  Node: Using X Selections,  Next: Accumulating Text,  Prev: Yanking,  Up: Top

Using X Selections
==================

In the X window system, mouse selections provide a simple mechanism for
text transfer between different applications.  In a typical X
application, you can select text by pressing the left mouse button and
dragging the cursor over the text you want to copy.  The text becomes
the primary X selection and is highlighted.  The highlighted region is
also the Emacs selected region.

   * Since the region is the primary X selection, you can go to a
     different X application and click the middle mouse button: the
     text that you selected in the previous application is pasted into
     the current application.

   * Since the region is the Emacs selected region, you can use all
     region commands (`C-w, M-w' etc.) as well as the options of the
     Edit menu to manipulate the selected text.

* Menu:

* X Clipboard Selection::     	Pasting to the X clipboard.
* X Selection Commands::	Other operations on the selection.
* X Cut Buffers::       	X cut buffers are available for compatibility.
* Active Regions::      	Using zmacs-style highlighting of the
                        	 selected region.


File: xemacs.info,  Node: X Clipboard Selection,  Next: X Selection Commands,  Prev: Using X Selections,  Up: Using X Selections

The Clipboard Selection
-----------------------

There are other kinds of X selections besides the Primary selection; one
common one is the Clipboard selection.  Some applications prefer to
transfer data using this selection in preference to the Primary.  One
can transfer text from the Primary selection to the  Clipboard
selection with the Copy command under the Edit menu in the menubar.

   Usually, the clipboard selection is not visible.  However, if you
run the `xclipboard' application, the text most recently copied to the
clipboard (with the Copy command) is displayed in a window.  Any time
new text is thus copied, the `xclipboard' application makes a copy of
it and displays it in its window.  The value of the clipboard can
survive the lifetime of the running Emacs process.  The `xclipboard'
man page provides more details.

   Warning: If you use the `xclipboard' application, remember that it
maintains a list of all things that have been pasted to the clipboard
(that is, copied with the Copy command).  If you don't manually delete
elements from this list by clicking on the Delete button in the
`xclipboard' window, the clipboard will eventually consume a lot of
memory.

   In summary, some X applications (such as `xterm') allow one to paste
text in them from XEmacs in the following way:

   * Drag out a region of text in Emacs with the left mouse button,
     making that text be the Primary selection.

   * Click the middle button in the other application, pasting the
     Primary selection.

   With some other applications (notably, the OpenWindows and Motif
tools) you must use this method instead:

   * Drag out a region of text in Emacs with the left mouse button,
     making that text be the Primary selection.

   * Copy the selected text to the Clipboard selection by selecting the
     Copy menu item from the Edit menu, or by hitting the Copy key on
     your keyboard.

   * Paste the text in the other application by selecting Paste from its
     menu, or by hitting the Paste key on your keyboard.


File: xemacs.info,  Node: X Selection Commands,  Next: X Cut Buffers,  Prev: X Clipboard Selection,  Up: Using X Selections

Miscellaneous X Selection Commands
----------------------------------

`M-x x-copy-primary-selection'
     Copy the primary selection to both the kill ring and the Clipboard.

`M-x x-insert-selection'
     Insert the current selection into the buffer at point.

`M-x x-delete-primary-selection'
     Deletes the text in the primary selection without copying it to
     the kill ring or the Clipboard.

`M-x x-kill-primary-selection'
     Deletes the text in the primary selection and copies it to both
     the kill ring and the Clipboard.

`M-x x-mouse-kill'
     Kill the text between point and the mouse and copy it to the
     clipboard and to the cut buffer.

`M-x x-own-secondary-selection'
     Make a secondary X selection of the given argument.

`M-x x-own-selection'
     Make a primary X selection of the given argument.

`M-x x-set-point-and-insert-selection'
     Set point where clicked and insert the primary selection or the
     cut buffer.


File: xemacs.info,  Node: X Cut Buffers,  Next: Active Regions,  Prev: X Selection Commands,  Up: Using X Selections

X Cut Buffers
-------------

X cut buffers are a different, older way of transferring text between
applications.  XEmacs supports cut buffers for compatibility with older
programs, even though selections are now the preferred way of
transferring text.

   X has a concept of applications "owning" selections.  When you select
text by clicking and dragging inside an application, the application
tells the X server that it owns the selection.  When another
application asks the X server for the value of the selection, the X
server requests the information from the owner. When you use
selections, the selection data is not actually transferred unless
someone wants it; the act of making a selection doesn't transfer data.
Cut buffers are different: when you "own" a cut buffer, the data is
actually transferred to the X server immediately, and survives the
lifetime of the application.

   Any time a region of text becomes the primary selection in Emacs,
Emacs also copies that text to the cut buffer.  This makes it possible
to copy text from an XEmacs buffer and paste it into an older,
non-selection-based application (such as Emacs 18).

   Note: Older versions of Emacs could not access the X selections, only
the X cut buffers.


File: xemacs.info,  Node: Active Regions,  Prev: X Cut Buffers,  Up: Using X Selections

Active Regions
--------------

By default, both the text you select in an Emacs buffer using the
click-and-drag mechanism and text you select by setting point and the
mark is highlighted. You can use Emacs region commands as well as the
Cut and Copy commands on the highlighted region you selected with the
mouse.

   If you prefer, you can make a distinction between text selected with
the mouse and text selected with point and the mark by setting the
variable `zmacs-regions' to `nil'.  In that case:

   * The text selected with the mouse becomes both the X selection and
     the Emacs selected region. You can use menu-bar commands as well
     as Emacs region commands on it.

   * The text selected with point and the mark is not highlighted. You
     can only use Emacs region commands on it, not the menu-bar items.

   Active regions originally come from Zmacs, the Lisp Machine editor.
The idea behind them is that commands can only operate on a region when
the region is in an "active" state.  Put simply, you can only operate on
a region that is highlighted.

   The variable `zmacs-regions' checks whether LISPM-style active
regions should be used.  This means that commands that operate on the
region (the area between point and the mark) only work while the region
is in the active state, which is indicated by highlighting.  Most
commands causes the region to not be in the active state; for example,
`C-w' only works immediately after activating the region.

   More specifically:
   * Commands that operate on the region only work if the region is
     active.

   * Only a very small set of commands causes the region to become
     active-- those commands whose semantics are to mark an area, such
     as `mark-defun'.

   * The region is deactivated after each command that is executed,
     except that motion commands do not change whether the region is
     active or not.

   `set-mark-command' (`C-SPC') pushes a mark and activates the region.
Moving the cursor with normal motion commands (`C-n', `C-p', etc.)
will cause the region between point and the recently-pushed mark to be
highlighted.  It will remain highlighted until some non-motion command
is executed.

   `exchange-point-and-mark' (`C-x C-x') activates the region.  So if
you mark a region and execute a command that operates on it, you can
reactivate the same region with `C-x C-x' (or perhaps `C-x C-x C-x
C-x') to operate on it again.

   Generally, commands that push marks as a means of navigation, such as
`beginning-of-buffer' (`M-<') and `end-of-buffer' (`M->'), do not
activate the region.  However, commands that push marks as a means of
marking an area of text, such as `mark-defun' (`M-C-h'), `mark-word'
(`M-@'), and `mark-whole-buffer' (`C-x h'), do activate the region.

   When `zmacs-regions' is `t', there is no distinction between the
primary X selection and the active region selected by point and the
mark.  To see this, set the mark (<C-SPC>) and move the cursor with any
cursor-motion command: the region between point and mark is
highlighted, and you can watch it grow and shrink as you move the
cursor.

   Any other commands besides cursor-motion commands (such as inserting
or deleting text) will cause the region to no longer be active; it will
no longer be highlighted, and will no longer be the primary selection.
Region can be explicitly deactivated with `C-g'.

   Commands that require a region (such as `C-w') signal an error if
the region is not active.  Certain commands cause the region to be in
its active state.  The most common ones are `push-mark' (<C-SPC>) and
`exchange-point-and-mark' (`C-x C-x').

   When `zmacs-regions' is `t', programs can be non-intrusive on the
state of the region by setting the variable `zmacs-region-stays' to a
non-`nil' value.  If you are writing a new Emacs command that is
conceptually a "motion" command and should not interfere with the
current highlightedness of the region, then you may set this variable.
It is reset to `nil' after each user command is executed.

   When `zmacs-regions' is `t', programs can make the region between
point and mark go into the active (highlighted) state by using the
function `zmacs-activate-region'. Only a small number of commands
should ever do this.

   When `zmacs-regions' is `t', programs can deactivate the region
between point and the mark by using `zmacs-deactivate-region'.  Note:
you should not have to call this function; the command loop calls it
when appropriate.


File: xemacs.info,  Node: Accumulating Text,  Next: Rectangles,  Prev: Using X Selections,  Up: Top

Accumulating Text
=================

Usually you copy or move text by killing it and yanking it, but there
are other ways that are useful for copying one block of text in many
places, or for copying many scattered blocks of text into one place.

   If you like, you can accumulate blocks of text from scattered
locations either into a buffer or into a file.  The relevant commands
are described here.  You can also use Emacs registers for storing and
accumulating text.  *Note Registers::.

`M-x append-to-buffer'
     Append region to contents of specified buffer (`append-to-buffer').

`M-x prepend-to-buffer'
     Prepend region to contents of specified buffer.

`M-x copy-to-buffer'
     Copy region into specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert contents of specified buffer into current buffer at point.

`M-x append-to-file'
     Append region to the end of the contents of specified file.

   To accumulate text into a buffer, use the command `M-x
append-to-buffer', which inserts a copy of the region into the buffer
BUFFERNAME, at the location of point in that buffer.  If there is no
buffer with the given name, one is created.

   If you append text to a buffer that has been used for editing, the
copied text goes to the place where point is.  Point in that buffer is
left at the end of the copied text, so successive uses of
`append-to-buffer' accumulate the text in the specified buffer in the
same order as they were copied.  Strictly speaking, this command does
not always append to the text already in the buffer; but if this command
is the only command used to alter a buffer, it does always append to the
existing text because point is always at the end.

   `M-x prepend-to-buffer' is similar to `append-to-buffer', but point
in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is
similar, except that any existing text in the other buffer is deleted,
so the buffer is left containing just the text newly copied into it.

   You can retrieve the accumulated text from that buffer with `M-x
insert-buffer', which takes BUFFERNAME as an argument.  It inserts a
copy of the text in buffer BUFFERNAME into the selected buffer.  You
could alternatively select the other buffer for editing, perhaps moving
text from it by killing or with `append-to-buffer'.  *Note Buffers::,
for background information on buffers.

   Instead of accumulating text within Emacs in a buffer, you can append
text directly into a file with `M-x append-to-file', which takes
FILE-NAME as an argument.  It adds the text of the region to the end of
the specified file.  The file is changed immediately on disk.  This
command is normally used with files that are not being visited in
Emacs.  Using it on a file that Emacs is visiting can produce confusing
results, because the file's text inside Emacs does not change while the
file itself changes.


File: xemacs.info,  Node: Rectangles,  Next: Registers,  Prev: Accumulating Text,  Up: Top

Rectangles
==========

The rectangle commands affect rectangular areas of text: all characters
between a certain pair of columns, in a certain range of lines.
Commands are provided to kill rectangles, yank killed rectangles, clear
them out, or delete them.  Rectangle commands are useful with text in
multicolumnar formats, like code with comments at the right, or for
changing text into or out of such formats.

   To specify the rectangle a command should work on, put the mark at
one corner and point at the opposite corner.  The specified rectangle is
called the "region-rectangle" because it is controlled about the same
way the region is controlled.  Remember that a given combination of
point and mark values can be interpreted either as specifying a region
or as specifying a rectangle; it is up to the command that uses them to
choose the interpretation.

`M-x delete-rectangle'
     Delete the text of the region-rectangle, moving any following text
     on each line leftward to the left edge of the region-rectangle.

`M-x kill-rectangle'
     Similar, but also save the contents of the region-rectangle as the
     "last killed rectangle".

`M-x yank-rectangle'
     Yank the last killed rectangle with its upper left corner at point.

`M-x open-rectangle'
     Insert blank space to fill the space of the region-rectangle.  The
     previous contents of the region-rectangle are pushed rightward.

`M-x clear-rectangle'
     Clear the region-rectangle by replacing its contents with spaces.

   The rectangle operations fall into two classes: commands deleting and
moving rectangles, and commands for blank rectangles.

   There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed" rectangle.
The commands for these two ways are `M-x delete-rectangle' and `M-x
kill-rectangle'.  In either case, the portion of each line that falls
inside the rectangle's boundaries is deleted, causing following text
(if any) on the line to move left.

   Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that only records the most recently killed rectangle (that is, does not
append to a killed rectangle).  Different yank commands have to be used
and only one rectangle is stored, because yanking a rectangle is quite
different from yanking linear text and yank-popping commands are
difficult to make sense of.

   Inserting a rectangle is the opposite of deleting one.  You specify
where to put the upper left corner by putting point there.  The
rectangle's first line is inserted at point, the rectangle's second line
is inserted at a point one line vertically down, and so on.  The number
of lines affected is determined by the height of the saved rectangle.

   To insert the last killed rectangle, type `M-x yank-rectangle'.
This can be used to convert single-column lists into double-column
lists; kill the second half of the list as a rectangle and then yank it
beside the first line of the list.

   There are two commands for working with blank rectangles: `M-x
clear-rectangle' erases existing text, and `M-x open-rectangle' inserts
a blank rectangle.  Clearing a rectangle is equivalent to deleting it
and then inserting a blank rectangle of the same size.

   Rectangles can also be copied into and out of registers.  *Note
Rectangle Registers: RegRect.


File: xemacs.info,  Node: Registers,  Next: Display,  Prev: Rectangles,  Up: Top

Registers
*********

XEmacs "registers" are places in which you can save text or positions
for later use.  Once you save text or a rectangle in a register, you
can copy it into the buffer once or many times; a position saved in a
register is used by moving point to that position.  Rectangles can also
be copied into and out of registers (*note Rectangles::).

   Each register has a name which is a single character.  A register can
store a piece of text, a rectangle, a position, a window configuration,
or a file name, but only one thing at any given time.  Whatever you
store in a register remains there until you store something else in that
register.  To see what a register R contains, use `M-x view-register'.

`M-x view-register <RET> R'
     Display a description of what register R contains.

   `M-x view-register' reads a register name as an argument and then
displays the contents of the specified register.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.


File: xemacs.info,  Node: RegPos,  Next: RegText,  Prev: Registers,  Up: Registers

Saving Positions in Registers
=============================

Saving a position records a place in a buffer so that you can move back
there later.  Moving to a saved position switches to that buffer and
moves point to that place in it.

`C-x r <SPC> R'
     Save position of point in register R (`point-to-register').

`C-x r j R'
     Jump to the position saved in register R (`jump-to-register').

   To save the current position of point in a register, choose a name R
and type `C-x r <SPC> R'.  The register R retains the position thus
saved until you store something else in that register.

   The command `C-x r j R' moves point to the position recorded in
register R.  The register is not affected; it continues to record the
same location.  You can jump to the same position using the same
register as often as you want.

   If you use `C-x r j' to go to a saved position, but the buffer it
was saved from has been killed, `C-x r j' tries to create the buffer
again by visiting the same file.  Of course, this works only for buffers
that were visiting files.


File: xemacs.info,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

Saving Text in Registers
========================

When you want to insert a copy of the same piece of text many times, it
can be impractical to use the kill ring, since each subsequent kill
moves the piece of text further down on the ring.  It becomes hard to
keep track of the argument needed to retrieve the same text with `C-y'.
An alternative is to store the text in a register with `C-x r s'
(`copy-to-register') and then retrieve it with `C-x r i'
(`insert-register').

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r g R'
`C-x r i R'
     Insert text contents of register R (`insert-register').

   `C-x r s R' stores a copy of the text of the region into the
register named R.  Given a numeric argument, `C-x r s R' deletes the
text from the buffer as well.

   `C-x r i R' inserts the text from register R in the buffer.  By
default it leaves point before the text and places the mark after it.
With a numeric argument (`C-u'), it puts point after the text and the
mark before it.


File: xemacs.info,  Node: RegRect,  Next: RegConfig,  Prev: RegText,  Up: Registers

Saving Rectangles in Registers
==============================

A register can contain a rectangle instead of lines of text.  The
rectangle is represented as a list of strings.  *Note Rectangles::, for
basic information on rectangles and how to specify rectangles in a
buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-rectangle-to-register').  With a numeric argument, delete it
     as well.

`C-x r g R'
`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' command inserts linear text if the register
contains that, or inserts a rectangle if the register contains one.

   See also the command `sort-columns', which you can think of as
sorting a rectangle.  *Note Sorting::.


File: xemacs.info,  Node: RegConfig,  Next: RegNumbers,  Prev: RegRect,  Up: Registers

Saving Window Configurations in Registers
=========================================

You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`M-x frame-configuration-to-register <RET> R'
     Save the state of all frames, including all their windows, in
     register R (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: xemacs.info,  Node: RegNumbers,  Next: RegFiles,  Prev: RegConfig,  Up: Registers

Keeping Numbers in Registers
============================

There are commands to store a number in a register, to insert the
number in the buffer in decimal, and to increment it.  These commands
can be useful in keyboard macros (*note Keyboard Macros::).

`C-u NUMBER C-x r n REG'
     Store NUMBER into register REG (`number-to-register').

`C-u NUMBER C-x r + REG'
     Increment the number in register REG by NUMBER
     (`increment-register').

`C-x r g REG'
     Insert the number from register REG into the buffer.

   `C-x r g' is the same command used to insert any other sort of
register contents into the buffer.


File: xemacs.info,  Node: RegFiles,  Next: Bookmarks,  Prev: RegNumbers,  Up: Registers

Keeping File Names in Registers
===============================

If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/usr/src/xemacs/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)


File: xemacs.info,  Node: Bookmarks,  Prev: RegFiles,  Up: Registers

Bookmarks
=========

"Bookmarks" are somewhat like registers in that they record positions
you can jump to.  Unlike registers, they have long names, and they
persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

   Note: bookmark.el is distributed in edit-utils package.  You need to
install that to use bookmark facility (*note Packages::).

`C-x r m <RET>'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK <RET>'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK <RET>'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks').

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions or annotate the bookmarks.
Type `C-h m' in that buffer for more information about its special
editing commands.

   When you kill XEmacs, XEmacs offers to save your bookmark values in
your default bookmark file, `~/.emacs.bmk', if you have changed any
bookmark values.  You can also save the bookmarks at any time with the
`M-x bookmark-save' command.  The bookmark commands load your default
bookmark file automatically.  This saving and loading is how bookmarks
persist from one XEmacs session to the next.

   If you set the variable `bookmark-save-flag' to 1, then each command
that sets a bookmark will also save your bookmarks; this way, you don't
lose any bookmark values even if XEmacs crashes.  (The value, if a
number, says how many bookmark modifications should go by between
saving.)

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record, on each side of the bookmark's
position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load <RET> FILENAME <RET>'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write <RET> FILENAME <RET>'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete <RET> BOOKMARK <RET>'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-insert-location <RET> BOOKMARK <RET>'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert <RET> BOOKMARK <RET>'
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.


File: xemacs.info,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

Controlling the Display
***********************

Since only part of a large buffer fits in the window, XEmacs tries to
show the part that is likely to be interesting.  The display control
commands allow you to specify which part of the text you want to see.

`C-l'
     Clear frame and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
`pgdn'
`next'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').  On most X keyboards, you can get this
     functionality using the key labelled `Page Down', which generates
     either `next' or `pgdn'.

`M-v'
`pgup'
`prior'
     Scroll backward (`scroll-down').  On most X keyboards, you can get
     this functionality using the key labelled `Page Up', which
     generates either `prior' or `pgup'.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-x <'
`C-pgdn'
`C-next'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
`C-pgup'
`C-prior'
     Scroll to the right (`scroll-right').

`C-x $'
     Make deeply indented lines invisible (`set-selective-display').

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* Display Vars::           Information on variables for customizing display.


File: xemacs.info,  Node: Scrolling,  Next: Horizontal Scrolling,  Prev: Display,  Up: Display

Scrolling
=========

If a buffer contains text that is too large to fit entirely within the
window that is displaying the buffer, XEmacs shows a contiguous section
of the text.  The section shown always contains point.

   "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling forward means that
text moves up, and new text appears at the bottom.  Scrolling backward
moves text down and new text appears at the top.

   Scrolling happens automatically if you move point past the bottom or
top of the window.  You can also explicitly request scrolling with the
commands in this section.

`C-l'
     Clear frame and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
`pgdn'
`next'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`M-v'
`pgup'
`prior'
     Scroll backward (`scroll-down').

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

   The most basic scrolling command is `C-l' (`recenter') with no
argument.  It clears the entire frame and redisplays all windows.  In
addition, it scrolls the selected window so that point is halfway down
from the top of the window.

   The scrolling commands `C-v' and `M-v' let you move all the text in
the window up or down a few lines.  `C-v' (`scroll-up') with an
argument shows you that many more lines at the bottom of the window,
moving the text and point up together as `C-l' might.  `C-v' with a
negative argument shows you more lines at the top of the window.
`Meta-v' (`scroll-down') is like `C-v', but moves in the opposite
direction.

   To read the buffer a windowful at a time, use `C-v' with no
argument.  `C-v' takes the last two lines at the bottom of the window
and puts them at the top, followed by nearly a whole windowful of lines
not previously visible.  Point moves to the new top of the window if it
was in the text scrolled off the top.  `M-v' with no argument moves
backward with similar overlap.  The number of lines of overlap across a
`C-v' or `M-v' is controlled by the variable
`next-screen-context-lines'; by default, it is two.

   Another way to scroll is using `C-l' with a numeric argument.  `C-l'
does not clear the frame when given an argument; it only scrolls the
selected window.  With a positive argument N, `C-l' repositions text to
put point N lines down from the top.  An argument of zero puts point on
the very top line.  Point does not move with respect to the text;
rather, the text and point move rigidly on the frame.  `C-l' with a
negative argument puts point that many lines from the bottom of the
window.  For example, `C-u - 1 C-l' puts point on the bottom line, and
`C-u - 5 C-l' puts it five lines from the bottom.  Just `C-u' as
argument, as in `C-u C-l', scrolls point to the center of the frame.

   Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Usually scrolling is
done  to put point vertically centered within the window.  However, if
the variable `scroll-step' has a non-zero value, an attempt is made to
scroll the buffer by that many lines; if that is enough to bring point
back into visibility, that is what happens.

   Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Usually scrolling is
done  to put point vertically centered within the window.  However, if
the variable `scroll-step' has a non-zero value, an attempt is made to
scroll the buffer by that many lines; if that is enough to bring point
back into visibility, that is what happens.

   If you set `scroll-step' to a small value because you want to use
arrow keys to scroll the screen without recentering, the redisplay
preemption will likely make XEmacs keep recentering the screen when
scrolling fast, regardless of `scroll-step'.  To prevent this, set
`scroll-conservatively' to a small value, which will have the result of
overriding the redisplay preemption.


File: xemacs.info,  Node: Horizontal Scrolling,  Prev: Scrolling,  Up: Display

Horizontal Scrolling
====================

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

The text in a window can also be scrolled horizontally.  This means that
each line of text is shifted sideways in the window, and one or more
characters at the beginning of each line are not displayed at all.
When a window has been scrolled horizontally in this way, text lines
are truncated rather than continued (*note Continuation Lines::), with
a `$' appearing in the first column when there is text truncated to the
left, and in the last column when there is text truncated to the right.

   The command `C-x <' (`scroll-left') scrolls the selected window to
the left by N columns with argument N.  With no argument, it scrolls by
almost the full width of the window (two columns less, to be precise).
`C-x >' (`scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displaying
normally (with each line starting at the window's left margin);
attempting to do so has no effect.


File: xemacs.info,  Node: Selective Display,  Next: Display Vars,  Prev: Display,  Up: Display

Selective Display
=================

XEmacs can hide lines indented more than a certain number of columns
(you specify how many columns).  This allows you  to get an overview of
a part of a program.

   To hide lines, type `C-x $' (`set-selective-display') with a numeric
argument N.  (*Note Arguments::, for information on giving the
argument.)  Lines with at least N columns of indentation disappear from
the screen.  The only indication of their presence are three dots
(`...'), which appear at the end of each visible line that is followed
by one or more invisible ones.

   The invisible lines are still present in the buffer, and most editing
commands see them as usual, so it is very easy to put point in the
middle of invisible text.  When this happens, the cursor appears at the
end of the previous line, after the three dots.  If point is at the end
of the visible line, before the newline that ends it, the cursor
appears before the three dots.

   The commands `C-n' and `C-p' move across the invisible lines as if
they were not there.

   To make everything visible again, type `C-x $' with no argument.


File: xemacs.info,  Node: Display Vars,  Prev: Selective Display,  Up: Display

Variables Controlling Display
=============================

This section contains information for customization only.  Beginning
users should skip it.

   When you reenter XEmacs after suspending, XEmacs normally clears the
screen and redraws the entire display.  On some terminals with more than
one page of memory, it is possible to arrange the termcap entry so that
the `ti' and `te' strings (output to the terminal when XEmacs is
entered and exited, respectively) switch between pages of memory so as
to use one page for XEmacs and another page for other output.  In that
case, you might want to set the variable `no-redraw-on-reenter' to
non-`nil' so that XEmacs will assume, when resumed, that the screen
page it is using still contains what XEmacs last wrote there.

   The variable `echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero, meaning don't echo at all.
*Note Echo Area::.

   If the variable `ctl-arrow' is `nil', control characters in the
buffer are displayed with octal escape sequences, all except newline and
tab.  If its value is `t', then control characters will be printed with
an up-arrow, for example `^A'.

   If its value is not `t' and not `nil', then characters whose code is
greater than 160 (that is, the space character (32) with its high bit
set) will be assumed to be printable, and will be displayed without
alteration.  This is the default when running under X Windows, since
XEmacs assumes an ISO/8859-1 character set (also known as "Latin1").
The `ctl-arrow' variable may also be set to an integer, in which case
all characters whose codes are greater than or equal to that value will
be assumed to be printable.

   Altering the value of `ctl-arrow' makes it local to the current
buffer; until that time, the default value is in effect.  *Note
Locals::.

   Normally, a tab character in the buffer is displayed as whitespace
which extends to the next display tab stop position, and display tab
stops come at intervals equal to eight spaces.  The number of spaces
per tab is controlled by the variable `tab-width', which is made local
by changing it, just like `ctl-arrow'.  Note that how the tab character
in the buffer is displayed has nothing to do with the definition of
<TAB> as a command.

   If you set the variable `selective-display-ellipses' to `nil', the
three dots at the end of a line that precedes invisible lines do not
appear.  There is no visible indication of the invisible lines.  This
variable becomes local automatically when set.


File: xemacs.info,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

Searching and Replacement
*************************

Like other editors, Emacs has commands for searching for occurrences of
a string.  The principal search command is unusual in that it is
"incremental": it begins to search before you have finished typing the
search string.  There are also non-incremental search commands more like
those of other editors.

   Besides the usual `replace-string' command that finds all
occurrences of one string and replaces them with another, Emacs has a
fancy replacement command called `query-replace' which asks
interactively which occurrences to replace.

* Menu:

* Incremental Search::     Search happens as you type the string.
* Non-Incremental Search:: Specify entire string and then search.
* Word Search::            Search for sequence of words.
* Regexp Search::          Search for match for a regexp.
* Regexps::                Syntax of regular expressions.
* Search Case::            To ignore case while searching, or not.
* Replace::                Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.


File: xemacs.info,  Node: Incremental Search,  Next: Non-Incremental Search,  Prev: Search,  Up: Search

Incremental Search
==================

An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string, Emacs
shows you where the string (as you have typed it so far) is found.
When you have typed enough characters to identify the place you want,
you can stop.  Depending on what you do next, you may or may not need to
terminate the search explicitly with a <RET>.

`C-s'
     Incremental search forward (`isearch-forward').

`C-r'
     Incremental search backward (`isearch-backward').

   `C-s' starts an incremental search.  `C-s' reads characters from the
keyboard and positions the cursor at the first occurrence of the
characters that you have typed.  If you type `C-s' and then `F', the
cursor moves right after the first `F'.  Type an `O', and see the
cursor move to after the first `FO'.  After another `O', the cursor is
after the first `FOO' after the place where you started the search.
Meanwhile, the search string `FOO' has been echoed in the echo area.

   The echo area display ends with three dots when actual searching is
going on.  When search is waiting for more input, the three dots are
removed.  (On slow terminals, the three dots are not displayed.)

   If you make a mistake in typing the search string, you can erase
characters with <DEL>.  Each <DEL> cancels the last character of the
search string.  This does not happen until Emacs is ready to read
another input character; first it must either find, or fail to find,
the character you want to erase.  If you do not want to wait for this
to happen, use `C-g' as described below.

   When you are satisfied with the place you have reached, you can type
<RET> (or <C-m>), which stops searching, leaving the cursor where the
search brought it.  Any command not specially meaningful in searches
also stops the search and is then executed.  Thus, typing `C-a' exits
the search and then moves to the beginning of the line.  <RET> is
necessary only if the next command you want to type is a printing
character, <DEL>, <ESC>, or another control character that is special
within searches (`C-q', `C-w', `C-r', `C-s', or `C-y').

   Sometimes you search for `FOO' and find it, but were actually
looking for a different occurrence of it.  To move to the next
occurrence of the search string, type another `C-s'.  Do this as often
as necessary.  If you overshoot, you can cancel some `C-s' characters
with <DEL>.

   After you exit a search, you can search for the same string again by
typing just `C-s C-s': the first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again".

   If the specified string is not found at all, the echo area displays
the text `Failing I-Search'.  The cursor is after the place where Emacs
found as much of your string as it could.  Thus, if you search for
`FOOT', and there is no `FOOT', the cursor may be after the `FOO' in
`FOOL'.  At this point there are several things you can do.  If you
mistyped the search string, correct it.  If you like the place you have
found, you can type <RET> or some other Emacs command to "accept what
the search offered".  Or you can type `C-g', which removes from the
search string the characters that could not be found (the `T' in
`FOOT'), leaving those that were found (the `FOO' in `FOOT').  A second
`C-g' at that point cancels the search entirely, returning point to
where it was when the search started.

   If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating a
failing backward search with `C-r' starts again from the end.  This is
called "wrapping around".  `Wrapped' appears in the search prompt once
this has happened.

   The `C-g' "quit" character does special things during searches; just
what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, `C-g' cancels the
entire search.  The cursor moves back to where you started the search.
If `C-g' is typed when there are characters in the search string that
have not been found--because Emacs is still searching for them, or
because it has failed to find them--then the search string characters
which have not been found are discarded from the search string.  The
search is now successful and waiting for more input, so a second `C-g'
cancels the entire search.

   To search for a control character such as `C-s' or <DEL> or <ESC>,
you must quote it by typing `C-q' first.  This function of `C-q' is
analogous to its meaning as an Emacs command: it causes the following
character to be treated the way a graphic character would normally be
treated in the same context.

   To search backwards, you can use `C-r' instead of `C-s' to start the
search; `C-r' is the key that runs the command (`isearch-backward') to
search backward.  You can also use `C-r' to change from searching
forward to searching backwards.  Do this if a search fails because the
place you started was too far down in the file.  Repeated `C-r' keeps
looking for more occurrences backwards.  `C-s' starts going forward
again.  You can cancel `C-r' in a search with <DEL>.

   The characters `C-y' and `C-w' can be used in incremental search to
grab text from the buffer into the search string.  This makes it
convenient to search for another occurrence of text at point.  `C-w'
copies the word after point as part of the search string, advancing
point over that word.  Another `C-s' to repeat the search will then
search for a string including that word.  `C-y' is similar to `C-w' but
copies the rest of the current line into the search string.

   The characters `M-p' and `M-n' can be used in an incremental search
to recall things which you have searched for in the past.  A list of
the last 16 things you have searched for is retained, and `M-p' and
`M-n' let you cycle through that ring.

   The character `M-<TAB>' does completion on the elements in the
search history ring.  For example, if you know that you have recently
searched for the string `POTATOE', you could type `C-s P O M-<TAB>'.
If you had searched for other strings beginning with `PO' then you
would be shown a list of them, and would need to type more to select
one.

   You can change any of the special characters in incremental search
via the normal keybinding mechanism: simply add a binding to the
`isearch-mode-map'.  For example, to make the character `C-b' mean
"search backwards" while in isearch-mode, do this:

     (define-key isearch-mode-map "\C-b" 'isearch-repeat-backward)

   These are the default bindings of isearch-mode:

`DEL'
     Delete a character from the incremental search string
     (`isearch-delete-char').

`RET'
     Exit incremental search (`isearch-exit').

`C-q'
     Quote special characters for incremental search
     (`isearch-quote-char').

`C-s'
     Repeat incremental search forward (`isearch-repeat-forward').

`C-r'
     Repeat incremental search backward (`isearch-repeat-backward').

`C-y'
     Pull rest of line from buffer into search string
     (`isearch-yank-line').

`C-w'
     Pull next word from buffer into search string
     (`isearch-yank-word').

`C-g'
     Cancels input back to what has been found successfully, or aborts
     the isearch (`isearch-abort').

`M-p'
     Recall the previous element in the isearch history ring
     (`isearch-ring-retreat').

`M-n'
     Recall the next element in the isearch history ring
     (`isearch-ring-advance').

`M-<TAB>'
     Do completion on the elements in the isearch history ring
     (`isearch-complete').


   Any other character which is normally inserted into a buffer when
typed is automatically added to the search string in isearch-mode.

Slow Terminal Incremental Search
--------------------------------

Incremental search on a slow terminal uses a modified style of display
that is designed to take less time.  Instead of redisplaying the buffer
at each place the search gets to, it creates a new single-line window
and uses that to display the line the search has found.  The
single-line window appears as soon as point gets outside of the text
that is already on the screen.

   When the search is terminated, the single-line window is removed.
Only at this time the window in which the search was done is
redisplayed to show its new value of point.

   The three dots at the end of the search string, normally used to
indicate that searching is going on, are not displayed in slow style
display.

   The slow terminal style of display is used when the terminal baud
rate is less than or equal to the value of the variable
`search-slow-speed', initially 1200.

   The number of lines to use in slow terminal search display is
controlled by the variable `search-slow-window-lines'.  Its normal
value is 1.


File: xemacs.info,  Node: Non-Incremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

Non-Incremental Search
======================

Emacs also has conventional non-incremental search commands, which
require you type the entire search string before searching begins.

`C-s <RET> STRING <RET>'
     Search for STRING.

`C-r <RET> STRING <RET>'
     Search backward for STRING.

   To do a non-incremental search, first type `C-s <RET>' (or `C-s
C-m').  This enters the minibuffer to read the search string.
Terminate the string with <RET> to start the search.  If the string is
not found, the search command gets an error.

   By default, `C-s' invokes incremental search, but if you give it an
empty argument, which would otherwise be useless, it invokes
non-incremental search.  Therefore, `C-s <RET>' invokes non-incremental
search.  `C-r <RET>' also works this way.

   Forward and backward non-incremental searches are implemented by the
commands `search-forward' and `search-backward'.  You can bind these
commands to keys.  The reason that incremental search is programmed to
invoke them as well is that `C-s <RET>' is the traditional sequence of
characters used in Emacs to invoke non-incremental search.

   Non-incremental searches performed using `C-s <RET>' do not call
`search-forward' right away.  They first check if the next character is
`C-w', which requests a word search.  *Note Word Search::.


File: xemacs.info,  Node: Word Search,  Next: Regexp Search,  Prev: Non-Incremental Search,  Up: Search

Word Search
===========

Word search looks for a sequence of words without regard to how the
words are separated.  More precisely, you type a string of many words,
using single spaces to separate them, and the string is found even if
there are multiple spaces, newlines or other punctuation between the
words.

   Word search is useful in editing documents formatted by text
formatters.  If you edit while looking at the printed, formatted
version, you can't tell where the line breaks are in the source file.
Word search, allows you to search  without having to know the line
breaks.

`C-s <RET> C-w WORDS <RET>'
     Search for WORDS, ignoring differences in punctuation.

`C-r <RET> C-w WORDS <RET>'
     Search backward for WORDS, ignoring differences in punctuation.

   Word search is a special case of non-incremental search.  It is
invoked with `C-s <RET> C-w' followed by the search string, which must
always be terminated with another <RET>.  Being non-incremental, this
search does not start until the argument is terminated.  It works by
constructing a regular expression and searching for that.  *Note Regexp
Search::.

   You can do a backward word search with `C-r <RET> C-w'.

   Forward and backward word searches are implemented by the commands
`word-search-forward' and `word-search-backward'.  You can bind these
commands to keys.  The reason that incremental search is programmed to
invoke them as well is that `C-s <RET> C-w' is the traditional Emacs
sequence of keys for word search.


File: xemacs.info,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

Regular Expression Search
=========================

A "regular expression" ("regexp", for short) is a pattern that denotes
a (possibly infinite) set of strings.  Searching for matches for a
regexp is a powerful operation that editors on Unix systems have
traditionally offered.

   To gain a thorough understanding of regular expressions and how to
use them to best advantage, we recommend that you study `Mastering
Regular Expressions, by Jeffrey E.F. Friedl, O'Reilly and Associates,
1997'. (It's known as the "Hip Owls" book, because of the picture on its
cover.)  You might also read the manuals to *Note (gawk)Top::, *Note
(ed)Top::, `sed', `grep', *Note (perl)Top::, *Note (regex)Top::, *Note
(rx)Top::, `pcre', and *Note (flex)Top::, which also make good use of
regular expressions.

   The XEmacs regular expression syntax most closely resembles that of
`ed', or `grep', the GNU versions of which all utilize the GNU `regex'
library.  XEmacs' version of `regex' has recently been extended with
some Perl-like capabilities, described in the next section.

   In XEmacs, you can search for the next match for a regexp either
incrementally or not.

   Incremental search for a regexp is done by typing `M-C-s'
(`isearch-forward-regexp').  This command reads a search string
incrementally just like `C-s', but it treats the search string as a
regexp rather than looking for an exact match against the text in the
buffer.  Each time you add text to the search string, you make the
regexp longer, and the new regexp is searched for.  A reverse regexp
search command `isearch-backward-regexp' also exists, bound to `M-C-r'.

   All of the control characters that do special things within an
ordinary incremental search have the same functionality in incremental
regexp search.  Typing `C-s' or `C-r' immediately after starting a
search retrieves the last incremental search regexp used: incremental
regexp and non-regexp searches have independent defaults.

   Non-incremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke them with
`M-x' or bind them to keys.  You can also call `re-search-forward' by
way of incremental regexp search with `M-C-s <RET>'; similarly for
`re-search-backward' with `M-C-r <RET>'.


File: xemacs.info,  Node: Regexps,  Next: Search Case,  Prev: Regexp Search,  Up: Search

Syntax of Regular Expressions
=============================

Regular expressions have a syntax in which a few characters are special
constructs and the rest are "ordinary".  An ordinary character is a
simple regular expression that matches that character and nothing else.
The special characters are `.', `*', `+', `?', `[', `]', `^', `$', and
`\'; no new special characters will be defined in the future.  Any
other character appearing in a regular expression is ordinary, unless a
`\' precedes it.

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does _not_ match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression that matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something more powerful, you need
to use one of the special characters.  Here is a list of them:

`. (Period)'
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b', which matches any three-character string that begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a quantifying suffix operator
     that means to repeat the preceding regular expression as many
     times as possible.  In `fo*', the `*' applies to the `o', so `fo*'
     matches one `f' followed by any number of `o's.  The case of zero
     `o's is allowed: `fo*' does match `f'.

     `*' always applies to the _smallest_ possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating `fo'.

     The matcher processes a `*' construct by matching, immediately, as
     many repetitions as can be found; it is "greedy".  Then it
     continues with the rest of the pattern.  If that fails,
     backtracking occurs, discarding some of the matches of the
     `*'-modified construct in case that makes it possible to match the
     rest of the pattern.  For example, in matching `ca*ar' against the
     string `caaar', the `a*' first tries to match all three `a's; but
     the rest of the pattern is `ar' and there is only `r' left to
     match, so this try fails.  The next alternative is for `a*' to
     match only two `a's.  With this choice, the rest of the regexp
     matches successfully.

     Nested repetition operators can be extremely slow if they specify
     backtracking loops.  For example, it could take hours for the
     regular expression `\(x+y*\)*a' to match the sequence
     `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz'.  The slowness is because
     Emacs must try each imaginable way of grouping the 35 `x''s before
     concluding that none of them can work.  To make sure your regular
     expressions run fast, check nested repetitions carefully.

`+'
     is a quantifying suffix operator similar to `*' except that the
     preceding expression must match at least once.  It is also
     "greedy".  So, for example, `ca+r' matches the strings `car' and
     `caaaar' but not the string `cr', whereas `ca*r' matches all three
     strings.

`?'
     is a quantifying suffix operator similar to `*', except that the
     preceding expression can match either once or not at all.  For
     example, `ca?r' matches `car' or `cr', but does not match anything
     else.

`*?'
     works just like `*', except that rather than matching the longest
     match, it matches the shortest match.  `*?' is known as a
     "non-greedy" quantifier, a regexp construct borrowed from Perl.

     This construct is very useful for when you want to match the text
     inside a pair of delimiters.  For instance, `/\*.*?\*/' will match
     C comments in a string.  This could not easily be achieved without
     the use of a non-greedy quantifier.

     This construct has not been available prior to XEmacs 20.4.  It is
     not available in FSF Emacs.

`+?'
     is the non-greedy version of `+'.

`??'
     is the non-greedy version of `?'.

`\{n,m\}'
     serves as an interval quantifier, analogous to `*' or `+', but
     specifies that the expression must match at least N times, but no
     more than M times.  This syntax is supported by most Unix regexp
     utilities, and has been introduced to XEmacs for the version 20.3.

     Unfortunately, the non-greedy version of this quantifier does not
     exist currently, although it does in Perl.

`[ ... ]'
     `[' begins a "character set", which is terminated by a `]'.  In
     the simplest case, the characters between the two brackets form
     the set.  Thus, `[ad]' matches either one `a' or one `d', and
     `[ad]*' matches any string composed of just `a's and `d's
     (including the empty string), from which it follows that `c[ad]*r'
     matches `cr', `car', `cdr', `caddaar', etc.

     The usual regular expression special characters are not special
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     `-' is used for ranges of characters.  To write a range, write two
     characters with a `-' between them.  Thus, `[a-z]' matches any
     lower case letter.  Ranges may be intermixed freely with individual
     characters, as in `[a-z$%.]', which matches any lower case letter
     or `$', `%', or a period.

     To include a `]' in a character set, make it the first character.
     For example, `[]a]' matches `]' or `a'.  To include a `-', write
     `-' as the first character in the set, or put it immediately after
     a range.  (You can replace one individual character C with the
     range `C-C' to make a place to put the `-'.)  There is no way to
     write a set containing just `-' and `]'.

     To include `^' in a set, put it anywhere but at the beginning of
     the set.

`[^ ... ]'
     `[^' begins a "complement character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters _except_ letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (thus, `-' and `]' are not special there).

     Note that a complement character set can match a newline, unless
     newline is mentioned as one of the characters not to match.

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' that occurs
     at the beginning of a line.

     When matching a string instead of a buffer, `^' matches at the
     beginning of the string or after a newline character `\n'.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `x+$' matches a string of one `x' or more at the end of a line.

     When matching a string instead of a buffer, `$' matches at the end
     of the string or before a newline character `\n'.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression that matches only `$', and `\[' is a regular expression
     that matches only `[', and so on.


   *Please note:* For historical compatibility, special characters are
treated as ordinary ones if they are in contexts where their special
meanings make no sense.  For example, `*foo' treats `*' as ordinary
since there is no preceding expression on which the `*' can act.  It is
poor practice to depend on this behavior; quote the special character
anyway, regardless of where it appears.

   For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: characters that,
when preceded by `\', are special constructs.  Such characters are
always ordinary when encountered on their own.  Here is a table of `\'
constructs:

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches anything that
     either A or B matches.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose an expression for a suffix operator such as `*' to
          act on.  Thus, `ba\(na\)*' matches `bananana', etc., with any
          (zero or more) number of `na' strings.

       3. To record a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that happens to be
     assigned as a second meaning to the same `\( ... \)' construct
     because there is no conflict in practice between the two meanings.
     Here is an explanation of this feature:

`\DIGIT'
     matches the same text that matched the DIGITth occurrence of a `\(
     ... \)' construct.

     In other words, after the end of a `\( ... \)' construct.  the
     matcher remembers the beginning and end of the text matched by that
     construct.  Then, later on in the regular expression, you can use
     `\' followed by DIGIT to match that same text, whatever it may
     have been.

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in the order that the open parentheses appear in the regular
     expression.  So you can use `\1' through `\9' to refer to the text
     matched by the corresponding `\( ... \)' constructs.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

`\(?: ... \)'
     is called a "shy" grouping operator, and it is used just like `\(
     ... \)', except that it does not cause the matched substring to be
     recorded for future reference.

     This is useful when you need a lot of grouping `\( ... \)'
     constructs, but only want to remember one or two - or if you have
     more than nine groupings and need to use backreferences to refer to
     the groupings at the end.

     Using `\(?: ... \)' rather than `\( ... \)' when you don't need
     the captured substrings ought to speed up your programs some,
     since it shortens the code path followed by the regular expression
     engine, as well as the amount of memory allocation and string
     copying it must do.  The actual performance gain to be observed
     has not been measured or quantified as of this writing.

     The shy grouping operator has been borrowed from Perl, and has not
     been available prior to XEmacs 20.3, nor is it available in FSF
     Emacs.

`\w'
     matches any word-constituent character.  The editor syntax table
     determines which characters these are.  *Note Syntax::.

`\W'
     matches any character that is not a word constituent.

`\sCODE'
     matches any character whose syntax is CODE.  Here CODE is a
     character that represents a syntax code: thus, `w' for word
     constituent, `-' for whitespace, `(' for open parenthesis, etc.
     *Note Syntax::, for a list of syntax codes and the characters that
     stand for them.

`\SCODE'
     matches any character whose syntax is not CODE.

   The following regular expression constructs match the empty
string--that is, they don't use up any characters--but whether they
match depends on the context.

`\`'
     matches the empty string, but only at the beginning of the buffer
     or string being matched against.

`\''
     matches the empty string, but only at the end of the buffer or
     string being matched against.

`\='
     matches the empty string, but only at point.  (This construct is
     not defined when matching against a string.)

`\b'
     matches the empty string, but only at the beginning or end of a
     word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

`\B'
     matches the empty string, but _not_ at the beginning or end of a
     word.

`\<'
     matches the empty string, but only at the beginning of a word.

`\>'
     matches the empty string, but only at the end of a word.

   Here is a complicated regexp used by Emacs to recognize the end of a
sentence together with any whitespace that follows.  It is given in Lisp
syntax to enable you to distinguish the spaces from the tab characters.
In Lisp syntax, the string constant begins and ends with a
double-quote.  `\"' stands for a double-quote as part of the regexp,
`\\' for a backslash as part of the regexp, `\t' for a tab and `\n' for
a newline.

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This regexp contains four parts: a character set matching period, `?'
or `!'; a character set matching close-brackets, quotes or parentheses,
repeated any number of times; an alternative in backslash-parentheses
that matches end-of-line, a tab or two spaces; and a character set
matching whitespace characters, repeated any number of times.


File: xemacs.info,  Node: Search Case,  Next: Replace,  Prev: Regexps,  Up: Search

Searching and Case
==================

All searches in Emacs normally ignore the case of the text they are
searching through; if you specify searching for `FOO', `Foo' and `foo'
are also considered a match.  Regexps, and in particular character
sets, are included: `[aB]' matches `a' or `A' or `b' or `B'.

   If you want a case-sensitive search, set the variable
`case-fold-search' to `nil'.  Then all letters must match exactly,
including case. `case-fold-search' is a per-buffer variable; altering
it affects only the current buffer, but there is a default value which
you can change as well.  *Note Locals::.  You can also use Case
Sensitive Search from the Options menu on your screen.


File: xemacs.info,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

Replacement Commands
====================

Global search-and-replace operations are not needed as often in Emacs as
they are in other editors, but they are available.  In addition to the
simple `replace-string' command which is like that found in most
editors, there is a `query-replace' command which asks you, for each
occurrence of a pattern, whether to replace it.

   The replace commands all replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs'.  *Note Expanding
Abbrevs::.

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: xemacs.info,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

Unconditional Replacement
-------------------------

`M-x replace-string <RET> STRING <RET> NEWSTRING <RET>'
     Replace every occurrence of STRING with NEWSTRING.

`M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace every match for REGEXP with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement occurs only after point: if you want to cover the whole
buffer you must go to the beginning first.  By default, all occurrences
up to the end of the buffer are replaced.  To limit replacement to part
of the buffer, narrow to that part of the buffer before doing the
replacement (*note Narrowing::).

   When `replace-string' exits, point is left at the last occurrence
replaced.  The value of point when the `replace-string' command was
issued is remembered on the mark ring; `C-u C-<SPC>' moves back there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.


File: xemacs.info,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

Regexp Replacement
------------------

`replace-string' replaces exact matches for a single string.  The
similar command `replace-regexp' replaces any match for a specified
pattern.

   In `replace-regexp', the NEWSTRING need not be constant.  It can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire text being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the D'th
parenthesized grouping in REGEXP.  For example,

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

would replace (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

would perform exactly the opposite replacements.  To include a `\' in
the text to replace with, you must give `\\'.

