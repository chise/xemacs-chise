This is ../info/lispref.info, produced by makeinfo version 4.0 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Pop-Up Menus,  Next: Menu Filters,  Prev: Modifying Menus,  Up: Menus

Pop-Up Menus
============

 - Function: popup-menu menu-desc
     This function pops up a menu specified by MENU-DESC, which is a
     menu description (*note Menu Format::).  The menu is displayed at
     the current mouse position.

 - Function: popup-menu-up-p
     This function returns `t' if a pop-up menu is up, `nil' otherwise.

 - Variable: popup-menu-titles
     If true (the default), pop-up menus will have title bars at the
     top.

   Some machinery is provided that attempts to provide a higher-level
mechanism onto pop-up menus.  This only works if you do not redefine
the binding for button3.

 - Command: popup-mode-menu
     This function pops up a menu of global and mode-specific commands.
     The menu is computed by combining `global-popup-menu' and
     `mode-popup-menu'.  This is the default binding for button3.  You
     should generally not change this binding.

 - Variable: global-popup-menu
     This holds the global popup menu.  This is present in all modes.
     (This is `nil' by default.)

 - Variable: mode-popup-menu
     The mode-specific popup menu.  Automatically buffer local.  This
     is appended to the default items in `global-popup-menu'.

 - Constant: default-popup-menu
     This holds the default value of `mode-popup-menu'.

 - Variable: activate-popup-menu-hook
     Function or functions run before a mode-specific popup menu is made
     visible.  These functions are called with no arguments, and should
     interrogate and modify the value of `global-popup-menu' or
     `mode-popup-menu' as desired.  Note: this hook is only run if you
     use `popup-mode-menu' for activating the global and mode-specific
     commands; if you have your own binding for button3, this hook
     won't be run.

   The following convenience functions are provided for displaying
pop-up menus.

 - Function: popup-buffer-menu event
     This function pops up a copy of the `Buffers' menu (from the
     menubar) where the mouse is clicked.

 - Function: popup-menubar-menu event
     This function pops up a copy of menu that also appears in the
     menubar.


File: lispref.info,  Node: Menu Accelerators,  Next: Buffers Menu,  Prev: Menu Filters,  Up: Menus

Menu Accelerators
=================

   Menu accelerators are keyboard shortcuts for accessing the menubar.
Accelerator keys can be specified for menus as well as for menu items.
An accelerator key for a menu is used to activate that menu when it
appears as a submenu of another menu.  An accelerator key for a menu
item is used to activate that item.

* Menu:

* Creating Menu Accelerators::  How to add accelerator keys to a menu.
* Keyboard Menu Traversal::     How to use and modify the keys which are used
                                to traverse the menu structure.
* Menu Accelerator Functions::  Functions for working with menu accelerators.


File: lispref.info,  Node: Creating Menu Accelerators,  Next: Keyboard Menu Traversal,  Up: Menu Accelerators

Creating Menu Accelerators
--------------------------

   Menu accelerators are specified as part of the menubar format using
the :accelerator tag to specify a key or by placing "%_" in the menu or
menu item name prior to the letter which is to be used as the
accelerator key.  The advantage of the second method is that the menu
rendering code then knows to draw an underline under that character,
which is the canonical way of indicating an accelerator key to a user.

   For example, the command

     (add-submenu nil '("%_Test"
                        ["One" (insert "1") :accelerator ?1 :active t]
                        ["%_Two" (insert "2")]
                        ["%_3" (insert "3")]))

   will add a new menu to the top level menubar.  The new menu can be
reached by pressing "t" while the top level menubar is active.  When
the menu is active, pressing "1" will activate the first item and
insert the character "1" into the buffer.  Pressing "2" will activate
the second item and insert the character "2" into the buffer.  Pressing
"3" will activate the third item and insert the character "3" into the
buffer.

   It is possible to activate the top level menubar itself using
accelerator keys.  *Note Menu Accelerator Functions::.


File: lispref.info,  Node: Keyboard Menu Traversal,  Next: Menu Accelerator Functions,  Prev: Creating Menu Accelerators,  Up: Menu Accelerators

Keyboard Menu Traversal
-----------------------

   In addition to immediately activating a menu or menu item, the
keyboard can be used to traverse the menus without activating items.
The keyboard arrow keys, the return key and the escape key are defined
to traverse the menus in a way that should be familiar to users of any
of a certain family of popular PC operating systems.

   This behavior can be changed by modifying the bindings in
menu-accelerator-map.  At this point, the online help is your best bet
for more information about how to modify the menu traversal keys.


File: lispref.info,  Node: Menu Accelerator Functions,  Prev: Keyboard Menu Traversal,  Up: Menu Accelerators

Menu Accelerator Functions
--------------------------

 - Function: accelerate-menu
     Make the menubar immediately active and place the cursor on the
     left most entry in the top level menu.  Menu items can be selected
     as usual.

 - Variable: menu-accelerator-enabled
     Whether menu accelerator keys can cause the menubar to become
     active.

     If `menu-force' or `menu-fallback', then menu accelerator keys can
     be used to activate the top level menu.  Once the menubar becomes
     active, the accelerator keys can be used regardless of the value
     of this variable.

     `menu-force' is used to indicate that the menu accelerator key
     takes precedence over bindings in the current keymap(s).
     `menu-fallback' means that bindings in the current keymap take
     precedence over menu accelerator keys.  Thus a top level menu with
     an accelerator of "T" would be activated on a keypress of Meta-t
     if MENU-ACCELERATOR-ENABLED is `menu-force'.  However, if
     MENU-ACCELERATOR-ENABLED is `menu-fallback', then Meta-t will not
     activate the menubar and will instead run the function
     transpose-words, to which it is normally bound.

     The default value is `nil'.

     See also MENU-ACCELERATOR-MODIFIERS and MENU-ACCELERATOR-PREFIX.

 - Variable: menu-accelerator-map
     Keymap consulted to determine the commands to run in response to
     keypresses occurring while the menubar is active.  *Note Keyboard
     Menu Traversal::.

 - Variable: menu-accelerator-modifiers
     A list of modifier keys which must be pressed in addition to a
     valid menu accelerator in order for the top level menu to be
     activated in response to a keystroke.  The default value of
     `(meta)' mirrors the usage of the alt key as a menu accelerator in
     popular PC operating systems.

     The modifier keys in MENU-ACCELERATOR-MODIFIERS must match exactly
     the modifiers present in the keypress.  The only exception is that
     the shift modifier is accepted in conjunction with alphabetic keys
     even if it is not a menu accelerator modifier.

     See also MENU-ACCELERATOR-ENABLED and MENU-ACCELERATOR-PREFIX.

 - Variable: menu-accelerator-prefix
     Prefix key(s) that must be typed before menu accelerators will be
     activated.  Must be a valid key descriptor.

     The default value is `nil'.

     (setq menu-accelerator-prefix ?\C-x)
     (setq menu-accelerator-modifiers '(meta control))
     (setq menu-accelerator-enabled 'menu-force)
     (add-submenu nil '("%_Test"
                        ["One" (insert "1") :accelerator ?1 :active t]
                        ["%_Two" (insert "2")]
                        ["%_3" (insert "3")]))

   will add the menu "Test" to the top level menubar.  Pressing C-x
followed by C-M-T will activate the menubar and display the "Test"
menu.  Pressing C-M-T by itself will not activate the menubar.  Neither
will pressing C-x followed by anything else.


File: lispref.info,  Node: Buffers Menu,  Prev: Menu Accelerators,  Up: Menus

Buffers Menu
============

   The following options control how the `Buffers' menu is displayed.
This is a list of all (or a subset of) the buffers currently in
existence, and is updated dynamically.

 - User Option: buffers-menu-max-size
     This user option holds the maximum number of entries which may
     appear on the `Buffers' menu.  If this is 10, then only the ten
     most-recently-selected buffers will be shown.  If this is `nil',
     then all buffers will be shown.  Setting this to a large number or
     `nil' will slow down menu responsiveness.

 - Function: format-buffers-menu-line buffer
     This function returns a string to represent BUFFER in the
     `Buffers' menu.  `nil' means the buffer shouldn't be listed.  You
     can redefine this.

 - User Option: complex-buffers-menu-p
     If true, the `Buffers' menu will contain several commands, as
     submenus of each buffer line.  If this is false, then there will
     be only one command: select that buffer.

 - User Option: buffers-menu-switch-to-buffer-function
     This user option holds the function to call to select a buffer
     from the `Buffers' menu.  `switch-to-buffer' is a good choice, as
     is `pop-to-buffer'.


File: lispref.info,  Node: Dialog Boxes,  Next: Toolbar,  Prev: Menus,  Up: Top

Dialog Boxes
************

* Menu:

* Dialog Box Format::
* Dialog Box Functions::


File: lispref.info,  Node: Dialog Box Format,  Next: Dialog Box Functions,  Up: Dialog Boxes

Dialog Box Format
=================

   A dialog box description is a list.

   * The first element of the list is a string to display in the dialog
     box.

   * The rest of the elements are descriptions of the dialog box's
     buttons.  Each one is a vector of three elements:
        - The first element is the text of the button.

        - The second element is the "callback".

        - The third element is `t' or `nil', whether this button is
          selectable.

   If the callback of a button is a symbol, then it must name a command.
It will be invoked with `call-interactively'.  If it is a list, then it
is evaluated with `eval'.

   One (and only one) of the buttons may be `nil'.  This marker means
that all following buttons should be flushright instead of flushleft.

   The syntax, more precisely:

        form         :=  <something to pass to `eval'>
        command      :=  <a symbol or string, to pass to `call-interactively'>
        callback     :=  command | form
        active-p     :=  <t, nil, or a form to evaluate to decide whether this
                         button should be selectable>
        name         :=  <string>
        partition    :=  'nil'
        button       :=  '['  name callback active-p ']'
        dialog       :=  '(' name [ button ]+ [ partition [ button ]+ ] ')'


File: lispref.info,  Node: Dialog Box Functions,  Prev: Dialog Box Format,  Up: Dialog Boxes

Dialog Box Functions
====================

 - Function: popup-dialog-box dbox-desc
     This function pops up a dialog box.  DBOX-DESC describes how the
     dialog box will appear (*note Dialog Box Format::).

   *Note Yes-or-No Queries::, for functions to ask a yes/no question
using a dialog box.


File: lispref.info,  Node: Toolbar,  Next: Gutter,  Prev: Dialog Boxes,  Up: Top

Toolbar
*******

* Menu:

* Toolbar Intro::		An introduction.
* Creating Toolbar::            How to create a toolbar.
* Toolbar Descriptor Format::	Accessing and modifying a toolbar's
                                  properties.
* Specifying the Toolbar::	Setting a toolbar's contents.
* Other Toolbar Variables::	Controlling the size of toolbars.


File: lispref.info,  Node: Toolbar Intro,  Next: Creating Toolbar,  Up: Toolbar

Toolbar Intro
=============

   A "toolbar" is a bar of icons displayed along one edge of a frame.
You can view a toolbar as a series of menu shortcuts--the most common
menu options can be accessed with a single click rather than a series
of clicks and/or drags to select the option from a menu.  Consistent
with this, a help string (called the "help-echo") describing what an
icon in the toolbar (called a "toolbar button") does, is displayed in
the minibuffer when the mouse is over the button.

   In XEmacs, a toolbar can be displayed along any of the four edges of
the frame, and two or more different edges can be displaying toolbars
simultaneously.  The contents, thickness, and visibility of the
toolbars can be controlled separately, and the values can be
per-buffer, per-frame, etc., using specifiers (*note Specifiers::).

   Normally, there is one toolbar displayed in a frame.  Usually, this
is the standard toolbar, but certain modes will override this and
substitute their own toolbar.  In some cases (e.g. the VM package), a
package will supply its own toolbar along a different edge from the
standard toolbar, so that both can be visible at once.  This standard
toolbar is usually positioned along the top of the frame, but this can
be changed using `set-default-toolbar-position'.

   Note that, for each of the toolbar properties (contents, thickness,
and visibility), there is a separate specifier for each of the four
toolbar positions (top, bottom, left, and right), and an additional
specifier for the "default" toolbar, i.e. the toolbar whose position is
controlled by `set-default-toolbar-position'.  The way this works is
that `set-default-toolbar-position' arranges things so that the
appropriate position-specific specifiers for the default position
inherit from the corresponding default specifiers.  That way, if the
position-specific specifier does not give a value (which it usually
doesn't), then the value from the default specifier applies.  If you
want to control the default toolbar, you just change the default
specifiers, and everything works.  A package such as VM that wants to
put its own toolbar in a different location from the default just sets
the position-specific specifiers, and if the user sets the default
toolbar to the same position, it will just not be visible.


File: lispref.info,  Node: Creating Toolbar,  Next: Toolbar Descriptor Format,  Prev: Toolbar Intro,  Up: Toolbar

Creating Toolbar
================

 - Function: make-toolbar-specifier spec-list
     Return a new `toolbar' specifier object with the given
     specification list.  SPEC-LIST can be a list of specifications
     (each of which is a cons of a locale and a list of instantiators),
     a single instantiator, or a list of instantiators.  *Note
     Specifiers::, for more information about specifiers.

     Toolbar specifiers are used to specify the format of a toolbar.
     The values of the variables `default-toolbar', `top-toolbar',
     `left-toolbar', `right-toolbar', and `bottom-toolbar' are always
     toolbar specifiers.

     Valid toolbar instantiators are called "toolbar descriptors" and
     are lists of vectors.  See `default-toolbar' for a description of
     the exact format.


File: lispref.info,  Node: Toolbar Descriptor Format,  Next: Specifying the Toolbar,  Prev: Creating Toolbar,  Up: Toolbar

Toolbar Descriptor Format
=========================

   The contents of a toolbar are specified using a "toolbar descriptor".
The format of a toolbar descriptor is a list of "toolbar button
descriptors".  Each toolbar button descriptor is a vector in one of the
following formats:

   * `[GLYPH-LIST FUNCTION ENABLED-P HELP]'

   * `[:style 2D-OR-3D]'

   * `[:style 2D-OR-3D :size WIDTH-OR-HEIGHT]'

   * `[:size WIDTH-OR-HEIGHT :style 2D-OR-3D]'

   Optionally, one of the toolbar button descriptors may be `nil'
instead of a vector; this signifies the division between the toolbar
buttons that are to be displayed flush-left, and the buttons to be
displayed flush-right.

   The first vector format above specifies a normal toolbar button; the
others specify blank areas in the toolbar.

   For the first vector format:

   * GLYPH-LIST should be a list of one to six glyphs (as created by
     `make-glyph') or a symbol whose value is such a list.  The first
     glyph, which must be provided, is the glyph used to display the
     toolbar button when it is in the "up" (not pressed) state.  The
     optional second glyph is for displaying the button when it is in
     the "down" (pressed) state.  The optional third glyph is for when
     the button is disabled.  The last three glyphs are for displaying
     the button in the "up", "down", and "disabled" states,
     respectively, but are used when the user has called for captioned
     toolbar buttons (using `toolbar-buttons-captioned-p').  The
     function `toolbar-make-button-list' is useful in creating these
     glyph lists.

   * Even if you do not provide separate down-state and disabled-state
     glyphs, the user will still get visual feedback to indicate which
     state the button is in.  Buttons in the up-state are displayed
     with a shadowed border that gives a raised appearance to the
     button.  Buttons in the down-state are displayed with shadows that
     give a recessed appearance.  Buttons in the disabled state are
     displayed with no shadows, giving a 2-d effect.

   * If some of the toolbar glyphs are not provided, they inherit as
     follows:

               UP:                up
               DOWN:              down -> up
               DISABLED:          disabled -> up
               CAP-UP:            cap-up -> up
               CAP-DOWN:          cap-down -> cap-up -> down -> up
               CAP-DISABLED:      cap-disabled -> cap-up -> disabled -> up

   * The second element FUNCTION is a function to be called when the
     toolbar button is activated (i.e. when the mouse is released over
     the toolbar button, if the press occurred in the toolbar).  It can
     be any form accepted by `call-interactively', since this is how it
     is invoked.

   * The third element ENABLED-P specifies whether the toolbar button
     is enabled (disabled buttons do nothing when they are activated,
     and are displayed differently; see above).  It should be either a
     boolean or a form that evaluates to a boolean.

   * The fourth element HELP, if non-`nil', should be a string.  This
     string is displayed in the echo area when the mouse passes over the
     toolbar button.

   For the other vector formats (specifying blank areas of the toolbar):

   * 2D-OR-3D should be one of the symbols `2d' or `3d', indicating
     whether the area is displayed with shadows (giving it a raised,
     3-d appearance) or without shadows (giving it a flat appearance).

   * WIDTH-OR-HEIGHT specifies the length, in pixels, of the blank
     area.  If omitted, it defaults to a device-specific value (8
     pixels for X devices).

 - Function: toolbar-make-button-list up &optional down disabled cap-up
          cap-down cap-disabled
     This function calls `make-glyph' on each arg and returns a list of
     the results.  This is useful for setting the first argument of a
     toolbar button descriptor (typically, the result of this function
     is assigned to a symbol, which is specified as the first argument
     of the toolbar button descriptor).

 - Function: check-toolbar-button-syntax button &optional noerror
     Verify the syntax of entry BUTTON in a toolbar description list.
     If you want to verify the syntax of a toolbar description list as a
     whole, use `check-valid-instantiator' with a specifier type of
     `toolbar'.


File: lispref.info,  Node: Specifying the Toolbar,  Next: Other Toolbar Variables,  Prev: Toolbar Descriptor Format,  Up: Toolbar

Specifying the Toolbar
======================

   In order to specify the contents of a toolbar, set one of the
specifier variables `default-toolbar', `top-toolbar', `bottom-toolbar',
`left-toolbar', or `right-toolbar'.  These are specifiers, which means
you set them with `set-specifier' and query them with `specifier-specs'
or `specifier-instance'.  You will get an error if you try to set them
using `setq'.  The valid instantiators for these specifiers are toolbar
descriptors, as described above.  *Note Specifiers::, for more
information.

   Most of the time, you will set `default-toolbar', which allows the
user to choose where the toolbar should go.

 - Specifier: default-toolbar
     The position of this toolbar is specified in the function
     `default-toolbar-position'.  If the corresponding
     position-specific toolbar (e.g. `top-toolbar' if
     `default-toolbar-position' is `top') does not specify a toolbar in
     a particular domain, then the value of `default-toolbar' in that
     domain, of any, will be used instead.

   Note that the toolbar at any particular position will not be
displayed unless its thickness (width or height, depending on
orientation) is non-zero and its visibility status is true.  The
thickness is controlled by the specifiers `top-toolbar-height',
`bottom-toolbar-height', `left-toolbar-width', and
`right-toolbar-width', and the visibility status is controlled by the
specifiers `top-toolbar-visible-p', `bottom-toolbar-visible-p',
`left-toolbar-visible-p', and `right-toolbar-visible-p' (*note Other
Toolbar Variables::).

 - Function: set-default-toolbar-position position
     This function sets the position that the `default-toolbar' will be
     displayed at.  Valid positions are the symbols `top', `bottom',
     `left' and `right'.  What this actually does is set the fallback
     specifier for the position-specific specifier corresponding to the
     given position to `default-toolbar', and set the fallbacks for the
     other position-specific specifiers to `nil'.  It also does the
     same thing for the position-specific thickness and visibility
     specifiers, which inherit from one of `default-toolbar-height' or
     `default-toolbar-width', and from `default-toolbar-visible-p',
     respectively (*note Other Toolbar Variables::).

 - Function: default-toolbar-position
     This function returns the position that the `default-toolbar' will
     be displayed at.

   You can also explicitly set a toolbar at a particular position.  When
redisplay determines what to display at a particular position in a
particular domain (i.e. window), it first consults the position-specific
toolbar.  If that does not yield a toolbar descriptor, the
`default-toolbar' is consulted if `default-toolbar-position' indicates
this position.

 - Specifier: top-toolbar
     Specifier for the toolbar at the top of the frame.

 - Specifier: bottom-toolbar
     Specifier for the toolbar at the bottom of the frame.

 - Specifier: left-toolbar
     Specifier for the toolbar at the left edge of the frame.

 - Specifier: right-toolbar
     Specifier for the toolbar at the right edge of the frame.

 - Function: toolbar-specifier-p object
     This function returns non-nil if OBJECT is a toolbar specifier.
     Toolbar specifiers are the actual objects contained in the toolbar
     variables described above, and their valid instantiators are
     toolbar descriptors (*note Toolbar Descriptor Format::).


File: lispref.info,  Node: Other Toolbar Variables,  Prev: Specifying the Toolbar,  Up: Toolbar

Other Toolbar Variables
=======================

   The variables to control the toolbar thickness, visibility status,
and captioned status are all specifiers.  *Note Specifiers::.

 - Specifier: default-toolbar-height
     This specifies the height of the default toolbar, if it's oriented
     horizontally.  The position of the default toolbar is specified by
     the function `set-default-toolbar-position'.  If the corresponding
     position-specific toolbar thickness specifier (e.g.
     `top-toolbar-height' if `default-toolbar-position' is `top') does
     not specify a thickness in a particular domain (a window or a
     frame), then the value of `default-toolbar-height' or
     `default-toolbar-width' (depending on the toolbar orientation) in
     that domain, if any, will be used instead.

 - Specifier: default-toolbar-width
     This specifies the width of the default toolbar, if it's oriented
     vertically.  This behaves like `default-toolbar-height'.

   Note that `default-toolbar-height' is only used when
`default-toolbar-position' is `top' or `bottom', and
`default-toolbar-width' is only used when `default-toolbar-position' is
`left' or `right'.

 - Specifier: top-toolbar-height
     This specifies the height of the top toolbar.

 - Specifier: bottom-toolbar-height
     This specifies the height of the bottom toolbar.

 - Specifier: left-toolbar-width
     This specifies the width of the left toolbar.

 - Specifier: right-toolbar-width
     This specifies the width of the right toolbar.

   Note that all of the position-specific toolbar thickness specifiers
have a fallback value of zero when they do not correspond to the
default toolbar.  Therefore, you will have to set a non-zero thickness
value if you want a position-specific toolbar to be displayed.

 - Specifier: default-toolbar-visible-p
     This specifies whether the default toolbar is visible.  The
     position of the default toolbar is specified by the function
     `set-default-toolbar-position'.  If the corresponding
     position-specific toolbar visibility specifier (e.g.
     `top-toolbar-visible-p' if `default-toolbar-position' is `top')
     does not specify a visible-p value in a particular domain (a
     window or a frame), then the value of `default-toolbar-visible-p'
     in that domain, if any, will be used instead.

 - Specifier: top-toolbar-visible-p
     This specifies whether the top toolbar is visible.

 - Specifier: bottom-toolbar-visible-p
     This specifies whether the bottom toolbar is visible.

 - Specifier: left-toolbar-visible-p
     This specifies whether the left toolbar is visible.

 - Specifier: right-toolbar-visible-p
     This specifies whether the right toolbar is visible.

   `default-toolbar-visible-p' and all of the position-specific toolbar
visibility specifiers have a fallback value of true.

   Internally, toolbar thickness and visibility specifiers are
instantiated in both window and frame domains, for different purposes.
The value in the domain of a frame's selected window specifies the
actual toolbar thickness or visibility that you will see in that frame.
The value in the domain of a frame itself specifies the toolbar
thickness or visibility that is used in frame geometry calculations.

   Thus, for example, if you set the frame width to 80 characters and
the left toolbar width for that frame to 68 pixels, then the frame will
be sized to fit 80 characters plus a 68-pixel left toolbar.  If you then
set the left toolbar width to 0 for a particular buffer (or if that
buffer does not specify a left toolbar or has a nil value specified for
`left-toolbar-visible-p'), you will find that, when that buffer is
displayed in the selected window, the window will have a width of 86 or
87 characters--the frame is sized for a 68-pixel left toolbar but the
selected window specifies that the left toolbar is not visible, so it is
expanded to take up the slack.

 - Specifier: toolbar-buttons-captioned-p
     Whether toolbar buttons are captioned.  This affects which glyphs
     from a toolbar button descriptor are chosen.  *Note Toolbar
     Descriptor Format::.

   You can also reset the toolbar to what it was when XEmacs started up.

 - Constant: initial-toolbar-spec
     The toolbar descriptor used to initialize `default-toolbar' at
     startup.


File: lispref.info,  Node: Gutter,  Next: Scrollbars,  Prev: Toolbar,  Up: Top

Gutter
******

   A gutter is a rectangle displayed along one edge of a frame.  It can
contain arbitrary text or graphics.

* Menu:

* Gutter Intro::		An introduction.
* Creating Gutter::             How to create a gutter.
* Gutter Descriptor Format::	Accessing and modifying a gutter's
                                  properties.
* Specifying a Gutter::		Setting a gutter's contents.
* Other Gutter Variables::	Controlling the size of gutters.
* Common Gutter Widgets::       Things to put in gutters.


File: lispref.info,  Node: Gutter Intro,  Next: Creating Gutter,  Prev: Gutter,  Up: Gutter

Gutter Intro
============

   A "gutter" is a rectangle displayed along one edge of a frame.  It
can contain arbitrary text or graphics.  It could be considered a
generalization of a toolbar, although toolbars are not currently
implemented using gutters.

   In XEmacs, a gutter can be displayed along any of the four edges of
the frame, and two or more different edges can be displaying gutters
simultaneously.  The contents, thickness, and visibility of the gutters
can be controlled separately, and the values can be per-buffer,
per-frame, etc., using specifiers (*note Specifiers::).

   Normally, there is one gutter displayed in a frame.  Usually, this is
the default gutter, containing buffer tabs, but modes cab override this
and substitute their own gutter.  This default gutter is usually
positioned along the top of the frame, but this can be changed using
`set-default-gutter-position'.

   Note that, for each of the gutter properties (contents, thickness,
and visibility), there is a separate specifier for each of the four
gutter positions (top, bottom, left, and right), and an additional
specifier for the "default" gutter, i.e. the gutter whose position is
controlled by `set-default-gutter-position'.  The way this works is
that `set-default-gutter-position' arranges things so that the
appropriate position-specific specifiers for the default position
inherit from the corresponding default specifiers.  That way, if the
position-specific specifier does not give a value (which it usually
doesn't), then the value from the default specifier applies.  If you
want to control the default gutter, you just change the default
specifiers, and everything works.  A package such as VM that wants to
put its own gutter in a different location from the default just sets
the position-specific specifiers, and if the user sets the default
gutter to the same position, it will just not be visible.


File: lispref.info,  Node: Creating Gutter,  Next: Gutter Descriptor Format,  Prev: Gutter Intro,  Up: Gutter

Creating Gutter
===============

 - Function: make-gutter-specifier spec-list
     Return a new `gutter' specifier object with the given specification
     list.  SPEC-LIST can be a list of specifications (each of which is
     a cons of a locale and a list of instantiators), a single
     instantiator, or a list of instantiators.  *Note Specifiers::, for
     more information about specifiers.

     Gutter specifiers are used to specify the format of a gutter.  The
     values of the variables `default-gutter', `top-gutter',
     `left-gutter', `right-gutter', and `bottom-gutter' are always
     gutter specifiers.

     Valid gutter instantiators are called "gutter descriptors" and are
     either strings or property-lists of strings.  See `default-gutter'
     for a description of the exact format.

 - Function: make-gutter-size-specifier spec-list
     Return a new `gutter-size' specifier object with the given spec
     list.  SPEC-LIST can be a list of specifications (each of which is
     a cons of a locale and a list of instantiators), a single
     instantiator, or a list of instantiators.  *Note Specifiers::, for
     more information about specifiers.

     Gutter-size specifiers are used to specify the size of a gutter.
     The values of the variables `default-gutter-size',
     `top-gutter-size', `left-gutter-size', `right-gutter-size', and
     `bottom-gutter-size' are always gutter-size specifiers.

     Valid gutter-size instantiators are either integers or the special
     symbol `autodetect'. If a gutter-size is set to `autodetect' them
     the size of the gutter will be adjusted to just accommodate the
     gutters contents. `autodetect' only works for top and bottom
     gutters.

 - Function: make-gutter-visible-specifier spec-list
     Return a new `gutter-visible' specifier object with the given spec
     list.  SPEC-LIST can be a list of specifications (each of which is
     a cons of a locale and a list of instantiators), a single
     instantiator, or a list of instantiators.  *Note Specifiers::, for
     more information about specifiers.

     Gutter-visible specifiers are used to specify the visibility of a
     gutter.  The values of the variables `default-gutter-visible-p',
     `top-gutter-visible-p', `left-gutter-visible-p',
     `right-gutter-visible-p', and `bottom-gutter-visible-p' are always
     gutter-visible specifiers.

     Valid gutter-visible instantiators are t, nil or a list of
     symbols.  If a gutter-visible instantiator is set to a list of
     symbols, and the corresponding gutter specification is a
     property-list strings, then elements of the gutter specification
     will only be visible if the corresponding symbol occurs in the
     gutter-visible instantiator.


File: lispref.info,  Node: Gutter Descriptor Format,  Next: Specifying a Gutter,  Prev: Creating Gutter,  Up: Gutter

Gutter Descriptor Format
========================

   The contents of a gutter are specified using a "gutter descriptor".
The format of a gutter descriptor is a list of "gutter button
descriptors".  Each gutter button descriptor is a vector in one of the
following formats:

   * `[GLYPH-LIST FUNCTION ENABLED-P HELP]'

   * `[:style 2D-OR-3D]'

   * `[:style 2D-OR-3D :size WIDTH-OR-HEIGHT]'

   * `[:size WIDTH-OR-HEIGHT :style 2D-OR-3D]'

   Optionally, one of the gutter button descriptors may be `nil'
instead of a vector; this signifies the division between the gutter
buttons that are to be displayed flush-left, and the buttons to be
displayed flush-right.

   The first vector format above specifies a normal gutter button; the
others specify blank areas in the gutter.

   For the first vector format:

   * GLYPH-LIST should be a list of one to six glyphs (as created by
     `make-glyph') or a symbol whose value is such a list.  The first
     glyph, which must be provided, is the glyph used to display the
     gutter button when it is in the "up" (not pressed) state.  The
     optional second glyph is for displaying the button when it is in
     the "down" (pressed) state.  The optional third glyph is for when
     the button is disabled.  The last three glyphs are for displaying
     the button in the "up", "down", and "disabled" states,
     respectively, but are used when the user has called for captioned
     gutter buttons (using `gutter-buttons-captioned-p').  The function
     `gutter-make-button-list' is useful in creating these glyph lists.

   * Even if you do not provide separate down-state and disabled-state
     glyphs, the user will still get visual feedback to indicate which
     state the button is in.  Buttons in the up-state are displayed
     with a shadowed border that gives a raised appearance to the
     button.  Buttons in the down-state are displayed with shadows that
     give a recessed appearance.  Buttons in the disabled state are
     displayed with no shadows, giving a 2-d effect.

   * If some of the gutter glyphs are not provided, they inherit as
     follows:

               UP:                up
               DOWN:              down -> up
               DISABLED:          disabled -> up
               CAP-UP:            cap-up -> up
               CAP-DOWN:          cap-down -> cap-up -> down -> up
               CAP-DISABLED:      cap-disabled -> cap-up -> disabled -> up

   * The second element FUNCTION is a function to be called when the
     gutter button is activated (i.e. when the mouse is released over
     the gutter button, if the press occurred in the gutter).  It can
     be any form accepted by `call-interactively', since this is how it
     is invoked.

   * The third element ENABLED-P specifies whether the gutter button is
     enabled (disabled buttons do nothing when they are activated, and
     are displayed differently; see above).  It should be either a
     boolean or a form that evaluates to a boolean.

   * The fourth element HELP, if non-`nil', should be a string.  This
     string is displayed in the echo area when the mouse passes over the
     gutter button.

   For the other vector formats (specifying blank areas of the gutter):

   * 2D-OR-3D should be one of the symbols `2d' or `3d', indicating
     whether the area is displayed with shadows (giving it a raised,
     3-d appearance) or without shadows (giving it a flat appearance).

   * WIDTH-OR-HEIGHT specifies the length, in pixels, of the blank
     area.  If omitted, it defaults to a device-specific value (8
     pixels for X devices).

 - Function: gutter-make-button-list up &optional down disabled cap-up
          cap-down cap-disabled
     This function calls `make-glyph' on each arg and returns a list of
     the results.  This is useful for setting the first argument of a
     gutter button descriptor (typically, the result of this function
     is assigned to a symbol, which is specified as the first argument
     of the gutter button descriptor).

 - Function: check-gutter-button-syntax button &optional noerror
     Verify the syntax of entry BUTTON in a gutter description list.
     If you want to verify the syntax of a gutter description list as a
     whole, use `check-valid-instantiator' with a specifier type of
     `gutter'.


File: lispref.info,  Node: Specifying a Gutter,  Next: Other Gutter Variables,  Prev: Gutter Descriptor Format,  Up: Gutter

Specifying a Gutter
===================

   In order to specify the contents of a gutter, set one of the
specifier variables `default-gutter', `top-gutter', `bottom-gutter',
`left-gutter', or `right-gutter'.  These are specifiers, which means
you set them with `set-specifier' and query them with `specifier-specs'
or `specifier-instance'.  You will get an error if you try to set them
using `setq'.  The valid instantiators for these specifiers are gutter
descriptors, as described above.  *Note Specifiers::, for more
information.

   Most of the time, you will set `default-gutter', which allows the
user to choose where the gutter should go.

 - Specifier: default-gutter
     The position of this gutter is specified in the function
     `default-gutter-position'.  If the corresponding position-specific
     gutter (e.g. `top-gutter' if `default-gutter-position' is `top')
     does not specify a gutter in a particular domain, then the value
     of `default-gutter' in that domain, of any, will be used instead.

   Note that the gutter at any particular position will not be displayed
unless its thickness (width or height, depending on orientation) is
non-zero and its visibility status is true.  The thickness is controlled
by the specifiers `top-gutter-height', `bottom-gutter-height',
`left-gutter-width', and `right-gutter-width', and the visibility
status is controlled by the specifiers `top-gutter-visible-p',
`bottom-gutter-visible-p', `left-gutter-visible-p', and
`right-gutter-visible-p' (*note Other Gutter Variables::).

 - Function: set-default-gutter-position position
     This function sets the position that the `default-gutter' will be
     displayed at.  Valid positions are the symbols `top', `bottom',
     `left' and `right'.  What this actually does is set the fallback
     specifier for the position-specific specifier corresponding to the
     given position to `default-gutter', and set the fallbacks for the
     other position-specific specifiers to `nil'.  It also does the
     same thing for the position-specific thickness and visibility
     specifiers, which inherit from one of `default-gutter-height' or
     `default-gutter-width', and from `default-gutter-visible-p',
     respectively (*note Other Gutter Variables::).

 - Function: default-gutter-position
     This function returns the position that the `default-gutter' will
     be displayed at.

   You can also explicitly set a gutter at a particular position.  When
redisplay determines what to display at a particular position in a
particular domain (i.e. window), it first consults the position-specific
gutter.  If that does not yield a gutter descriptor, the
`default-gutter' is consulted if `default-gutter-position' indicates
this position.

 - Specifier: top-gutter
     Specifier for the gutter at the top of the frame.

 - Specifier: bottom-gutter
     Specifier for the gutter at the bottom of the frame.

 - Specifier: left-gutter
     Specifier for the gutter at the left edge of the frame.

 - Specifier: right-gutter
     Specifier for the gutter at the right edge of the frame.

 - Function: gutter-specifier-p object
     This function returns non-nil if OBJECT is a gutter specifier.
     Gutter specifiers are the actual objects contained in the gutter
     variables described above, and their valid instantiators are
     gutter descriptors (*note Gutter Descriptor Format::).


File: lispref.info,  Node: Other Gutter Variables,  Next: Common Gutter Widgets,  Prev: Specifying a Gutter,  Up: Gutter

Other Gutter Variables
======================

   The variables to control the gutter thickness, visibility status, and
captioned status are all specifiers.  *Note Specifiers::.

 - Specifier: default-gutter-height
     This specifies the height of the default gutter, if it's oriented
     horizontally.  The position of the default gutter is specified by
     the function `set-default-gutter-position'.  If the corresponding
     position-specific gutter thickness specifier (e.g.
     `top-gutter-height' if `default-gutter-position' is `top') does
     not specify a thickness in a particular domain (a window or a
     frame), then the value of `default-gutter-height' or
     `default-gutter-width' (depending on the gutter orientation) in
     that domain, if any, will be used instead.

 - Specifier: default-gutter-width
     This specifies the width of the default gutter, if it's oriented
     vertically.  This behaves like `default-gutter-height'.

   Note that `default-gutter-height' is only used when
`default-gutter-position' is `top' or `bottom', and
`default-gutter-width' is only used when `default-gutter-position' is
`left' or `right'.

 - Specifier: top-gutter-height
     This specifies the height of the top gutter.

 - Specifier: bottom-gutter-height
     This specifies the height of the bottom gutter.

 - Specifier: left-gutter-width
     This specifies the width of the left gutter.

 - Specifier: right-gutter-width
     This specifies the width of the right gutter.

   Note that all of the position-specific gutter thickness specifiers
have a fallback value of zero when they do not correspond to the
default gutter.  Therefore, you will have to set a non-zero thickness
value if you want a position-specific gutter to be displayed.

 - Specifier: default-gutter-visible-p
     This specifies whether the default gutter is visible.  The
     position of the default gutter is specified by the function
     `set-default-gutter-position'.  If the corresponding
     position-specific gutter visibility specifier (e.g.
     `top-gutter-visible-p' if `default-gutter-position' is `top') does
     not specify a visible-p value in a particular domain (a window or
     a frame), then the value of `default-gutter-visible-p' in that
     domain, if any, will be used instead.

 - Specifier: top-gutter-visible-p
     This specifies whether the top gutter is visible.

 - Specifier: bottom-gutter-visible-p
     This specifies whether the bottom gutter is visible.

 - Specifier: left-gutter-visible-p
     This specifies whether the left gutter is visible.

 - Specifier: right-gutter-visible-p
     This specifies whether the right gutter is visible.

   `default-gutter-visible-p' and all of the position-specific gutter
visibility specifiers have a fallback value of true.

   Internally, gutter thickness and visibility specifiers are
instantiated in both window and frame domains, for different purposes.
The value in the domain of a frame's selected window specifies the
actual gutter thickness or visibility that you will see in that frame.
The value in the domain of a frame itself specifies the gutter
thickness or visibility that is used in frame geometry calculations.

   Thus, for example, if you set the frame width to 80 characters and
the left gutter width for that frame to 68 pixels, then the frame will
be sized to fit 80 characters plus a 68-pixel left gutter.  If you then
set the left gutter width to 0 for a particular buffer (or if that
buffer does not specify a left gutter or has a nil value specified for
`left-gutter-visible-p'), you will find that, when that buffer is
displayed in the selected window, the window will have a width of 86 or
87 characters - the frame is sized for a 68-pixel left gutter but the
selected window specifies that the left gutter is not visible, so it is
expanded to take up the slack.

 - Specifier: gutter-buttons-captioned-p
     Whether gutter buttons are captioned.  This affects which glyphs
     from a gutter button descriptor are chosen.  *Note Gutter
     Descriptor Format::.

   You can also reset the gutter to what it was when XEmacs started up.

 - Constant: initial-gutter-spec
     The gutter descriptor used to initialize `default-gutter' at
     startup.


File: lispref.info,  Node: Common Gutter Widgets,  Prev: Other Gutter Variables,  Up: Gutter

Common Gutter Widgets
=====================

   A gutter can contain arbitrary text.  So, for example, in an Info
buffer you could put the title of the current node in the top gutter,
and it would not scroll out of view in a long node.  (This is an
artificial example, since usually the node name is sufficiently
descriptive, and Info puts that in the mode line.)

   A more common use for the gutter is to hold some kind of active
widget.  The buffer-tab facility, available in all XEmacs frames,
creates an array of file-folder-like tabs, which the user can click with
the mouse to switch buffers.  W3 uses a progress-bar widget in the
bottom gutter to give a visual indication of the progress of
time-consuming operations like downloading.

* Menu:

* Buffer Tabs::         Tabbed divider index metaphor for switching buffers.
* Progress Bars::       Visual indication of operation progress.


File: lispref.info,  Node: Buffer Tabs,  Next: Progress Bars,  Up: Common Gutter Widgets

Buffer Tabs
-----------

   Not documented yet.


File: lispref.info,  Node: Progress Bars,  Prev: Buffer Tabs,  Up: Common Gutter Widgets

Progress Bars
-------------

   Not documented yet.


File: lispref.info,  Node: Scrollbars,  Next: Drag and Drop,  Prev: Gutter,  Up: Top

Scrollbars
**********

   Not yet documented.


File: lispref.info,  Node: Drag and Drop,  Next: Modes,  Prev: Scrollbars,  Up: Top

Drag and Drop
*************

   _WARNING_: the Drag'n'Drop API is still under development and the
interface may change! The current implementation is considered
experimental.

   Drag'n'drop is a way to transfer information between multiple
applications.  To do this several GUIs define their own protocols.
Examples are OffiX, CDE, Motif, KDE, MSWindows, GNOME, and many more.
To catch all these protocols, XEmacs provides a generic API.

   One prime idea behind the API is to use a data interface that is
transparent for all systems. The author thinks that this is best
archived by using URL and MIME data, cause any internet enabled system
must support these for email already. XEmacs also already provides
powerful interfaces to support these types of data (tm and w3).

* Menu:

* Supported Protocols:: Which low-level protocols are supported.
* Drop Interface::      How XEmacs handles a drop from another application.
* Drag Interface::      Calls to initiate a drag from XEmacs.


File: lispref.info,  Node: Supported Protocols,  Next: Drop Interface,  Up: Drag and Drop

Supported Protocols
===================

   The current release of XEmacs only support a small set of Drag'n'drop
protocols. Some of these only support limited options available in the
API.

* Menu:

* OffiX DND::           A generic X based protocol.
* CDE dt::              Common Desktop Environment used on suns.
* MSWindows OLE::       Mr. Gates way of live.
* Loose ends::          The other protocols.


File: lispref.info,  Node: OffiX DND,  Next: CDE dt,  Up: Supported Protocols

OffiX DND
---------

   _WARNING_: If you compile in OffiX, you may not be able to use
multiple X displays successfully.  If the two servers are from
different vendors, the results may be unpredictable.

   The OffiX Drag'n'Drop protocol is part of a X API/Widget library
created by Cesar Crusius. It is based on X-Atoms and ClientMessage
events, and works with any X platform supporting them.

   OffiX is supported if 'offix is member of the variable
dragdrop-protocols, or the feature 'offix is defined.

   Unfortunately it uses it's own data types. Examples are: File, Files,
Exe, Link, URL, MIME. The API tries to choose the right type for the
data that is dragged from XEmacs (well, not yet...).

   XEmacs supports both MIME and URL drags and drops using this API. No
application interaction is possible while dragging is in progress.

   For information about the OffiX project have a look at
http://leb.net/~offix/

