This is ../info/xemacs.info, produced by makeinfo version 4.0b from
xemacs/xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Keymaps,  Next: Rebinding,  Up: Key Bindings

Keymaps
-------

   The bindings between characters and command functions are recorded in
data structures called "keymaps".  Emacs has many of these.  One, the
"global" keymap, defines the meanings of the single-character keys that
are defined regardless of major mode.  It is the value of the variable
`global-map'.

   Each major mode has another keymap, its "local keymap", which
contains overriding definitions for the single-character keys that are
redefined in that mode.  Each buffer records which local keymap is
installed for it at any time, and the current buffer's local keymap is
the only one that directly affects command execution.  The local keymaps
for Lisp mode, C mode, and many other major modes always exist even when
not in use.  They are the values of the variables `lisp-mode-map',
`c-mode-map', and so on.  For less frequently used major modes, the
local keymap is sometimes constructed only when the mode is used for the
first time in a session, to save space.

   There are local keymaps for the minibuffer, too; they contain various
completion and exit commands.

   * `minibuffer-local-map' is used for ordinary input (no completion).

   * `minibuffer-local-ns-map' is similar, except that <SPC> exits just
     like <RET>.  This is used mainly for Mocklisp compatibility.

   * `minibuffer-local-completion-map' is for permissive completion.

   * `minibuffer-local-must-match-map' is for strict completion and for
     cautious completion.

   * `repeat-complex-command-map' is for use in `C-x <ESC>'.

   * `isearch-mode-map' contains the bindings of the special keys which
     are bound in the pseudo-mode entered with `C-s' and `C-r'.

   Finally, each prefix key has a keymap which defines the key sequences
that start with it.  For example, `ctl-x-map' is the keymap used for
characters following a `C-x'.

   * `ctl-x-map' is the variable name for the map used for characters
     that follow `C-x'.

   * `help-map' is used for characters that follow `C-h'.

   * `esc-map' is for characters that follow <ESC>. All Meta characters
     are actually defined by this map.

   * `ctl-x-4-map' is for characters that follow `C-x 4'.

   * `mode-specific-map' is for characters that follow `C-c'.

   The definition of a prefix key is the keymap to use for looking up
the following character.  Sometimes the definition is actually a Lisp
symbol whose function definition is the following character keymap.  The
effect is the same, but it provides a command name for the prefix key
that you can use as a description of what the prefix key is for.  Thus
the binding of `C-x' is the symbol `Ctl-X-Prefix', whose function
definition is the keymap for `C-x' commands, the value of `ctl-x-map'.

   Prefix key definitions can appear in either the global map or a
local map.  The definitions of `C-c', `C-x', `C-h', and <ESC> as prefix
keys appear in the global map, so these prefix keys are always
available.  Major modes can locally redefine a key as a prefix by
putting a prefix key definition for it in the local map.

   A mode can also put a prefix definition of a global prefix character
such as `C-x' into its local map.  This is how major modes override the
definitions of certain keys that start with `C-x'.  This case is
special, because the local definition does not entirely replace the
global one.  When both the global and local definitions of a key are
other keymaps, the next character is looked up in both keymaps, with
the local definition overriding the global one.  The character after the
`C-x' is looked up in both the major mode's own keymap for redefined
`C-x' commands and in `ctl-x-map'.  If the major mode's own keymap for
`C-x' commands contains `nil', the definition from the global keymap
for `C-x' commands is used.


File: xemacs.info,  Node: Rebinding,  Next: Disabling,  Prev: Keymaps,  Up: Key Bindings

Changing Key Bindings
---------------------

   You can redefine an Emacs key by changing its entry in a keymap.
You can change the global keymap, in which case the change is effective
in all major modes except those that have their own overriding local
definitions for the same key.  Or you can change the current buffer's
local map, which affects all buffers using the same major mode.

* Menu:

* Interactive Rebinding::      Changing Key Bindings Interactively
* Programmatic Rebinding::     Changing Key Bindings Programmatically
* Key Bindings Using Strings:: Using Strings for Changing Key Bindings


File: xemacs.info,  Node: Interactive Rebinding,  Next: Programmatic Rebinding,  Up: Rebinding

Changing Key Bindings Interactively
...................................

`M-x global-set-key <RET> KEY CMD <RET>'
     Defines KEY globally to run CMD.

`M-x local-set-key <RET> KEYS CMD <RET>'
     Defines KEY locally (in the major mode now in effect) to run CMD.

`M-x local-unset-key <RET> KEYS <RET>'
     Removes the local binding of KEY.

   CMD is a symbol naming an interactively-callable function.

   When called interactively, KEY is the next complete key sequence
that you type.  When called as a function, KEY is a string, a vector of
events, or a vector of key-description lists as described in the
`define-key' function description.  The binding goes in the current
buffer's local map, which is shared with other buffers in the same
major mode.

   The following example:

     M-x global-set-key <RET> C-f next-line <RET>

redefines `C-f' to move down a line.  The fact that CMD is read second
makes it serve as a kind of confirmation for KEY.

   These functions offer no way to specify a particular prefix keymap as
the one to redefine in, but that is not necessary, as you can include
prefixes in KEY.  KEY is read by reading characters one by one until
they amount to a complete key (that is, not a prefix key).  Thus, if
you type `C-f' for KEY, Emacs enters the minibuffer immediately to read
CMD.  But if you type `C-x', another character is read; if that
character is `4', another character is read, and so on.  For example,

     M-x global-set-key <RET> C-x 4 $ spell-other-window <RET>

redefines `C-x 4 $' to run the (fictitious) command
`spell-other-window'.

   The most general way to modify a keymap is the function
`define-key', used in Lisp code (such as your init file).  `define-key'
takes three arguments: the keymap, the key to modify in it, and the new
definition.  *Note Init File::, for an example.
`substitute-key-definition' is used similarly; it takes three
arguments, an old definition, a new definition, and a keymap, and
redefines in that keymap all keys that were previously defined with the
old definition to have the new definition instead.


File: xemacs.info,  Node: Programmatic Rebinding,  Next: Key Bindings Using Strings,  Prev: Interactive Rebinding,  Up: Rebinding

Changing Key Bindings Programmatically
......................................

   You can use the functions `global-set-key' and `define-key' to
rebind keys under program control.

``(global-set-key KEYS CMD)''
     Defines KEYS globally to run CMD.

``(define-key KEYMAP KEYS DEF)''
     Defines KEYS to run DEF in the keymap KEYMAP.

   KEYMAP is a keymap object.

   KEYS is the sequence of keystrokes to bind.

   DEF is anything that can be a key's definition:

   * `nil', meaning key is undefined in this keymap

   * A command, that is, a Lisp function suitable for interactive
     calling

   * A string or key sequence vector, which is treated as a keyboard
     macro

   * A keymap to define a prefix key

   * A symbol so that when the key is looked up, the symbol stands for
     its function definition, which should at that time be one of the
     above, or another symbol whose function definition is used, and so
     on

   * A cons, `(string . defn)', meaning that DEFN is the definition
     (DEFN should be a valid definition in its own right)

   * A cons, `(keymap . char)', meaning use the definition of CHAR in
     map KEYMAP

   For backward compatibility, XEmacs allows you to specify key
sequences as strings.  However, the preferred method is to use the
representations of key sequences as vectors of keystrokes.  *Note
Keystrokes::, for more information about the rules for constructing key
sequences.

   Emacs allows you to abbreviate representations for key sequences in
most places where there is no ambiguity.  Here are some rules for
abbreviation:

   * The keysym by itself is equivalent to a list of just that keysym,
     i.e., `f1' is equivalent to `(f1)'.

   * A keystroke by itself is equivalent to a vector containing just
     that keystroke, i.e.,  `(control a)' is equivalent to `[(control
     a)]'.

   * You can use ASCII codes for keysyms that have them. i.e., `65' is
     equivalent to `A'. (This is not so much an abbreviation as an
     alternate representation.)

   Here are some examples of programmatically binding keys:


     ;;;  Bind `my-command' to <f1>
     (global-set-key 'f1 'my-command)
     
     ;;;  Bind `my-command' to Shift-f1
     (global-set-key '(shift f1) 'my-command)
     
     ;;; Bind `my-command' to C-c Shift-f1
     (global-set-key '[(control c) (shift f1)] 'my-command)
     
     ;;; Bind `my-command' to the middle mouse button.
     (global-set-key 'button2 'my-command)
     
     ;;; Bind `my-command' to <META> <CTL> <Right Mouse Button>
     ;;; in the keymap that is in force when you are running `dired'.
     (define-key dired-mode-map '(meta control button3) 'my-command)


File: xemacs.info,  Node: Key Bindings Using Strings,  Prev: Programmatic Rebinding,  Up: Rebinding

Using Strings for Changing Key Bindings
.......................................

   For backward compatibility, you can still use strings to represent
key sequences.  Thus you can use commands like the following:

     ;;; Bind `end-of-line' to C-f
     (global-set-key "\C-f" 'end-of-line)

   Note, however, that in some cases you may be binding more than one
key sequence by using a single command.  This situation can arise
because in ASCII, `C-i' and <TAB> have the same representation.
Therefore, when Emacs sees:

     (global-set-key "\C-i" 'end-of-line)

   it is unclear whether the user intended to bind `C-i' or <TAB>.  The
solution XEmacs adopts is to bind both of these key sequences.

   After binding a command to two key sequences with a form like:

             (define-key global-map "\^X\^I" 'command-1)

   it is possible to redefine only one of those sequences like so:

             (define-key global-map [(control x) (control i)] 'command-2)
             (define-key global-map [(control x) tab] 'command-3)

   This applies only when running under a window system.  If you are
talking to Emacs through an ASCII-only channel, you do not get any of
these features.

   Here is a table of pairs of key sequences that behave in a similar
fashion:

             control h      backspace
             control l      clear
             control i      tab
             control m      return
             control j      linefeed
             control [      escape
             control @      control space


File: xemacs.info,  Node: Disabling,  Prev: Rebinding,  Up: Key Bindings

Disabling Commands
------------------

   Disabling a command marks it as requiring confirmation before it can
be executed.  The purpose of disabling a command is to prevent
beginning users from executing it by accident and being confused.

   The direct mechanism for disabling a command is to have a non-`nil'
`disabled' property on the Lisp symbol for the command.  These
properties are normally set by the user's init file with Lisp
expressions such as:

     (put 'delete-region 'disabled t)

   *Note Init File::.

   If the value of the `disabled' property is a string, that string is
included in the message printed when the command is used:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

   You can disable a command either by editing the init file directly
or with the command `M-x disable-command', which edits the init file
for you.  *Note Init File::.

   When you attempt to invoke a disabled command interactively in Emacs,
a window is displayed containing the command's name, its documentation,
and some instructions on what to do next; then Emacs asks for input
saying whether to execute the command as requested, enable it and
execute, or cancel it.  If you decide to enable the command, you are
asked whether to do this permanently or just for the current session.
Enabling permanently works by automatically editing your init file.
You can use `M-x enable-command' at any time to enable any command
permanently.

   Whether a command is disabled is independent of what key is used to
invoke it; it also applies if the command is invoked using `M-x'.
Disabling a command has no effect on calling it as a function from Lisp
programs.


File: xemacs.info,  Node: Syntax,  Next: Init File,  Prev: Key Bindings,  Up: Customization

The Syntax Table
================

   All the Emacs commands which parse words or balance parentheses are
controlled by the "syntax table".  The syntax table specifies which
characters are opening delimiters, which are parts of words, which are
string quotes, and so on.  Actually, each major mode has its own syntax
table (though sometimes related major modes use the same one) which it
installs in each buffer that uses that major mode.  The syntax table
installed in the current buffer is the one that all commands use, so we
call it "the" syntax table.  A syntax table is a Lisp object, a vector
of length 256 whose elements are numbers.

* Menu:

* Entry: Syntax Entry.    What the syntax table records for each character.
* Change: Syntax Change.  How to change the information.


File: xemacs.info,  Node: Syntax Entry,  Next: Syntax Change,  Up: Syntax

Information About Each Character
--------------------------------

   The syntax table entry for a character is a number that encodes six
pieces of information:

   * The syntactic class of the character, represented as a small
     integer

   * The matching delimiter, for delimiter characters only (the
     matching delimiter of `(' is `)', and vice versa)

   * A flag saying whether the character is the first character of a
     two-character comment starting sequence

   * A flag saying whether the character is the second character of a
     two-character comment starting sequence

   * A flag saying whether the character is the first character of a
     two-character comment ending sequence

   * A flag saying whether the character is the second character of a
     two-character comment ending sequence

   The syntactic classes are stored internally as small integers, but
are usually described to or by the user with characters.  For example,
`(' is used to specify the syntactic class of opening delimiters.  Here
is a table of syntactic classes, with the characters that specify them.

` '
     The class of whitespace characters.

`w'
     The class of word-constituent characters.

`_'
     The class of characters that are part of symbol names but not
     words.  This class is represented by `_' because the character `_'
     has this class in both C and Lisp.

`.'
     The class of punctuation characters that do not fit into any other
     special class.

`('
     The class of opening delimiters.

`)'
     The class of closing delimiters.

`''
     The class of expression-adhering characters.  These characters are
     part of a symbol if found within or adjacent to one, and are part
     of a following expression if immediately preceding one, but are
     like whitespace if surrounded by whitespace.

`"'
     The class of string-quote characters.  They match each other in
     pairs, and the characters within the pair all lose their syntactic
     significance except for the `\' and `/' classes of escape
     characters, which can be used to include a string-quote inside the
     string.

`$'
     The class of self-matching delimiters.  This is intended for TeX's
     `$', which is used both to enter and leave math mode.  Thus, a
     pair of matching `$' characters surround each piece of math mode
     TeX input.  A pair of adjacent `$' characters act like a single
     one for purposes of matching.

`/'
     The class of escape characters that always just deny the following
     character its special syntactic significance.  The character after
     one of these escapes is always treated as alphabetic.

`\'
     The class of C-style escape characters.  In practice, these are
     treated just like `/'-class characters, because the extra
     possibilities for C escapes (such as being followed by digits)
     have no effect on where the containing expression ends.

`<'
     The class of comment-starting characters.  Only single-character
     comment starters (such as `;' in Lisp mode) are represented this
     way.

`>'
     The class of comment-ending characters.  Newline has this syntax in
     Lisp mode.

   The characters flagged as part of two-character comment delimiters
can have other syntactic functions most of the time.  For example, `/'
and `*' in C code, when found separately, have nothing to do with
comments.  The comment-delimiter significance overrides when the pair of
characters occur together in the proper order.  Only the list and sexp
commands use the syntax table to find comments; the commands
specifically for comments have other variables that tell them where to
find comments.  Moreover, the list and sexp commands notice comments
only if `parse-sexp-ignore-comments' is non-`nil'.  This variable is set
to `nil' in modes where comment-terminator sequences are liable to
appear where there is no comment, for example, in Lisp mode where the
comment terminator is a newline but not every newline ends a comment.


File: xemacs.info,  Node: Syntax Change,  Prev: Syntax Entry,  Up: Syntax

Altering Syntax Information
---------------------------

   It is possible to alter a character's syntax table entry by storing
a new number in the appropriate element of the syntax table, but it
would be hard to determine what number to use.  Emacs therefore
provides a command that allows you to specify the syntactic properties
of a character in a convenient way.

   `M-x modify-syntax-entry' is the command to change a character's
syntax.  It can be used interactively and is also used by major modes
to initialize their own syntax tables.  Its first argument is the
character to change.  The second argument is a string that specifies the
new syntax.  When called from Lisp code, there is a third, optional
argument, which specifies the syntax table in which to make the change.
If not supplied, or if this command is called interactively, the third
argument defaults to the current buffer's syntax table.

  1. The first character in the string specifies the syntactic class.
     It is one of the characters in the previous table (*note Syntax
     Entry::).

  2. The second character is the matching delimiter.  For a character
     that is not an opening or closing delimiter, this should be a
     space, and may be omitted if no following characters are needed.

  3. The remaining characters are flags.  The flag characters allowed
     are:

    `1'
          Flag this character as the first of a two-character comment
          starting sequence.

    `2'
          Flag this character as the second of a two-character comment
          starting sequence.

    `3'
          Flag this character as the first of a two-character comment
          ending sequence.

    `4'
          Flag this character as the second of a two-character comment
          ending sequence.

   Use `C-h s' (`describe-syntax') to display a description of the
contents of the current syntax table.  The description of each
character includes both the string you have to pass to
`modify-syntax-entry' to set up that character's current syntax, and
some English to explain that string if necessary.


File: xemacs.info,  Node: Init File,  Next: Audible Bell,  Prev: Syntax,  Up: Customization

The Init File
=============

   When you start Emacs, it normally loads either `.xemacs/init.el' or
the file `.emacs' (whichever comes first) in your home directory.  This
file, if it exists, should contain Lisp code.  It is called your
initialization file or "init file".  Use the command line switch `-q'
to tell Emacs whether to load an init file (*note Entering Emacs::).
Use the command line switch `-user-init-file' (*note Command
Switches::) to tell Emacs to load a different file instead of
`~/.xemacs/init.el'/`~/.emacs'.

   When the init file is read, the variable `user-init-file' says which
init file was loaded.

   At some sites there is a "default init file", which is the library
named `default.el', found via the standard search path for libraries.
The Emacs distribution contains no such library; your site may create
one for local customizations.  If this library exists, it is loaded
whenever you start Emacs.  But your init file, if any, is loaded first;
if it sets `inhibit-default-init' non-`nil', then `default' is not
loaded.

   If you have a large amount of code in your init file, you should
byte-compile it to `~/.xemacs/init.elc' or `~/.emacs.elc'.

* Menu:

* Init Syntax::     Syntax of constants in Emacs Lisp.
* Init Examples::   How to do some things with an init file.
* Terminal Init::   Each terminal type can have an init file.


File: xemacs.info,  Node: Init Syntax,  Next: Init Examples,  Up: Init File

Init File Syntax
----------------

   The init file contains one or more Lisp function call expressions.
Each consists of a function name followed by arguments, all surrounded
by parentheses.  For example, `(setq fill-column 60)' represents a call
to the function `setq' which is used to set the variable `fill-column'
(*note Filling::) to 60.

   The second argument to `setq' is an expression for the new value of
the variable.  This can be a constant, a variable, or a function call
expression.  In the init file, constants are used most of the time.
They can be:

Numbers
     Integers are written in decimal, with an optional initial minus
     sign.

     If a sequence of digits is followed by a period and another
     sequence of digits, it is interpreted as a floating point number.

     The number prefixes `#b', `#o', and `#x' are supported to
     represent numbers in binary, octal, and hexadecimal notation (or
     radix).

Strings
     Lisp string syntax is the same as C string syntax with a few extra
     features.  Use a double-quote character to begin and end a string
     constant.

     Newlines and special characters may be present literally in
     strings.  They can also be represented as backslash sequences:
     `\n' for newline, `\b' for backspace, `\r' for return, `\t' for
     tab, `\f' for formfeed (control-l), `\e' for escape, `\\' for a
     backslash, `\"' for a double-quote, or `\OOO' for the character
     whose octal code is OOO.  Backslash and double-quote are the only
     characters for which backslash sequences are mandatory.

     You can use `\C-' as a prefix for a control character, as in
     `\C-s' for ASCII Control-S, and `\M-' as a prefix for a Meta
     character, as in `\M-a' for Meta-A or `\M-\C-a' for Control-Meta-A.

Characters
     Lisp character constant syntax consists of a `?' followed by
     either a character or an escape sequence starting with `\'.
     Examples: `?x', `?\n', `?\"', `?\)'.  Note that strings and
     characters are not interchangeable in Lisp; some contexts require
     one and some contexts require the other.

True
     `t' stands for `true'.

False
     `nil' stands for `false'.

Other Lisp objects
     Write a single-quote (') followed by the Lisp object you want.


File: xemacs.info,  Node: Init Examples,  Next: Terminal Init,  Prev: Init Syntax,  Up: Init File

Init File Examples
------------------

   Here are some examples of doing certain commonly desired things with
Lisp expressions:

   * Make <TAB> in C mode just insert a tab if point is in the middle
     of a line.

          (setq c-tab-always-indent nil)

     Here we have a variable whose value is normally `t' for `true' and
     the alternative is `nil' for `false'.

   * Make searches case sensitive by default (in all buffers that do not
     override this).

          (setq-default case-fold-search nil)

     This sets the default value, which is effective in all buffers
     that do not have local values for the variable.  Setting
     `case-fold-search' with `setq' affects only the current buffer's
     local value, which is probably not what you want to do in an init
     file.

   * Make Text mode the default mode for new buffers.

          (setq default-major-mode 'text-mode)

     Note that `text-mode' is used because it is the command for
     entering the mode we want.  A single-quote is written before it to
     make a symbol constant; otherwise, `text-mode' would be treated as
     a variable name.

   * Turn on Auto Fill mode automatically in Text mode and related
     modes.

          (setq text-mode-hook
            '(lambda () (auto-fill-mode 1)))

     Here we have a variable whose value should be a Lisp function.  The
     function we supply is a list starting with `lambda', and a single
     quote is written in front of it to make it (for the purpose of this
     `setq') a list constant rather than an expression.  Lisp functions
     are not explained here; for mode hooks it is enough to know that
     `(auto-fill-mode 1)' is an expression that will be executed when
     Text mode is entered.  You could replace it with any other
     expression that you like, or with several expressions in a row.

          (setq text-mode-hook 'turn-on-auto-fill)

     This is another way to accomplish the same result.
     `turn-on-auto-fill' is a symbol whose function definition is
     `(lambda () (auto-fill-mode 1))'.

   * Load the installed Lisp library named `foo' (actually a file
     `foo.elc' or `foo.el' in a standard Emacs directory).

          (load "foo")

     When the argument to `load' is a relative pathname, not starting
     with `/' or `~', `load' searches the directories in `load-path'
     (*note Loading::).

   * Load the compiled Lisp file `foo.elc' from your home directory.

          (load "~/foo.elc")

     Here an absolute file name is used, so no searching is done.

   * Rebind the key `C-x l' to run the function `make-symbolic-link'.

          (global-set-key "\C-xl" 'make-symbolic-link)

     or

          (define-key global-map "\C-xl" 'make-symbolic-link)

     Note once again the single-quote used to refer to the symbol
     `make-symbolic-link' instead of its value as a variable.

   * Do the same thing for C mode only.

          (define-key c-mode-map "\C-xl" 'make-symbolic-link)

   * Bind the function key <F1> to a command in C mode.  Note that the
     names of function keys must be lower case.

          (define-key c-mode-map 'f1 'make-symbolic-link)

   * Bind the shifted version of <F1> to a command.

          (define-key c-mode-map '(shift f1) 'make-symbolic-link)

   * Redefine all keys which now run `next-line' in Fundamental mode to
     run `forward-line' instead.

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * Make `C-x C-v' undefined.

          (global-unset-key "\C-x\C-v")

     One reason to undefine a key is so that you can make it a prefix.
     Simply defining `C-x C-v ANYTHING' would make `C-x C-v' a prefix,
     but `C-x C-v' must be freed of any non-prefix definition first.

   * Make `$' have the syntax of punctuation in Text mode.  Note the
     use of a character constant for `$'.

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * Enable the use of the command `eval-expression' without
     confirmation.

          (put 'eval-expression 'disabled nil)


File: xemacs.info,  Node: Terminal Init,  Prev: Init Examples,  Up: Init File

Terminal-Specific Initialization
--------------------------------

   Each terminal type can have a Lisp library to be loaded into Emacs
when it is run on that type of terminal.  For a terminal type named
TERMTYPE, the library is called `term/TERMTYPE' and it is found by
searching the directories `load-path' as usual and trying the suffixes
`.elc' and `.el'.  Normally it appears in the subdirectory `term' of
the directory where most Emacs libraries are kept.

   The usual purpose of the terminal-specific library is to define the
escape sequences used by the terminal's function keys using the library
`keypad.el'.  See the file `term/vt100.el' for an example of how this
is done.

   When the terminal type contains a hyphen, only the part of the name
before the first hyphen is significant in choosing the library name.
Thus, terminal types `aaa-48' and `aaa-30-rv' both use the library
`term/aaa'.  The code in the library can use `(getenv "TERM")' to find
the full terminal type name.

   The library's name is constructed by concatenating the value of the
variable `term-file-prefix' and the terminal type.  Your init file can
prevent the loading of the terminal-specific library by setting
`term-file-prefix' to `nil'.  *Note Init File::.

   The value of the variable `term-setup-hook', if not `nil', is called
as a function of no arguments at the end of Emacs initialization, after
both your init file and any terminal-specific library have been read.
*Note Init File::.  You can set the value in the init file to override
part of any of the terminal-specific libraries and to define
initializations for terminals that do not have a library.


File: xemacs.info,  Node: Audible Bell,  Next: Faces,  Prev: Init File,  Up: Customization

Changing the Bell Sound
=======================

   You can now change how the audible bell sounds using the variable
`sound-alist'.

   `sound-alist''s value is an list associating symbols with, among
other things, strings of audio-data.  When `ding' is called with one of
the symbols, the associated sound data is played instead of the
standard beep.  This only works if you are logged in on the console of a
machine with audio hardware. To listen to a sound of the provided type,
call the function `play-sound' with the argument SOUND. You can also
set the volume of the sound with the optional argument VOLUME.

   Each element of `sound-alist' is a list describing a sound.  The
first element of the list is the name of the sound being defined.
Subsequent elements of the list are alternating keyword/value pairs:

`sound'
     A string of raw sound data, or the name of another sound to play.
     The symbol `t' here means use the default X beep.

`volume'
     An integer from 0-100, defaulting to `bell-volume'.

`pitch'
     If using the default X beep, the pitch (Hz) to generate.

`duration'
     If using the default X beep, the duration (milliseconds).

   For compatibility, elements of `sound-alist' may also be of the form:

     ( SOUND-NAME . <SOUND> )
     ( SOUND-NAME <VOLUME> <SOUND> )

   You should probably add things to this list by calling the function
`load-sound-file'.

   Note that you can only play audio data if running on the console
screen of a machine with audio hardware which emacs understands, which
at this time means a Sun SparcStation, SGI, or HP9000s700.

   Also note that the pitch, duration, and volume options are available
everywhere, but most X servers ignore the `pitch' option.

   The variable `bell-volume' should be an integer from 0 to 100, with
100 being loudest, which controls how loud the sounds emacs makes
should be.  Elements of the `sound-alist' may override this value.
This variable applies to the standard X bell sound as well as sound
files.

   If the symbol `t' is in place of a sound-string, Emacs uses the
default X beep.  This allows you to define beep-types of different
volumes even when not running on the console.

   You can add things to this list by calling the function
`load-sound-file', which reads in an audio-file and adds its data to
the sound-alist. You can specify the sound with the SOUND-NAME argument
and the file into which the sounds are loaded with the FILENAME
argument. The optional VOLUME argument sets the volume.

   `load-sound-file (FILENAME SOUND-NAME &optional VOLUME)'

   To load and install some sound files as beep-types, use the function
`load-default-sounds' (note that this only works if you are on display
0 of a machine with audio hardware).

   The following beep-types are used by Emacs itself. Other Lisp
packages may use other beep types, but these are the ones that the C
kernel of Emacs uses.

`auto-save-error'
     An auto-save does not succeed

`command-error'
     The Emacs command loop catches an error

`undefined-key'
     You type a key that is undefined

`undefined-click'
     You use an undefined mouse-click combination

`no-completion'
     Completion was not possible

`y-or-n-p'
     You type something other than the required `y' or `n'

`yes-or-no-p'
     You type something other than `yes' or `no'


File: xemacs.info,  Node: Faces,  Next: Frame Components,  Prev: Audible Bell,  Up: Customization

Faces
=====

   XEmacs has objects called extents and faces.  An "extent" is a
region of text and a "face" is a collection of textual attributes, such
as fonts and colors.  Every extent is displayed in some face;
therefore, changing the properties of a face immediately updates the
display of all associated extents.  Faces can be frame-local: you can
have a region of text that displays with completely different
attributes when its buffer is viewed from a different X window.

   The display attributes of faces may be specified either in Lisp or
through the X resource manager.

Customizing Faces
-----------------

   You can change the face of an extent with the functions in this
section.  All the functions prompt for a FACE as an argument; use
completion for a list of possible values.

`M-x invert-face'
     Swap the foreground and background colors of the given FACE.

`M-x make-face-bold'
     Make the font of the given FACE bold.  When called from a program,
     returns `nil' if this is not possible.

`M-x make-face-bold-italic'
     Make the font of the given FACE bold italic.  When called from a
     program, returns `nil' if not possible.

`M-x make-face-italic'
     Make the font of the given FACE italic.  When called from a
     program, returns `nil' if not possible.

`M-x make-face-unbold'
     Make the font of the given FACE non-bold.  When called from a
     program, returns `nil' if not possible.

`M-x make-face-unitalic'
     Make the font of the given FACE non-italic.  When called from a
     program, returns `nil' if not possible.

`M-x make-face-larger'
     Make the font of the given FACE a little larger.  When called from
     a program, returns `nil' if not possible.

`M-x make-face-smaller'
     Make the font of the given FACE a little smaller.  When called
     from a program, returns `nil' if not possible.

`M-x set-face-background'
     Change the background color of the given FACE.

`M-x set-face-background-pixmap'
     Change the background pixmap of the given FACE.

`M-x set-face-font'
     Change the font of the given FACE.

`M-x set-face-foreground'
     Change the foreground color of the given FACE.

`M-x set-face-underline-p'
     Change whether the given FACE is underlined.

   You can exchange the foreground and background color of the selected
FACE with the function `invert-face'. If the face does not specify both
foreground and background, then its foreground and background are set
to the background and foreground of the default face.  When calling
this from a program, you can supply the optional argument FRAME to
specify which frame is affected; otherwise, all frames are affected.

   You can set the background color of the specified FACE with the
function `set-face-background'.  The argument `color' should be a
string, the name of a color.  When called from a program, if the
optional FRAME argument is provided, the face is changed only in that
frame; otherwise, it is changed in all frames.

   You can set the background pixmap of the specified FACE with the
function `set-face-background-pixmap'.  The pixmap argument NAME should
be a string, the name of a file of pixmap data.  The directories listed
in the `x-bitmap-file-path' variable are searched.  The bitmap may also
be a list of the form `(WIDTH HEIGHT DATA)', where WIDTH and HEIGHT are
the size in pixels, and DATA is a string containing the raw bits of the
bitmap.  If the optional FRAME argument is provided, the face is
changed only in that frame; otherwise, it is changed in all frames.

   The variable `x-bitmap-file-path' takes as a value a list of the
directories in which X bitmap files may be found.  If the value is
`nil', the list is initialized from the `*bitmapFilePath' resource.

   If the environment variable XBMLANGPATH is set, then it is consulted
before the `x-bitmap-file-path' variable.

   You can set the font of the specified FACE with the function
`set-face-font'.  The FONT argument should be a string, the name of a
font.  When called from a program, if the optional FRAME argument is
provided, the face is changed only in that frame; otherwise, it is
changed in all frames.

   You can set the foreground color of the specified FACE with the
function `set-face-foreground'.  The argument COLOR should be a string,
the name of a color.  If the optional FRAME argument is provided, the
face is changed only in that frame; otherwise, it is changed in all
frames.

   You can set underline the specified FACE with the function
`set-face-underline-p'. The argument UNDERLINE-P can be used to make
underlining an attribute of the face or not. If the optional FRAME
argument is provided, the face is changed only in that frame;
otherwise, it is changed in all frames.


File: xemacs.info,  Node: Frame Components,  Next: X Resources,  Prev: Faces,  Up: Customization

Frame Components
================

   You can control the presence and position of most frame components,
such as the menubar, toolbars, and gutters.

   This section is not written yet.  Try the Lisp Reference Manual:
*Note Menubar: (lispref)Menubar, *Note Toolbar Intro: (lispref)Toolbar
Intro, and *Note Gutter Intro: (lispref)Gutter Intro.


File: xemacs.info,  Node: X Resources,  Prev: Frame Components,  Up: Customization

X Resources
===========

   Historically, XEmacs has used the X resource application class
`Emacs' for its resources.  Unfortunately, GNU Emacs uses the same
application class, and resources are not compatible between the two
Emacsen.  This sharing of the application class often leads to trouble
if you want to run both variants.

   Starting with XEmacs 21, XEmacs uses the class `XEmacs' if it finds
any XEmacs resources in the resource database when the X connection is
initialized.  Otherwise, it will use the class `Emacs' for backwards
compatibility.  The variable X-EMACS-APPLICATION-CLASS may be consulted
to determine the application class being used.

   The examples in this section assume the application class is `Emacs'.

   The Emacs resources are generally set per-frame. Each Emacs frame
can have its own name or the same name as another, depending on the
name passed to the `make-frame' function.

   You can specify resources for all frames with the syntax:

     Emacs*parameter: value

or

     Emacs*EmacsFrame.parameter:value

You can specify resources for a particular frame with the syntax:

     Emacs*FRAME-NAME.parameter: value

* Menu:

* Geometry Resources::     Controlling the size and position of frames.
* Iconic Resources::       Controlling whether frames come up iconic.
* Resource List::          List of resources settable on a frame or device.
* Face Resources::         Controlling faces using resources.
* Widgets::                The widget hierarchy for XEmacs.
* Menubar Resources::      Specifying resources for the menubar.


File: xemacs.info,  Node: Geometry Resources,  Next: Iconic Resources,  Up: X Resources

Geometry Resources
------------------

   To make the default size of all Emacs frames be 80 columns by 55
lines, do this:

     Emacs*EmacsFrame.geometry: 80x55

To set the geometry of a particular frame named `fred', do this:

     Emacs*fred.geometry: 80x55

Important! Do not use the following syntax:

     Emacs*geometry: 80x55

You should never use `*geometry' with any X application. It does not
say "make the geometry of Emacs be 80 columns by 55 lines."  It really
says, "make Emacs and all subwindows thereof be 80x55 in whatever units
they care to measure in."  In particular, that is both telling the
Emacs text pane to be 80x55 in characters, and telling the menubar pane
to be 80x55 pixels, which is surely not what you want.

   As a special case, this geometry specification also works (and sets
the default size of all Emacs frames to 80 columns by 55 lines):

     Emacs.geometry: 80x55

since that is the syntax used with most other applications (since most
other applications have only one top-level window, unlike Emacs).  In
general, however, the top-level shell (the unmapped ApplicationShell
widget named `Emacs' that is the parent of the shell widgets that
actually manage the individual frames) does not have any interesting
resources on it, and you should set the resources on the frames instead.

   The `-geometry' command-line argument sets only the geometry of the
initial frame created by Emacs.

   A more complete explanation of geometry-handling is

   * The `-geometry' command-line option sets the `Emacs.geometry'
     resource, that is, the geometry of the ApplicationShell.

   * For the first frame created, the size of the frame is taken from
     the ApplicationShell if it is specified, otherwise from the
     geometry of the frame.

   * For subsequent frames, the order is reversed: First the frame, and
     then the ApplicationShell.

   * For the first frame created, the position of the frame is taken
     from the ApplicationShell (`Emacs.geometry') if it is specified,
     otherwise from the geometry of the frame.

   * For subsequent frames, the position is taken only from the frame,
     and never from the ApplicationShell.

   This is rather complicated, but it does seem to provide the most
intuitive behavior with respect to the default sizes and positions of
frames created in various ways.


File: xemacs.info,  Node: Iconic Resources,  Next: Resource List,  Prev: Geometry Resources,  Up: X Resources

Iconic Resources
----------------

   Analogous to `-geometry', the `-iconic' command-line option sets the
iconic flag of the ApplicationShell (`Emacs.iconic') and always applies
to the first frame created regardless of its name.  However, it is
possible to set the iconic flag on particular frames (by name) by using
the `Emacs*FRAME-NAME.iconic' resource.


File: xemacs.info,  Node: Resource List,  Next: Face Resources,  Prev: Iconic Resources,  Up: X Resources

Resource List
-------------

   Emacs frames accept the following resources:

`geometry' (class `Geometry'): string
     Initial geometry for the frame.  *Note Geometry Resources::, for a
     complete discussion of how this works.

`iconic' (class `Iconic'): boolean
     Whether this frame should appear in the iconified state.

`internalBorderWidth' (class `InternalBorderWidth'): int
     How many blank pixels to leave between the text and the edge of the
     window.

`interline' (class `Interline'): int
     How many pixels to leave between each line (may not be
     implemented).

`menubar' (class `Menubar'): boolean
     Whether newly-created frames should initially have a menubar.  Set
     to true by default.

`initiallyUnmapped' (class `InitiallyUnmapped'): boolean
     Whether XEmacs should leave the initial frame unmapped when it
     starts up.  This is useful if you are starting XEmacs as a server
     (e.g. in conjunction with gnuserv or the external client widget).
     You can also control this with the `-unmapped' command-line option.

`barCursor' (class `BarColor'): boolean
     Whether the cursor should be displayed as a bar, or the
     traditional box.

`cursorColor' (class `CursorColor'): color-name
     The color of the text cursor.

`scrollBarWidth' (class `ScrollBarWidth'): integer
     How wide the vertical scrollbars should be, in pixels; 0 means no
     vertical scrollbars.  You can also use a resource specification of
     the form `*scrollbar.width', or the usual toolkit scrollbar
     resources: `*XmScrollBar.width' (Motif), `*XlwScrollBar.width'
     (Lucid), or `*Scrollbar.thickness' (Athena).  We don't recommend
     that you use the toolkit resources, though, because they're
     dependent on how exactly your particular build of XEmacs was
     configured.

`scrollBarHeight' (class `ScrollBarHeight'): integer
     How high the horizontal scrollbars should be, in pixels; 0 means no
     horizontal scrollbars.  You can also use a resource specification
     of the form `*scrollbar.height', or the usual toolkit scrollbar
     resources: `*XmScrollBar.height' (Motif), `*XlwScrollBar.height'
     (Lucid), or `*Scrollbar.thickness' (Athena).  We don't recommend
     that you use the toolkit resources, though, because they're
     dependent on how exactly your particular build of XEmacs was
     configured.

`scrollBarPlacement' (class `ScrollBarPlacement'): string
     Where the horizontal and vertical scrollbars should be positioned.
     This should be one of the four strings `BOTTOM_LEFT',
     `BOTTOM_RIGHT', `TOP_LEFT', and `TOP_RIGHT'.  Default is
     `BOTTOM_RIGHT' for the Motif and Lucid scrollbars and
     `BOTTOM_LEFT' for the Athena scrollbars.

`topToolBarHeight' (class `TopToolBarHeight'): integer
`bottomToolBarHeight' (class `BottomToolBarHeight'): integer
`leftToolBarWidth' (class `LeftToolBarWidth'): integer
`rightToolBarWidth' (class `RightToolBarWidth'): integer
     Height and width of the four possible toolbars.

`topToolBarShadowColor' (class `TopToolBarShadowColor'): color-name
`bottomToolBarShadowColor' (class `BottomToolBarShadowColor'): color-name
     Color of the top and bottom shadows for the toolbars.  NOTE: These
     resources do _not_ have anything to do with the top and bottom
     toolbars (i.e. the toolbars at the top and bottom of the frame)!
     Rather, they affect the top and bottom shadows around the edges of
     all four kinds of toolbars.

`topToolBarShadowPixmap' (class `TopToolBarShadowPixmap'): pixmap-name
`bottomToolBarShadowPixmap' (class `BottomToolBarShadowPixmap'): pixmap-name
     Pixmap of the top and bottom shadows for the toolbars.  If set,
     these resources override the corresponding color resources. NOTE:
     These resources do _not_ have anything to do with the top and
     bottom toolbars (i.e. the toolbars at the top and bottom of the
     frame)!  Rather, they affect the top and bottom shadows around the
     edges of all four kinds of toolbars.

`toolBarShadowThickness' (class `ToolBarShadowThickness'): integer
     Thickness of the shadows around the toolbars, in pixels.

`visualBell' (class `VisualBell'): boolean
     Whether XEmacs should flash the screen rather than making an
     audible beep.

`bellVolume' (class `BellVolume'): integer
     Volume of the audible beep.

`useBackingStore' (class `UseBackingStore'): boolean
     Whether XEmacs should set the backing-store attribute of the X
     windows it creates.  This increases the memory usage of the X
     server but decreases the amount of X traffic necessary to update
     the screen, and is useful when the connection to the X server goes
     over a low-bandwidth line such as a modem connection.

   Emacs devices accept the following resources:

`textPointer' (class `Cursor'): cursor-name
     The cursor to use when the mouse is over text.  This resource is
     used to initialize the variable `x-pointer-shape'.

`selectionPointer' (class `Cursor'): cursor-name
     The cursor to use when the mouse is over a selectable text region
     (an extent with the `highlight' property; for example, an Info
     cross-reference).  This resource is used to initialize the variable
     `x-selection-pointer-shape'.

`spacePointer' (class `Cursor'): cursor-name
     The cursor to use when the mouse is over a blank space in a buffer
     (that is, after the end of a line or after the end-of-file).  This
     resource is used to initialize the variable
     `x-nontext-pointer-shape'.

`modeLinePointer' (class `Cursor'): cursor-name
     The cursor to use when the mouse is over a modeline.  This
     resource is used to initialize the variable `x-mode-pointer-shape'.

`gcPointer' (class `Cursor'): cursor-name
     The cursor to display when a garbage-collection is in progress.
     This resource is used to initialize the variable
     `x-gc-pointer-shape'.

`scrollbarPointer' (class `Cursor'): cursor-name
     The cursor to use when the mouse is over the scrollbar.  This
     resource is used to initialize the variable
     `x-scrollbar-pointer-shape'.

`pointerColor' (class `Foreground'): color-name
`pointerBackground' (class `Background'): color-name
     The foreground and background colors of the mouse cursor.  These
     resources are used to initialize the variables
     `x-pointer-foreground-color' and `x-pointer-background-color'.

