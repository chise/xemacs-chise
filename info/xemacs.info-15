This is Info file ../../info/xemacs.info, produced by Makeinfo version
1.68 from the input file xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Fancy Diary Display,  Next: Included Diary Files,  Prev: Hebrew/Islamic Entries,  Up: Calendar Customization

Fancy Diary Display
...................

   Diary display works by preparing the diary buffer and then running
the hook `diary-display-hook'.  The default value of this hook
(`simple-diary-display') hides the irrelevant diary entries and then
displays the buffer.  However, if you specify the hook as follows,

     (add-hook 'diary-display-hook 'fancy-diary-display)

this enables fancy diary display.  It displays diary entries and
holidays by copying them into a special buffer that exists only for the
sake of display.  Copying to a separate buffer provides an opportunity
to change the displayed text to make it prettier--for example, to sort
the entries by the dates they apply to.

   As with simple diary display, you can print a hard copy of the buffer
with `print-diary-entries'.  To print a hard copy of a day-by-day diary
for a week by positioning point on Sunday of that week, type `7 d' and
then do `M-x print-diary-entries'.  As usual, the inclusion of the
holidays slows down the display slightly; you can speed things up by
setting the variable `holidays-in-diary-buffer' to `nil'.

   Ordinarily, the fancy diary buffer does not show days for which
there are no diary entries, even if that day is a holiday.  If you want
such days to be shown in the fancy diary buffer, set the variable
`diary-list-include-blanks' to `t'.

   If you use the fancy diary display, you can use the normal hook
`list-diary-entries-hook' to sort each day's diary entries by their
time of day.  Add this line to your `.emacs' file:

     (add-hook 'list-diary-entries-hook 'sort-diary-entries t)

For each day, this sorts diary entries that begin with a recognizable
time of day according to their times.  Diary entries without times come
first within each day.


File: xemacs.info,  Node: Included Diary Files,  Next: Sexp Diary Entries,  Prev: Fancy Diary Display,  Up: Calendar Customization

Included Diary Files
....................

   Fancy diary display also has the ability to process included diary
files.  This permits a group of people to share a diary file for events
that apply to all of them.  Lines in the diary file of this form:

     #include "FILENAME"

includes the diary entries from the file FILENAME in the fancy diary
buffer.  The include mechanism is recursive, so that included files can
include other files, and so on; you must be careful not to have a cycle
of inclusions, of course.  Here is how to enable the include facility:

     (add-hook 'list-diary-entries-hook 'include-other-diary-files)
     (add-hook 'mark-diary-entries-hook 'mark-included-diary-files)

   The include mechanism works only with the fancy diary display,
because ordinary diary display shows the entries directly from your
diary file.


File: xemacs.info,  Node: Sexp Diary Entries,  Next: Appt Customizing,  Prev: Included Diary Files,  Up: Calendar Customization

Sexp Entries and the Fancy Diary Display
........................................

   Sexp diary entries allow you to do more than just have complicated
conditions under which a diary entry applies.  If you use the fancy
diary display, sexp entries can generate the text of the entry depending
on the date itself.  For example, an anniversary diary entry can insert
the number of years since the anniversary date into the text of the
diary entry.  Thus the `%d' in this dairy entry:

     %%(diary-anniversary 10 31 1948) Arthur's birthday (%d years old)

gets replaced by the age, so on October 31, 1990 the entry appears in
the fancy diary buffer like this:

     Arthur's birthday (42 years old)

If the diary file instead contains this entry:

     %%(diary-anniversary 10 31 1948) Arthur's %d%s birthday

the entry in the fancy diary buffer for October 31, 1990 appears like
this:

     Arthur's 42nd birthday

   Similarly, cyclic diary entries can interpolate the number of
repetitions that have occurred:

     %%(diary-cyclic 50 1 1 1990) Renew medication (%d%s time)

looks like this:

     Renew medication (5th time)

in the fancy diary display on September 8, 1990.

   The generality of sexp diary entries lets you specify any diary entry
that you can describe algorithmically.  A sexp diary entry contains an
expression that computes whether the entry applies to any given date.
If its value is non-`nil', the entry applies to that date; otherwise,
it does not.  The expression can use the variable  `date' to find the
date being considered; its value is a list (MONTH DAY YEAR) that refers
to the Gregorian calendar.

   Suppose you get paid on the 21st of the month if it is a weekday, and
on the Friday before if the 21st is on a weekend.  Here is how to write
a sexp diary entry that matches those dates:

     &%%(let ((dayname (calendar-day-of-week date))
              (day (car (cdr date))))
           (or (and (= day 21) (memq dayname '(1 2 3 4 5)))
               (and (memq day '(19 20)) (= dayname 5)))
              ) Pay check deposited

applies to just those dates.  This example illustrates how the sexp can
depend on the variable `date'; this variable is a list (MONTH DAY YEAR)
that gives the Gregorian date for which the diary entries are being
found.  If the value of the expression is `t', the entry applies to
that date.  If the expression evaluates to `nil', the entry does *not*
apply to that date.

   The following sexp diary entries take advantage of the ability (in
the fancy diary display) to concoct diary entries whose text varies
based on the date:

`%%(diary-sunrise-sunset)'
     Make a diary entry for the local times of today's sunrise and
     sunset.

`%%(diary-phases-of-moon)'
     Make a diary entry for the phases (quarters) of the moon.

`%%(diary-day-of-year)'
     Make a diary entry with today's day number in the current year and
     the number of days remaining in the current year.

`%%(diary-iso-date)'
     Make a diary entry with today's equivalent ISO commercial date.

`%%(diary-julian-date)'
     Make a diary entry with today's equivalent date on the Julian
     calendar.

`%%(diary-astro-day-number)'
     Make a diary entry with today's equivalent astronomical (Julian)
     day number.

`%%(diary-hebrew-date)'
     Make a diary entry with today's equivalent date on the Hebrew
     calendar.

`%%(diary-islamic-date)'
     Make a diary entry with today's equivalent date on the Islamic
     calendar.

`%%(diary-french-date)'
     Make a diary entry with today's equivalent date on the French
     Revolutionary calendar.

`%%(diary-mayan-date)'
     Make a diary entry with today's equivalent date on the Mayan
     calendar.

Thus including the diary entry

     &%%(diary-hebrew-date)

causes every day's diary display to contain the equivalent date on the
Hebrew calendar, if you are using the fancy diary display.  (With simple
diary display, the line `&%%(diary-hebrew-date)' appears in the diary
for any date, but does nothing particularly useful.)

   These functions can be used to construct sexp diary entries based on
the Hebrew calendar in certain standard ways:

`%%(diary-rosh-hodesh)'
     Make a diary entry that tells the occurrence and ritual
     announcement of each new Hebrew month.

`%%(diary-parasha)'
     Make a Saturday diary entry that tells the weekly synagogue
     scripture reading.

`%%(diary-sabbath-candles)'
     Make a Friday diary entry that tells the *local time* of Sabbath
     candle lighting.

`%%(diary-omer)'
     Make a diary entry that gives the omer count, when appropriate.

`%%(diary-yahrzeit MONTH DAY YEAR) NAME'
     Make a diary entry marking the anniversary of a date of death.
     The date is the *Gregorian* (civil) date of death.  The diary
     entry appears on the proper Hebrew calendar anniversary and on the
     day before.  (In the European style, the order of the parameters
     is changed to DAY, MONTH, YEAR.)


File: xemacs.info,  Node: Appt Customizing,  Prev: Sexp Diary Entries,  Up: Calendar Customization

Customizing Appointment Reminders
.................................

   You can specify exactly how Emacs reminds you of an appointment, and
how far in advance it begins doing so, by setting these variables:

`appt-message-warning-time'
     The time in minutes before an appointment that the reminder
     begins.  The default is 10 minutes.

`appt-audible'
     If this is `t' (the default), Emacs rings the terminal bell for
     appointment reminders.

`appt-visible'
     If this is `t' (the default), Emacs displays the appointment
     message in echo area.

`appt-display-mode-line'
     If this is `t' (the default), Emacs displays the number of minutes
     to the appointment on the mode line.

`appt-msg-window'
     If this is `t' (the default), Emacs displays the appointment
     message in another window.

`appt-display-duration'
     The number of seconds an appointment message is displayed.  The
     default is 5 seconds.


File: xemacs.info,  Node: Sorting,  Next: Shell,  Prev: Calendar/Diary,  Up: Top

Sorting Text
============

   XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.


File: xemacs.info,  Node: Shell,  Next: Narrowing,  Prev: Sorting,  Up: Top

Running Shell Commands from XEmacs
==================================

   XEmacs has commands for passing single command lines to inferior
shell processes; it can also run a shell interactively with input and
output to an XEmacs buffer `*shell*'.

`M-!'
     Run a specified shell command line and display the output
     (`shell-command').

`M-|'
     Run a specified shell command line with region contents as input;
     optionally replace the region with the output
     (`shell-command-on-region').

`M-x shell'
     Run a subshell with input and output through an XEmacs buffer.
     You can then give commands interactively.

`M-x term'
     Run a subshell with input and output through an XEmacs buffer.
     You can then give commands interactively.  Full terminal emulation
     is available.

* Menu:

* Single Shell::         How to run one shell command and return.
* Interactive Shell::    Permanent shell taking input via XEmacs.
* Shell Mode::           Special XEmacs commands used with permanent shell.
* Terminal emulator::    An XEmacs window as a terminal emulator.
* Term Mode::            Special XEmacs commands used in Term mode.
* Paging in Term::       Paging in the terminal emulator.


File: xemacs.info,  Node: Single Shell,  Next: Interactive Shell,  Prev: Shell,  Up: Shell

Single Shell Commands
---------------------

   `M-!' (`shell-command') reads a line of text using the minibuffer
and creates an inferior shell to execute the line as a command.
Standard input from the command comes from the null device.  If the
shell command produces any output, the output goes to an XEmacs buffer
named `*Shell Command Output*', which is displayed in another window
but not selected.  A numeric argument, as in `M-1 M-!', directs this
command to insert any output into the current buffer.  In that case,
point is left before the output and the mark is set after the output.

   `M-|' (`shell-command-on-region') is like `M-!' but passes the
contents of the region as input to the shell command, instead of no
input.  If a numeric argument is used to direct  output to the current
buffer, then the old region is deleted first and the output replaces it
as the contents of the region.

   Both `M-!' and `M-|' use `shell-file-name' to specify the shell to
use.  This variable is initialized based on your `SHELL' environment
variable when you start XEmacs.  If the file name does not specify a
directory, the directories in the list `exec-path' are searched; this
list is initialized based on the `PATH' environment variable when you
start XEmacs.  You can override either or both of these default
initializations in your `.emacs' file.

   When you use `M-!' and `M-|', XEmacs has to wait until the shell
command completes.  You can quit with `C-g'; that terminates the shell
command.


File: xemacs.info,  Node: Interactive Shell,  Next: Shell Mode,  Prev: Single Shell,  Up: Shell

Interactive Inferior Shell
--------------------------

   To run a subshell interactively with its typescript in an XEmacs
buffer, use `M-x shell'.  This creates (or reuses) a buffer named
`*shell*' and runs a subshell with input coming from and output going
to that buffer.  That is to say, any "terminal output" from the subshell
will go into the buffer, advancing point, and any "terminal input" for
the subshell comes from text in the buffer.  To give input to the
subshell, go to the end of the buffer and type the input, terminated by
<RET>.

   XEmacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while
it is running a command.  Output from the subshell waits until XEmacs
has time to process it; this happens whenever XEmacs is waiting for
keyboard input or for time to elapse.

   To get multiple subshells, change the name of buffer `*shell*' to
something different by using `M-x rename-buffer'.  The next use of `M-x
shell' creates a new buffer `*shell*' with its own subshell.  By
renaming this buffer as well you can create a third one, and so on.
All the subshells run independently and in parallel.

   The file name used to load the subshell is the value of the variable
`explicit-shell-file-name', if that is non-`nil'.  Otherwise, the
environment variable `ESHELL' is used, or the environment variable
`SHELL' if there is no `ESHELL'.  If the file name specified is
relative, the directories in the list `exec-path' are searched (*note
Single Shell Commands: Single Shell.).

   As soon as the subshell is started, it is sent as input the contents
of the file `~/.emacs_SHELLNAME', if that file exists, where SHELLNAME
is the name of the file that the shell was loaded from.  For example,
if you use `csh', the file sent to it is `~/.emacs_csh'.

   `cd', `pushd', and `popd' commands given to the inferior shell are
watched by XEmacs so it can keep the `*shell*' buffer's default
directory the same as the shell's working directory.  These commands
are recognized syntactically by examining lines of input that are sent.
If you use aliases for these commands, you can tell XEmacs to
recognize them also.  For example, if the value of the variable
`shell-pushd-regexp' matches the beginning of a shell command line,
that line is regarded as a `pushd' command.  Change this variable when
you add aliases for `pushd'.  Likewise, `shell-popd-regexp' and
`shell-cd-regexp' are used to recognize commands with the meaning of
`popd' and `cd'.

   `M-x shell-resync-dirs' queries the shell and resynchronizes XEmacs'
idea of what the current directory stack is.  `M-x
shell-dirtrack-toggle' turns directory tracking on and off.

   XEmacs keeps a history of the most recent commands you have typed in
the `*shell*' buffer.  If you are at the beginning of a shell command
line and type <M-p>, the previous shell input is inserted into the
buffer before point.  Immediately typing <M-p> again deletes that input
and inserts the one before it.  By repeating <M-p> you can move
backward through your commands until you find one you want to repeat.
You may then edit the command before typing <RET> if you wish. <M-n>
moves forward through the command history, in case you moved backward
past the one you wanted while using <M-p>.  If you type the first few
characters of a previous command and then type <M-p>, the most recent
shell input starting with those characters is inserted.  This can be
very convenient when you are repeating a sequence of shell commands.
The variable `input-ring-size' controls how many commands are saved in
your input history.  The default is 30.


File: xemacs.info,  Node: Shell Mode,  Next: Terminal emulator,  Prev: Interactive Shell,  Up: Shell

Shell Mode
----------

   The shell buffer uses Shell mode, which defines several special keys
attached to the `C-c' prefix.  They are chosen to resemble the usual
editing and job control characters present in shells that are not under
XEmacs, except that you must type `C-c' first.  Here is a list of the
special key bindings of Shell mode:

`<RET>'
     At end of buffer send line as input; otherwise, copy current line
     to end of buffer and send it (`send-shell-input').  When a line is
     copied, any text at the beginning of the line that matches the
     variable `shell-prompt-pattern' is left out; this variable's value
     should be a regexp string that matches the prompts that you use in
     your subshell.

`C-c C-d'
     Send end-of-file as input, probably causing the shell or its
     current subjob to finish (`shell-send-eof').

`C-d'
     If point is not at the end of the buffer, delete the next
     character just like most other modes.  If point is at the end of
     the buffer, send end-of-file as input, instead of generating an
     error as in other modes (`comint-delchar-or-maybe-eof').

`C-c C-u'
     Kill all text that has yet to be sent as input
     (`kill-shell-input').

`C-c C-w'
     Kill a word before point (`backward-kill-word').

`C-c C-c'
     Interrupt the shell or its current subjob if any
     (`interrupt-shell-subjob').

`C-c C-z'
     Stop the shell or its current subjob if any (`stop-shell-subjob').

`C-c C-\'
     Send quit signal to the shell or its current subjob if any
     (`quit-shell-subjob').

`C-c C-o'
     Delete last batch of output from shell (`kill-output-from-shell').

`C-c C-r'
     Scroll top of last batch of output to top of window
     (`show-output-from-shell').

`C-c C-y'
     Copy the previous bunch of shell input and insert it into the
     buffer before point (`copy-last-shell-input').  No final newline
     is inserted, and the input copied is not resubmitted until you type
     <RET>.

`M-p'
     Move backward through the input history.  Search for a matching
     command if you have typed the beginning of a command
     (`comint-previous-input').

`M-n'
     Move forward through the input history.  Useful when you are using
     <M-p> quickly and go past the desired command
     (`comint-next-input').

`<TAB>'
     Complete the file name preceding point (`comint-dynamic-complete').


File: xemacs.info,  Node: Terminal emulator,  Next: Term Mode,  Prev: Shell Mode,  Up: Shell

Interactive Inferior Shell with Terminal Emulator
-------------------------------------------------

   To run a subshell in a terminal emulator, putting its typescript in
an XEmacs buffer, use `M-x term'.  This creates (or reuses) a buffer
named `*term*' and runs a subshell with input coming from your keyboard
and output going to that buffer.

   All the normal keys that you type are sent without any interpretation
by XEmacs directly to the subshell, as "terminal input."  Any "echo" of
your input is the responsibility of the subshell.  (The exception is
the terminal escape character, which by default is `C-c'. *note Term
Mode::..)  Any "terminal output" from the subshell goes into the buffer,
advancing point.

   Some programs (such as XEmacs itself) need to control the appearance
on the terminal screen in detail.  They do this by sending special
control codes.  The exact control codes needed vary from terminal to
terminal, but nowadays most terminals and terminal emulators (including
xterm) understand the so-called "ANSI escape sequences" (first
popularized by the Digital's VT100 family of terminal).  The term mode
also understands these escape sequences, and for each control code does
the appropriate thing to change the buffer so that the appearance of
the window will match what it would be on a real terminal.  Thus you
can actually run XEmacs inside an XEmacs Term window!

   XEmacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while
it is running a command.  Output from the subshell waits until XEmacs
has time to process it; this happens whenever XEmacs is waiting for
keyboard input or for time to elapse.

   To make multiple terminal emulators, rename the buffer `*term*' to
something different using `M-x rename-uniquely', just as with Shell
mode.

   The file name used to load the subshell is determined the same way
as for Shell mode.

   Unlike Shell mode, Term mode does not track the current directory by
examining your input.  Instead, if you use a programmable shell, you
can have it tell Term what the current directory is.  This is done
automatically by bash for version 1.15 and later.


File: xemacs.info,  Node: Term Mode,  Next: Paging in Term,  Prev: Terminal emulator,  Up: Shell

Term Mode
---------

   Term uses Term mode, which has two input modes: In line mode, Term
basically acts like Shell mode.  *Note Shell Mode::.  In Char mode,
each character is sent directly to the inferior subshell, except for
the Term escape character, normally `C-c'.

   To switch between line and char mode, use these commands:
     findex term-char-mode

`C-c C-k'
     Switch to line mode.  Do nothing if already in line mode.

`C-c C-j'
     Switch to char mode.  Do nothing if already in char mode.

   The following commands are only available in Char mode:
`C-c C-c'
     Send a literal <C-c> to the sub-shell.

`C-c C-x'
     A prefix command to conveniently access the global <C-x> commands.
     For example, `C-c C-x o' invokes the global binding of `C-x o',
     which is normally `other-window'.


File: xemacs.info,  Node: Paging in Term,  Prev: Term Mode,  Up: Shell

Paging in the terminal emulator
-------------------------------

   Term mode has a pager feature.  When the pager is enabled, term mode
will pause at the end of each screenful.

`C-c C-q'
     Toggles the pager feature:  Disables the pager if it is enabled,
     and vice versa.  This works in both line and char modes.  If the
     pager enabled, the mode-line contains the word `page'.

   If the pager is enabled, and Term receives more than a screenful of
output since your last input, Term will enter More break mode.  This is
indicated by `**MORE**' in the mode-line.  Type a `Space' to display
the next screenful of output.  Type `?' to see your other options.  The
interface is similar to the Unix `more' program.


File: xemacs.info,  Node: Narrowing,  Next: Hardcopy,  Prev: Shell,  Up: Top

Narrowing
=========

   "Narrowing" means focusing in on some portion of the buffer, making
the rest temporarily invisible and inaccessible.  Cancelling the
narrowing and making the entire buffer once again visible is called
"widening".  The amount of narrowing in effect in a buffer at any time
is called the buffer's "restriction".

`C-x n n'
     Narrow down to between point and mark (`narrow-to-region').

`C-x n w'
     Widen to make the entire buffer visible again (`widen').

   Narrowing sometimes makes it easier to concentrate on a single
subroutine or paragraph by eliminating clutter.  It can also be used to
restrict the range of operation of a replace command or repeating
keyboard macro.  The word `Narrow' appears in the mode line whenever
narrowing is in effect.  When you have narrowed to a part of the
buffer, that part appears to be all there is.  You can't see the rest,
can't move into it (motion commands won't go outside the visible part),
and can't change it in any way.  However, the invisible text is not
gone; if you save the file, it will be saved.

   The primary narrowing command is `C-x n n' (`narrow-to-region').  It
sets the current buffer's restrictions so that the text in the current
region remains visible but all text before the region or after the
region is invisible.  Point and mark do not change.

   Because narrowing can easily confuse users who do not understand it,
`narrow-to-region' is normally a disabled command.  Attempting to use
this command asks for confirmation and gives you the option of enabling
it; once you enable the command, confirmation will no longer be
required.  *Note Disabling::.

   To undo narrowing, use `C-x n w' (`widen').  This makes all text in
the buffer accessible again.

   Use the `C-x =' command to get information on what part of the
buffer you narrowed down.  *Note Position Info::.


File: xemacs.info,  Node: Hardcopy,  Next: Recursive Edit,  Prev: Narrowing,  Up: Top

Hardcopy Output
===============

   The XEmacs commands for making hardcopy derive their names from the
Unix commands `print' and `lpr'.

`M-x print-buffer'
     Print hardcopy of current buffer using Unix command `print'
     (`lpr -p').  This command adds page headings containing the file
     name and page number.

`M-x lpr-buffer'
     Print hardcopy of current buffer using Unix command `lpr'.  This
     command does not add page headings.

`M-x print-region'
     Like `print-buffer', but prints only the current region.

`M-x lpr-region'
     Like `lpr-buffer', but prints only the current region.

   All the hardcopy commands pass extra switches to the `lpr' program
based on the value of the variable `lpr-switches'.  Its value should be
a list of strings, each string a switch starting with `-'.  For
example, the value could be `("-Pfoo")' to print on printer `foo'.


File: xemacs.info,  Node: Recursive Edit,  Next: Dissociated Press,  Prev: Hardcopy,  Up: Top

Recursive Editing Levels
========================

   A "recursive edit" is a situation in which you are using XEmacs
commands to perform arbitrary editing while in the middle of another
XEmacs command.  For example, when you type `C-r' inside a
`query-replace', you enter a recursive edit in which you can change the
current buffer.  When you exit from the recursive edit, you go back to
the `query-replace'.

   "Exiting" a recursive edit means returning to the unfinished
command, which continues execution.  For example, exiting the recursive
edit requested by `C-r' in `query-replace' causes query replacing to
resume.  Exiting is done with `C-M-c' (`exit-recursive-edit').

   You can also "abort" a recursive edit.  This is like exiting, but
also quits the unfinished command immediately.  Use the command `C-]'
(`abort-recursive-edit') for this.  *Note Quitting::.

   The mode line shows you when you are in a recursive edit by
displaying square brackets around the parentheses that always surround
the major and minor mode names.  Every window's mode line shows the
square brackets, since XEmacs as a whole, rather than any particular
buffer, is in a recursive edit.

   It is possible to be in recursive edits within recursive edits.  For
example, after typing `C-r' in a `query-replace', you might type a
command that entered the debugger.  In such a case, two or more sets of
square brackets appear in the mode line(s).  Exiting the inner
recursive edit (here with the debugger `c' command) resumes the
query-replace command where it called the debugger.  After the end of
the query-replace command, you would be able to exit the first
recursive edit.  Aborting exits only one level of recursive edit; it
returns to the command level of the previous recursive edit.  You can
then abort that one as well.

   The command `M-x top-level' aborts all levels of recursive edits,
returning immediately to the top level command reader.

   The text you edit inside the recursive edit need not be the same text
that you were editing at top level.  If the command that invokes the
recursive edit selects a different buffer first, that is the buffer you
will edit recursively.  You can switch buffers within the recursive edit
in the normal manner (as long as the buffer-switching keys have not been
rebound).  While you could theoretically do the rest of your editing
inside the recursive edit, including visiting files, this could have
surprising effects (such as stack overflow) from time to time.  It is
best if you always exit or abort a recursive edit when you no longer
need it.

   In general, XEmacs tries to avoid using recursive edits.  It is
usually preferable to allow users to switch among the possible editing
modes in any order they like.  With recursive edits, the only way to get
to another state is to go "back" to the state that the recursive edit
was invoked from.


File: xemacs.info,  Node: Dissociated Press,  Next: CONX,  Prev: Recursive Edit,  Up: Top

Dissociated Press
=================

   `M-x dissociated-press' is a command for scrambling a file of text
either word by word or character by character.  Starting from a buffer
of straight English, it produces extremely amusing output.  The input
comes from the current XEmacs buffer.  Dissociated Press writes its
output in a buffer named `*Dissociation*', and redisplays that buffer
after every couple of lines (approximately) to facilitate reading it.

   `dissociated-press' asks every so often whether to continue
operating.  Answer `n' to stop it.  You can also stop at any time by
typing `C-g'.  The dissociation output remains in the `*Dissociation*'
buffer for you to copy elsewhere if you wish.

   Dissociated Press operates by jumping at random from one point in the
buffer to another.  In order to produce plausible output rather than
gibberish, it insists on a certain amount of overlap between the end of
one run of consecutive words or characters and the start of the next.
That is, if it has just printed out `president' and then decides to
jump to a different point in the file, it might spot the `ent' in
`pentagon' and continue from there, producing `presidentagon'.  Long
sample texts produce the best results.

   A positive argument to `M-x dissociated-press' tells it to operate
character by character, and specifies the number of overlap characters.
A negative argument tells it to operate word by word and specifies the
number of overlap words.  In this mode, whole words are treated as the
elements to be permuted, rather than characters.  No argument is
equivalent to an argument of two.  For your againformation, the output
goes only into the buffer `*Dissociation*'.  The buffer you start with
is not changed.

   Dissociated Press produces nearly the same results as a Markov chain
based on a frequency table constructed from the sample text.  It is,
however, an independent, ignoriginal invention.  Dissociated Press
techniquitously copies several consecutive characters from the sample
between random choices, whereas a Markov chain would choose randomly for
each word or character.  This makes for more plausible sounding results
and runs faster.

   It is a mustatement that too much use of Dissociated Press can be a
developediment to your real work.  Sometimes to the point of outragedy.
And keep dissociwords out of your documentation, if you want it to be
well userenced and properbose.  Have fun.  Your buggestions are welcome.


File: xemacs.info,  Node: CONX,  Next: Amusements,  Prev: Dissociated Press,  Up: Top

CONX
====

   Besides producing a file of scrambled text with Dissociated Press,
you can generate random sentences by using CONX.

`M-x conx'
     Generate random sentences in the `*conx*' buffer.

`M-x conx-buffer'
     Absorb the text in the current buffer into the `conx' database.

`M-x conx-init'
     Forget the current word-frequency tree.

`M-x conx-load'
     Load a `conx' database that has been previously saved with `M-x
     conx-save'.

`M-x conx-region'
     Absorb the text in the current buffer into the `conx' database.

`M-x conx-save'
     Save the current `conx' database to a file for future retrieval.

   Copy text from a buffer using `M-x conx-buffer' or `M-x conx-region'
and then type `M-x conx'.  Output is continuously generated until you
type <^G>. You can save the `conx' database to a file with `M-x
conx-save', which you can retrieve with `M-x conx-load'.  To clear the
database, use `M-x conx-init'.


File: xemacs.info,  Node: Amusements,  Next: Emulation,  Prev: CONX,  Up: Top

Other Amusements
================

   If you are a little bit bored, you can try `M-x hanoi'.  If you are
considerably bored, give it a numeric argument.  If you are very, very
bored, try an argument of 9.  Sit back and watch.

   When you are frustrated, try the famous Eliza program.  Just do `M-x
doctor'.  End each input by typing `RET' twice.

   When you are feeling strange, type `M-x yow'.


File: xemacs.info,  Node: Emulation,  Next: Customization,  Prev: Amusements,  Up: Top

Emulation
=========

   XEmacs can be programmed to emulate (more or less) most other
editors.  Standard facilities can emulate these:

Viper (a vi emulator)
     In XEmacs, Viper is the preferred emulation of vi within XEmacs.
     Viper is designed to allow you to take advantage of the best
     features of XEmacs while still doing your basic editing in a
     familiar, vi-like fashion.  Viper provides various different
     levels of vi emulation, from a quite complete emulation that
     allows almost no access to native XEmacs commands, to an "expert"
     mode that combines the most useful vi commands with the most
     useful XEmacs commands.

     To start Viper, put the command

          (viper-mode)

     in your `.emacs' file.

     Viper comes with a separate manual that is provided standard with
     the XEmacs distribution.

EDT (DEC VMS editor)
     Turn on EDT emulation with `M-x edt-emulation-on'.  `M-x
     edt-emulation-off' restores normal Emacs command bindings.

     Most of the EDT emulation commands are keypad keys, and most
     standard Emacs key bindings are still available.  The EDT
     emulation rebindings are done in the global keymap, so there is no
     problem switching buffers or major modes while in EDT emulation.

Gosling Emacs
     Turn on emulation of Gosling Emacs (aka Unipress Emacs) with `M-x
     set-gosmacs-bindings'.  This redefines many keys, mostly on the
     `C-x' and `ESC' prefixes, to work as they do in Gosmacs.  `M-x
     set-gnu-bindings' returns to normal XEmacs by rebinding the same
     keys to the definitions they had at the time `M-x
     set-gosmacs-bindings' was done.

     It is also possible to run Mocklisp code written for Gosling Emacs.
     *Note Mocklisp::.


File: xemacs.info,  Node: Customization,  Next: Quitting,  Prev: Emulation,  Up: Top

Customization
*************

   This chapter talks about various topics relevant to adapting the
behavior of Emacs in minor ways.

   All kinds of customization affect only the particular Emacs job that
you do them in.  They are completely lost when you kill the Emacs job,
and have no effect on other Emacs jobs you may run at the same time or
later.  The only way an Emacs job can affect anything outside of it is
by writing a file; in particular, the only way to make a customization
`permanent' is to put something in your `.emacs' file or other
appropriate file to do the customization in each session.  *Note Init
File::.

* Menu:

* Minor Modes::     Each minor mode is one feature you can turn on
                     independently of any others.
* Variables::       Many Emacs commands examine Emacs variables
                     to decide what to do; by setting variables,
                     you can control their functioning.
* Keyboard Macros:: A keyboard macro records a sequence of keystrokes
                     to be replayed with a single command.
* Key Bindings::    The keymaps say what command each key runs.
                     By changing them, you can "redefine keys".
* Syntax::          The syntax table controls how words and expressions
                     are parsed.
* Init File::       How to write common customizations in the `.emacs'
                     file.
* Audible Bell::    Changing how Emacs sounds the bell.
* Faces::           Changing the fonts and colors of a region of text.
* X Resources::	    X resources controlling various aspects of the
                     behavior of XEmacs.


File: xemacs.info,  Node: Minor Modes,  Next: Variables,  Up: Customization

Minor Modes
===========

   Minor modes are options which you can use or not.  For example, Auto
Fill mode is a minor mode in which <SPC> breaks lines between words as
you type.  All the minor modes are independent of each other and of the
selected major mode.  Most minor modes inform you in the mode line when
they are on; for example, `Fill' in the mode line means that Auto Fill
mode is on.

   Append `-mode' to the name of a minor mode to get the name of a
command function that turns the mode on or off.  Thus, the command to
enable or disable Auto Fill mode is called `M-x auto-fill-mode'.  These
commands are usually invoked with `M-x', but you can bind keys to them
if you wish.  With no argument, the function turns the mode on if it was
off and off if it was on.  This is known as "toggling".  A positive
argument always turns the mode on, and an explicit zero argument or a
negative argument always turns it off.

   Auto Fill mode allows you to enter filled text without breaking lines
explicitly.  Emacs inserts newlines as necessary to prevent lines from
becoming too long.  *Note Filling::.

   Overwrite mode causes ordinary printing characters to replace
existing text instead of moving it to the right.  For example, if point
is in front of the `B' in `FOOBAR', and you type a `G' in Overwrite
mode, it changes to `FOOGAR', instead of `FOOGBAR'.

   Abbrev mode allows you to define abbreviations that automatically
expand as you type them.  For example, `amd' might expand to `abbrev
mode'.  *Note Abbrevs::, for full information.


File: xemacs.info,  Node: Variables,  Next: Keyboard Macros,  Prev: Minor Modes,  Up: Customization

Variables
=========

   A "variable" is a Lisp symbol which has a value.  Variable names can
contain any characters, but by convention they are words separated by
hyphens.  A variable can also have a documentation string, which
describes what kind of value it should have and how the value will be
used.

   Lisp allows any variable to have any kind of value, but most
variables that Emacs uses require a value of a certain type.  Often the
value has to be a string or a number.  Sometimes we say that a certain
feature is turned on if a variable is "non-`nil'," meaning that if the
variable's value is `nil', the feature is off, but the feature is on
for any other value.  The conventional value to turn on the
feature--since you have to pick one particular value when you set the
variable--is `t'.

   Emacs uses many Lisp variables for internal recordkeeping, as any
Lisp program must, but the most interesting variables for you are the
ones that exist for the sake of customization.  Emacs does not
(usually) change the values of these variables; instead, you set the
values, and thereby alter and control the behavior of certain Emacs
commands.  These variables are called "options".  Most options are
documented in this manual and appear in the Variable Index (*note
Variable Index::.).

   One example of a variable which is an option is `fill-column', which
specifies the position of the right margin (as a number of characters
from the left margin) to be used by the fill commands (*note
Filling::.).

* Menu:

* Examining::           Examining or setting one variable's value.
* Easy Customization::  Convenient and easy customization of variables.
* Edit Options::        Examining or editing list of all variables' values.
* Locals::              Per-buffer values of variables.
* File Variables::      How files can specify variable values.


File: xemacs.info,  Node: Examining,  Next: Easy Customization,  Up: Variables

Examining and Setting Variables
-------------------------------

`C-h v'
`M-x describe-variable'
     Print the value and documentation of a variable.

`M-x set-variable'
     Change the value of a variable.

   To examine the value of a single variable, use `C-h v'
(`describe-variable'), which reads a variable name using the
minibuffer, with completion.  It prints both the value and the
documentation of the variable.

     C-h v fill-column <RET>

prints something like:

     fill-column's value is 75
     
     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes local when set in any fashion.

The star at the beginning of the documentation indicates that this
variable is an option.  `C-h v' is not restricted to options; it allows
any variable name.

   If you know which option you want to set, you can use `M-x
set-variable' to set it.  This prompts for the variable name in the
minibuffer (with completion), and then prompts for a Lisp expression
for the new value using the minibuffer a second time.  For example,

     M-x set-variable <RET> fill-column <RET> 75 <RET>

sets `fill-column' to 75, as if you had executed the Lisp expression
`(setq fill-column 75)'.

   Setting variables in this way, like all means of customizing Emacs
except where explicitly stated, affects only the current Emacs session.


File: xemacs.info,  Node: Easy Customization,  Next: Edit Options,  Prev: Examining,  Up: Variables

Easy Customization Interface
----------------------------

   A convenient way to find the user option variables that you want to
change, and then change them, is with `M-x customize'.  This command
creates a "customization buffer" with which you can browse through the
Emacs user options in a logically organized structure, then edit and
set their values.  You can also use the customization buffer to save
settings permanently.  (Not all Emacs user options are included in this
structure as of yet, but we are adding the rest.)

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.


File: xemacs.info,  Node: Customization Groups,  Next: Changing an Option,  Up: Easy Customization

Customization Groups
....................

   For customization purposes, user options are organized into "groups"
to help you find them.  Groups are collected into bigger groups, all
the way up to a master group called `Emacs'.

   `M-x customize' creates a customization buffer that shows the
top-level `Emacs' group and the second-level groups immediately under
it.  It looks like this, in part:

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].
     
      [Open] Editing group
     Basic text editing facilities.
     
      [Open] External group
     Interfacing to external utilities.
     
     MORE SECOND-LEVEL GROUPS
     
     \- Emacs group end ------------------------------------------------/

This says that the buffer displays the contents of the `Emacs' group.
The other groups are listed because they are its contents.  But they
are listed differently, without indentation and dashes, because *their*
contents are not included.  Each group has a single-line documentation
string; the `Emacs' group also has a `[State]' line.

   Most of the text in the customization buffer is read-only, but it
typically includes some "editable fields" that you can edit.  There are
also "active fields"; this means a field that does something when you
"invoke" it.  To invoke an active field, either click on it with
`Mouse-1', or move point to it and type <RET>.

   For example, the phrase `[Open]' that appears in a second-level
group is an active field.  Invoking the `[Open]' field for a group
opens up a new customization buffer, which shows that group and its
contents.  This field is a kind of hypertext link to another group.

   The `Emacs' group does not include any user options itself, but
other groups do.  By examining various groups, you will eventually find
the options and faces that belong to the feature you are interested in
customizing.  Then you can use the customization buffer to set them.

   You can view the structure of customization groups on a larger scale
with `M-x customize-browse'.  This command creates a special kind of
customization buffer which shows only the names of the groups (and
options and faces), and their structure.

   In this buffer, you can show the contents of a group by invoking
`[+]'.  When the group contents are visible, this button changes to
`[-]'; invoking that hides the group contents.

   Each group, option or face name in this buffer has an active field
which says `[Group]', `[Option]' or `[Face]'.  Invoking that active
field creates an ordinary customization buffer showing just that group
and its contents, just that option, or just that face.  This is the way
to set values in it.

