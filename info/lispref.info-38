This is ../info/lispref.info, produced by makeinfo version 4.0 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Truncation,  Next: The Echo Area,  Prev: Refresh Screen,  Up: Display

Truncation
==========

   When a line of text extends beyond the right edge of a window, the
line can either be truncated or continued on the next line.  When a line
is truncated, this is normally shown with a `\' in the rightmost column
of the window on X displays, and with a `$' on TTY devices.  When a
line is continued or "wrapped" onto the next line, this is shown with a
curved arrow in the rightmost column of the window (or with a `\' on
TTY devices).  The additional screen lines used to display a long text
line are called "continuation" lines.

   Normally, whenever line truncation is in effect for a particular
window, a horizontal scrollbar is displayed in that window if the
device supports scrollbars.  *Note Scrollbars::.

   Note that continuation is different from filling; continuation
happens on the screen only, not in the buffer contents, and it breaks a
line precisely at the right margin, not at a word boundary.  *Note
Filling::.

 - User Option: truncate-lines
     This buffer-local variable controls how XEmacs displays lines that
     extend beyond the right edge of the window.  If it is non-`nil',
     then XEmacs does not display continuation lines; rather each line
     of text occupies exactly one screen line, and a backslash appears
     at the edge of any line that extends to or beyond the edge of the
     window.  The default is `nil'.

     If the variable `truncate-partial-width-windows' is non-`nil',
     then truncation is always used for side-by-side windows (within one
     frame) regardless of the value of `truncate-lines'.

 - User Option: default-truncate-lines
     This variable is the default value for `truncate-lines', for
     buffers that do not have local values for it.

 - User Option: truncate-partial-width-windows
     This variable controls display of lines that extend beyond the
     right edge of the window, in side-by-side windows (*note Splitting
     Windows::).  If it is non-`nil', these lines are truncated;
     otherwise, `truncate-lines' says what to do with them.

   The backslash and curved arrow used to indicate truncated or
continued lines are only defaults, and can be changed.  These images
are actually glyphs (*note Glyphs::).  XEmacs provides a great deal of
flexibility in how glyphs can be controlled. (This differs from FSF
Emacs, which uses display tables to control these images.)

   For details, *Note Redisplay Glyphs::.


File: lispref.info,  Node: The Echo Area,  Next: Warnings,  Prev: Truncation,  Up: Display

The Echo Area
=============

   The "echo area" is used for displaying messages made with the
`message' primitive, and for echoing keystrokes.  It is not the same as
the minibuffer, despite the fact that the minibuffer appears (when
active) in the same place on the screen as the echo area.  The `XEmacs
Reference Manual' specifies the rules for resolving conflicts between
the echo area and the minibuffer for use of that screen space (*note
The Minibuffer: (emacs)Minibuffer.).  Error messages appear in the echo
area; see *Note Errors::.

   You can write output in the echo area by using the Lisp printing
functions with `t' as the stream (*note Output Functions::), or as
follows:

 - Function: message string &rest arguments
     This function displays a one-line message in the echo area.  The
     argument STRING is similar to a C language `printf' control
     string.  See `format' in *Note String Conversion::, for the details
     on the conversion specifications.  `message' returns the
     constructed string.

     In batch mode, `message' prints the message text on the standard
     error stream, followed by a newline.

     If STRING is `nil', `message' clears the echo area.  If the
     minibuffer is active, this brings the minibuffer contents back onto
     the screen immediately.

          (message "Minibuffer depth is %d."
                   (minibuffer-depth))
           -| Minibuffer depth is 0.
          => "Minibuffer depth is 0."
          
          ---------- Echo Area ----------
          Minibuffer depth is 0.
          ---------- Echo Area ----------

   In addition to only displaying a message, XEmacs allows you to
"label" your messages, giving you fine-grained control of their
display.  Message label is a symbol denoting the message type.  Some
standard labels are:

   * `message'--default label used by the `message' function;

   * `error'--default label used for reporting errors;

   * `progress'--progress indicators like `Converting... 45%' (not
     logged by default);

   * `prompt'--prompt-like messages like `Isearch: foo' (not logged by
     default);

   * `command'--helper command messages like `Mark set' (not logged by
     default);

   * `no-log'--messages that should never be logged

   Several messages may be stacked in the echo area at once.  Lisp
programs may access these messages, or remove them as appropriate, via
the message stack.

 - Function: display-message label message &optional frame stdout-p
     This function displays MESSAGE (a string) labeled as LABEL, as
     described above.

     The FRAME argument specifies the frame to whose minibuffer the
     message should be printed.  This is currently unimplemented.  The
     STDOUT-P argument is used internally.

          (display-message 'command "Mark set")

 - Function: lmessage label string &rest arguments
     This function displays a message STRING with label LABEL.  It is
     similar to `message' in that it accepts a `printf'-like strings
     and any number of arguments.

          ;; Display a command message.
          (lmessage 'command "Comment column set to %d" comment-column)
          
          ;; Display a progress message.
          (lmessage 'progress "Fontifying %s... (%d)" buffer percentage)
          
          ;; Display a message that should not be logged.
          (lmessage 'no-log "Done")

 - Function: clear-message &optional label frame stdout-p no-restore
     This function remove any message with the given LABEL from the
     message-stack, erasing it from the echo area if it's currently
     displayed there.

     If a message remains at the head of the message-stack and
     NO-RESTORE is `nil', it will be displayed.  The string which
     remains in the echo area will be returned, or `nil' if the
     message-stack is now empty.  If LABEL is nil, the entire
     message-stack is cleared.

          ;; Show a message, wait for 2 seconds, and restore old minibuffer
          ;; contents.
          (message "A message")
           -| A message
          => "A Message"
          (lmessage 'my-label "Newsflash!  Newsflash!")
           -| Newsflash!  Newsflash!
          => "Newsflash!  Newsflash!"
          (sit-for 2)
          (clear-message 'my-label)
           -| A message
          => "A message"

     Unless you need the return value or you need to specify a label,
     you should just use `(message nil)'.

 - Function: current-message &optional frame
     This function returns the current message in the echo area, or
     `nil'.  The FRAME argument is currently unused.

   Some of the messages displayed in the echo area are also recorded in
the ` *Message-Log*' buffer.  Exactly which messages will be recorded
can be tuned using the following variables.

 - User Option: log-message-max-size
     This variable specifies the maximum size of the ` *Message-log*'
     buffer.

 - Variable: log-message-ignore-labels
     This variable specifies the labels whose messages will not be
     logged.  It should be a list of symbols.

 - Variable: log-message-ignore-regexps
     This variable specifies the regular expressions matching messages
     that will not be logged.  It should be a list of regular
     expressions.

     Normally, packages that generate messages that might need to be
     ignored should label them with `progress', `prompt', or `no-log',
     so they can be filtered by `log-message-ignore-labels'.

 - Variable: echo-keystrokes
     This variable determines how much time should elapse before command
     characters echo.  Its value must be a number, which specifies the
     number of seconds to wait before echoing.  If the user types a
     prefix key (such as `C-x') and then delays this many seconds
     before continuing, the prefix key is echoed in the echo area.  Any
     subsequent characters in the same command will be echoed as well.

     If the value is zero, then command input is not echoed.

 - Variable: cursor-in-echo-area
     This variable controls where the cursor appears when a message is
     displayed in the echo area.  If it is non-`nil', then the cursor
     appears at the end of the message.  Otherwise, the cursor appears
     at point--not in the echo area at all.

     The value is normally `nil'; Lisp programs bind it to `t' for
     brief periods of time.


File: lispref.info,  Node: Warnings,  Next: Invisible Text,  Prev: The Echo Area,  Up: Display

Warnings
========

   XEmacs contains a facility for unified display of various warnings.
Unlike errors, warnings are displayed in the situations when XEmacs
encounters a problem that is recoverable, but which should be fixed for
safe future operation.

   For example, warnings are printed by the startup code when it
encounters problems with X keysyms, when there is an error in `.emacs',
and in other problematic situations.  Unlike messages, warnings are
displayed in a separate buffer, and include an explanatory message that
may span across several lines.  Here is an example of how a warning is
displayed:

     (1) (initialization/error) An error has occurred while loading ~/.emacs:
     
     Symbol's value as variable is void: bogus-variable
     
     To ensure normal operation, you should investigate the cause of the error
     in your initialization file and remove it.  Use the `-debug-init' option
     to XEmacs to view a complete error backtrace.

   Each warning has a "class" and a "priority level".  The class is a
symbol describing what sort of warning this is, such as
`initialization', `resource' or `key-mapping'.

   The warning priority level specifies how important the warning is.
The recognized warning levels, in increased order of priority, are:
`debug', `info', `notice', `warning', `error', `critical', `alert' and
`emergency'.

 - Function: display-warning class message &optional level
     This function displays a warning message MESSAGE (a string).
     CLASS should be a warning class symbol, as described above, or a
     list of such symbols.  LEVEL describes the warning priority level.
     If unspecified, it default to `warning'.

          (display-warning 'resource
            "Bad resource specification encountered:
          something like
          
              Emacs*foo: bar
          
          You should replace the * with a . in order to get proper behavior when
          you use the specifier and/or `set-face-*' functions.")
          
          ---------- Warning buffer ----------
          (1) (resource/warning) Bad resource specification encountered:
          something like
          
              Emacs*foo: bar
          
          You should replace the * with a . in order to get proper behavior when
          you use the specifier and/or `set-face-*' functions.
          ---------- Warning buffer ----------

 - Function: lwarn class level message &rest args
     This function displays a formatted labeled warning message.  As
     above, CLASS should be the warning class symbol, or a list of such
     symbols, and LEVEL should specify the warning priority level
     (`warning' by default).

     Unlike in `display-warning', MESSAGE may be a formatted message,
     which will be, together with the rest of the arguments, passed to
     `format'.

          (lwarn 'message-log 'warning
            "Error caught in `remove-message-hook': %s"
            (error-message-string e))

 - Variable: log-warning-minimum-level
     This variable specifies the minimum level of warnings that should
     be generated.  Warnings with level lower than defined by this
     variable are completely ignored, as if they never happened.

 - Variable: display-warning-minimum-level
     This variable specifies the minimum level of warnings that should
     be displayed.  Unlike `log-warning-minimum-level', setting this
     function does not suppress warnings entirely--they are still
     generated in the `*Warnings*' buffer, only they are not displayed
     by default.

 - Variable: log-warning-suppressed-classes
     This variable specifies a list of classes that should not be
     logged or displayed.  If any of the class symbols associated with
     a warning is the same as any of the symbols listed here, the
     warning will be completely ignored, as it they never happened.

 - Variable: display-warning-suppressed-classes
     This variable specifies a list of classes that should not be
     logged or displayed.  If any of the class symbols associated with
     a warning is the same as any of the symbols listed here, the
     warning will not be displayed.  The warning will still logged in
     the *Warnings* buffer (unless also contained in
     `log-warning-suppressed-classes'), but the buffer will not be
     automatically popped up.


File: lispref.info,  Node: Invisible Text,  Next: Selective Display,  Prev: Warnings,  Up: Display

Invisible Text
==============

   You can make characters "invisible", so that they do not appear on
the screen, with the `invisible' property.  This can be either a text
property or a property of an overlay.

   In the simplest case, any non-`nil' `invisible' property makes a
character invisible.  This is the default case--if you don't alter the
default value of `buffer-invisibility-spec', this is how the
`invisibility' property works.  This feature is much like selective
display (*note Selective Display::), but more general and cleaner.

   More generally, you can use the variable `buffer-invisibility-spec'
to control which values of the `invisible' property make text
invisible.  This permits you to classify the text into different subsets
in advance, by giving them different `invisible' values, and
subsequently make various subsets visible or invisible by changing the
value of `buffer-invisibility-spec'.

   Controlling visibility with `buffer-invisibility-spec' is especially
useful in a program to display the list of entries in a data base.  It
permits the implementation of convenient filtering commands to view
just a part of the entries in the data base.  Setting this variable is
very fast, much faster than scanning all the text in the buffer looking
for properties to change.

 - Variable: buffer-invisibility-spec
     This variable specifies which kinds of `invisible' properties
     actually make a character invisible.

    `t'
          A character is invisible if its `invisible' property is
          non-`nil'.  This is the default.

    a list
          Each element of the list makes certain characters invisible.
          Ultimately, a character is invisible if any of the elements
          of this list applies to it.  The list can have two kinds of
          elements:

         `ATOM'
               A character is invisible if its `invisible' property
               value is ATOM or if it is a list with ATOM as a member.

         `(ATOM . t)'
               A character is invisible if its `invisible' property
               value is ATOM or if it is a list with ATOM as a member.
               Moreover, if this character is at the end of a line and
               is followed by a visible newline, it displays an
               ellipsis.

   Ordinarily, commands that operate on text or move point do not care
whether the text is invisible.  However, the user-level line motion
commands explicitly ignore invisible newlines.


File: lispref.info,  Node: Selective Display,  Next: Overlay Arrow,  Prev: Invisible Text,  Up: Display

Selective Display
=================

   "Selective display" is a pair of features that hide certain lines on
the screen.

   The first variant, explicit selective display, is designed for use in
a Lisp program.  The program controls which lines are hidden by altering
the text.  Outline mode has traditionally used this variant.  It has
been partially replaced by the invisible text feature (*note Invisible
Text::); there is a new version of Outline mode which uses that instead.

   In the second variant, the choice of lines to hide is made
automatically based on indentation.  This variant is designed to be a
user-level feature.

   The way you control explicit selective display is by replacing a
newline (control-j) with a carriage return (control-m).  The text that
was formerly a line following that newline is now invisible.  Strictly
speaking, it is temporarily no longer a line at all, since only newlines
can separate lines; it is now part of the previous line.

   Selective display does not directly affect editing commands.  For
example, `C-f' (`forward-char') moves point unhesitatingly into
invisible text.  However, the replacement of newline characters with
carriage return characters affects some editing commands.  For example,
`next-line' skips invisible lines, since it searches only for newlines.
Modes that use selective display can also define commands that take
account of the newlines, or that make parts of the text visible or
invisible.

   When you write a selectively displayed buffer into a file, all the
control-m's are output as newlines.  This means that when you next read
in the file, it looks OK, with nothing invisible.  The selective display
effect is seen only within XEmacs.

 - Variable: selective-display
     This buffer-local variable enables selective display.  This means
     that lines, or portions of lines, may be made invisible.

        * If the value of `selective-display' is `t', then any portion
          of a line that follows a control-m is not displayed.

        * If the value of `selective-display' is a positive integer,
          then lines that start with more than that many columns of
          indentation are not displayed.

     When some portion of a buffer is invisible, the vertical movement
     commands operate as if that portion did not exist, allowing a
     single `next-line' command to skip any number of invisible lines.
     However, character movement commands (such as `forward-char') do
     not skip the invisible portion, and it is possible (if tricky) to
     insert or delete text in an invisible portion.

     In the examples below, we show the _display appearance_ of the
     buffer `foo', which changes with the value of `selective-display'.
     The _contents_ of the buffer do not change.

          (setq selective-display nil)
               => nil
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column
            3n this column
            3n this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------
          
          (setq selective-display 2)
               => 2
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

 - Variable: selective-display-ellipses
     If this buffer-local variable is non-`nil', then XEmacs displays
     `...' at the end of a line that is followed by invisible text.
     This example is a continuation of the previous one.

          (setq selective-display-ellipses t)
               => t
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column ...
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

     You can use a display table to substitute other text for the
     ellipsis (`...').  *Note Display Tables::.


File: lispref.info,  Node: Overlay Arrow,  Next: Temporary Displays,  Prev: Selective Display,  Up: Display

The Overlay Arrow
=================

   The "overlay arrow" is useful for directing the user's attention to
a particular line in a buffer.  For example, in the modes used for
interface to debuggers, the overlay arrow indicates the line of code
about to be executed.

 - Variable: overlay-arrow-string
     This variable holds the string to display to call attention to a
     particular line, or `nil' if the arrow feature is not in use.
     Despite its name, the value of this variable can be either a string
     or a glyph (*note Glyphs::).

 - Variable: overlay-arrow-position
     This variable holds a marker that indicates where to display the
     overlay arrow.  It should point at the beginning of a line.  The
     arrow text appears at the beginning of that line, overlaying any
     text that would otherwise appear.  Since the arrow is usually
     short, and the line usually begins with indentation, normally
     nothing significant is overwritten.

     The overlay string is displayed only in the buffer that this marker
     points into.  Thus, only one buffer can have an overlay arrow at
     any given time.

   You can do the same job by creating an extent with a `begin-glyph'
property.  *Note Extent Properties::.


File: lispref.info,  Node: Temporary Displays,  Next: Blinking,  Prev: Overlay Arrow,  Up: Display

Temporary Displays
==================

   Temporary displays are used by commands to put output into a buffer
and then present it to the user for perusal rather than for editing.
Many of the help commands use this feature.

 - Special Form: with-output-to-temp-buffer buffer-name forms...
     This function executes FORMS while arranging to insert any output
     they print into the buffer named BUFFER-NAME.  The buffer is then
     shown in some window for viewing, displayed but not selected.

     The string BUFFER-NAME specifies the temporary buffer, which need
     not already exist.  The argument must be a string, not a buffer.
     The buffer is erased initially (with no questions asked), and it is
     marked as unmodified after `with-output-to-temp-buffer' exits.

     `with-output-to-temp-buffer' binds `standard-output' to the
     temporary buffer, then it evaluates the forms in FORMS.  Output
     using the Lisp output functions within FORMS goes by default to
     that buffer (but screen display and messages in the echo area,
     although they are "output" in the general sense of the word, are
     not affected).  *Note Output Functions::.

     The value of the last form in FORMS is returned.

          ---------- Buffer: foo ----------
           This is the contents of foo.
          ---------- Buffer: foo ----------
          
          (with-output-to-temp-buffer "foo"
              (print 20)
              (print standard-output))
          => #<buffer foo>
          
          ---------- Buffer: foo ----------
          20
          
          #<buffer foo>
          
          ---------- Buffer: foo ----------

 - Variable: temp-buffer-show-function
     If this variable is non-`nil', `with-output-to-temp-buffer' calls
     it as a function to do the job of displaying a help buffer.  The
     function gets one argument, which is the buffer it should display.

     In Emacs versions 18 and earlier, this variable was called
     `temp-buffer-show-hook'.

 - Function: momentary-string-display string position &optional char
          message
     This function momentarily displays STRING in the current buffer at
     POSITION.  It has no effect on the undo list or on the buffer's
     modification status.

     The momentary display remains until the next input event.  If the
     next input event is CHAR, `momentary-string-display' ignores it
     and returns.  Otherwise, that event remains buffered for
     subsequent use as input.  Thus, typing CHAR will simply remove the
     string from the display, while typing (say) `C-f' will remove the
     string from the display and later (presumably) move point forward.
     The argument CHAR is a space by default.

     The return value of `momentary-string-display' is not meaningful.

     You can do the same job in a more general way by creating an extent
     with a begin-glyph property.  *Note Extent Properties::.

     If MESSAGE is non-`nil', it is displayed in the echo area while
     STRING is displayed in the buffer.  If it is `nil', a default
     message says to type CHAR to continue.

     In this example, point is initially located at the beginning of the
     second line:

          ---------- Buffer: foo ----------
          This is the contents of foo.
          -!-Second line.
          ---------- Buffer: foo ----------
          
          (momentary-string-display
            "**** Important Message! ****"
            (point) ?\r
            "Type RET when done reading")
          => t
          
          ---------- Buffer: foo ----------
          This is the contents of foo.
          **** Important Message! ****Second line.
          ---------- Buffer: foo ----------
          
          ---------- Echo Area ----------
          Type RET when done reading
          ---------- Echo Area ----------

     This function works by actually changing the text in the buffer.
     As a result, if you later undo in this buffer, you will see the
     message come and go.


File: lispref.info,  Node: Blinking,  Next: Usual Display,  Prev: Temporary Displays,  Up: Display

Blinking Parentheses
====================

   This section describes the mechanism by which XEmacs shows a matching
open parenthesis when the user inserts a close parenthesis.

 - Variable: blink-paren-function
     The value of this variable should be a function (of no arguments)
     to be called whenever a character with close parenthesis syntax is
     inserted.  The value of `blink-paren-function' may be `nil', in
     which case nothing is done.

          *Please note:* This variable was named `blink-paren-hook' in
          older Emacs versions, but since it is not called with the
          standard convention for hooks, it was renamed to
          `blink-paren-function' in version 19.

 - Variable: blink-matching-paren
     If this variable is `nil', then `blink-matching-open' does nothing.

 - Variable: blink-matching-paren-distance
     This variable specifies the maximum distance to scan for a matching
     parenthesis before giving up.

 - Variable: blink-matching-paren-delay
     This variable specifies the number of seconds for the cursor to
     remain at the matching parenthesis.  A fraction of a second often
     gives good results, but the default is 1, which works on all
     systems.

 - Function: blink-matching-open
     This function is the default value of `blink-paren-function'.  It
     assumes that point follows a character with close parenthesis
     syntax and moves the cursor momentarily to the matching opening
     character.  If that character is not already on the screen, it
     displays the character's context in the echo area.  To avoid long
     delays, this function does not search farther than
     `blink-matching-paren-distance' characters.

     Here is an example of calling this function explicitly.

          (defun interactive-blink-matching-open ()
            "Indicate momentarily the start of sexp before point."
            (interactive)
            (let ((blink-matching-paren-distance
                   (buffer-size))
                  (blink-matching-paren t))
              (blink-matching-open)))


File: lispref.info,  Node: Usual Display,  Next: Display Tables,  Prev: Blinking,  Up: Display

Usual Display Conventions
=========================

   The usual display conventions define how to display each character
code.  You can override these conventions by setting up a display table
(*note Display Tables::).  Here are the usual display conventions:

   * Character codes 32 through 126 map to glyph codes 32 through 126.
     Normally this means they display as themselves.

   * Character code 9 is a horizontal tab.  It displays as whitespace
     up to a position determined by `tab-width'.

   * Character code 10 is a newline.

   * All other codes in the range 0 through 31, and code 127, display
     in one of two ways according to the value of `ctl-arrow'.  If it is
     non-`nil', these codes map to sequences of two glyphs, where the
     first glyph is the ASCII code for `^'.  (A display table can
     specify a glyph to use instead of `^'.)  Otherwise, these codes map
     just like the codes in the range 128 to 255.

   * Character codes 128 through 255 map to sequences of four glyphs,
     where the first glyph is the ASCII code for `\', and the others are
     digit characters representing the code in octal.  (A display table
     can specify a glyph to use instead of `\'.)

   The usual display conventions apply even when there is a display
table, for any character whose entry in the active display table is
`nil'.  Thus, when you set up a display table, you need only specify
the characters for which you want unusual behavior.

   These variables affect the way certain characters are displayed on
the screen.  Since they change the number of columns the characters
occupy, they also affect the indentation functions.

 - User Option: ctl-arrow
     This buffer-local variable controls how control characters are
     displayed.  If it is non-`nil', they are displayed as a caret
     followed by the character: `^A'.  If it is `nil', they are
     displayed as a backslash followed by three octal digits: `\001'.

 - Variable: default-ctl-arrow
     The value of this variable is the default value for `ctl-arrow' in
     buffers that do not override it.  *Note Default Value::.

 - User Option: tab-width
     The value of this variable is the spacing between tab stops used
     for displaying tab characters in Emacs buffers.  The default is 8.
     Note that this feature is completely independent from the
     user-settable tab stops used by the command `tab-to-tab-stop'.
     *Note Indent Tabs::.


File: lispref.info,  Node: Display Tables,  Next: Beeping,  Prev: Usual Display,  Up: Display

Display Tables
==============

   You can use the "display table" feature to control how all 256
possible character codes display on the screen.  This is useful for
displaying European languages that have letters not in the ASCII
character set.

   The display table maps each character code into a sequence of
"runes", each rune being an image that takes up one character position
on the screen.  You can also define how to display each rune on your
terminal, using the "rune table".

* Menu:

* Display Table Format::	What a display table consists of.
* Active Display Table::	How XEmacs selects a display table to use.
* Character Descriptors::	Format of an individual element of a
				  display table.


File: lispref.info,  Node: Display Table Format,  Next: Active Display Table,  Up: Display Tables

Display Table Format
--------------------

   A display table is an array of 256 elements. (In FSF Emacs, a display
table is 262 elements.  The six extra elements specify the truncation
and continuation glyphs, etc.  This method is very kludgey, and in
XEmacs the variables `truncation-glyph', `continuation-glyph', etc. are
used.  *Note Truncation::.)

 - Function: make-display-table
     This creates and returns a display table.  The table initially has
     `nil' in all elements.

   The 256 elements correspond to character codes; the Nth element says
how to display the character code N.  The value should be `nil', a
string, a glyph, or a vector of strings and glyphs (*note Character
Descriptors::).  If an element is `nil', it says to display that
character according to the usual display conventions (*note Usual
Display::).

   If you use the display table to change the display of newline
characters, the whole buffer will be displayed as one long "line."

   For example, here is how to construct a display table that mimics the
effect of setting `ctl-arrow' to a non-`nil' value:

     (setq disptab (make-display-table))
     (let ((i 0))
       (while (< i 32)
         (or (= i ?\t) (= i ?\n)
             (aset disptab i (concat "^" (char-to-string (+ i 64)))))
         (setq i (1+ i)))
       (aset disptab 127 "^?"))


File: lispref.info,  Node: Active Display Table,  Next: Character Descriptors,  Prev: Display Table Format,  Up: Display Tables

Active Display Table
--------------------

   The active display table is controlled by the variable
`current-display-table'.  This is a specifier, which means that you can
specify separate values for it in individual buffers, windows, frames,
and devices, as well as a global value.  It also means that you cannot
set this variable using `setq'; use `set-specifier' instead.  *Note
Specifiers::. (FSF Emacs uses `window-display-table',
`buffer-display-table', `standard-display-table', etc. to control the
display table.  However, specifiers are a cleaner and more powerful way
of doing the same thing.  FSF Emacs also uses a different format for
the contents of a display table, using additional indirection to a
"glyph table" and such.  Note that "glyph" has a different meaning in
XEmacs.)

 - Variable: current-display-table
     The display table currently in use.  This is a specifier.

     Display tables are used to control how characters are displayed.
     Each time that redisplay processes a character, it is looked up in
     all the display tables that apply (obtained by calling
     `specifier-instance' on `current-display-table' and any overriding
     display tables specified in currently active faces).  The first
     entry found that matches the character determines how the
     character is displayed.  If there is no matching entry, the
     default display method is used. (Non-control characters are
     displayed as themselves and control characters are displayed
     according to the buffer-local variable `ctl-arrow'.  Control
     characters are further affected by `control-arrow-glyph' and
     `octal-escape-glyph'.)

     Each instantiator in this specifier and the display-table
     specifiers in faces is a display table or a list of such tables.
     If a list, each table will be searched in turn for an entry
     matching a particular character.  Each display table is one of

        * A vector, specifying values for characters starting at 0.

        * A char table, either of type `char' or `generic'.

        * A range table.

     Each entry in a display table should be one of

        * nil (this entry is ignored and the search continues).

        * A character (use this character; if it happens to be the same
          as the original character, default processing happens,
          otherwise redisplay attempts to display this character
          directly; #### At some point recursive display-table lookup
          will be implemented).

        * A string (display each character in the string directly; ####
          At some point recursive display-table lookup will be
          implemented).

        * A glyph (display the glyph; #### At some point recursive
          display-table lookup will be implemented when a string glyph
          is being processed).

        * A cons of the form (format "STRING") where STRING is a
          printf-like spec used to process the character. ####
          Unfortunately no formatting directives other than %% are
          implemented.

        * A vector (each element of the vector is processed recursively;
          in such a case, nil elements in the vector are simply
          ignored).

          #### At some point in the near future, display tables are
          likely to be expanded to include other features, such as
          referencing characters in particular fonts and allowing the
          character search to continue all the way up the chain of
          specifier instantiators.  These features are necessary to
          properly display Unicode characters.

   Individual faces can also specify an overriding display table; this
is set using `set-face-display-table'.  *Note Faces::.

   If no display table can be determined for a particular window, then
XEmacs uses the usual display conventions.  *Note Usual Display::.


File: lispref.info,  Node: Character Descriptors,  Prev: Active Display Table,  Up: Display Tables

Character Descriptors
---------------------

   Each element of the display-table vector describes how to display a
particular character and is called a "character descriptor".  A
character descriptor can be:

a string
     Display this particular string wherever the character is to be
     displayed.

a glyph
     Display this particular glyph wherever the character is to be
     displayed.

a vector
     The vector may contain strings and/or glyphs.  Display the
     elements of the vector one after another wherever the character is
     to be displayed.

`nil'
     Display according to the standard interpretation (*note Usual
     Display::).


File: lispref.info,  Node: Beeping,  Prev: Display Tables,  Up: Display

Beeping
=======

   You can make XEmacs ring a bell, play a sound, or blink the screen to
attract the user's attention.  Be conservative about how often you do
this; frequent bells can become irritating.  Also be careful not to use
beeping alone when signaling an error is appropriate.  (*Note Errors::.)

 - Function: ding &optional dont-terminate sound device
     This function beeps, or flashes the screen (see `visible-bell'
     below).  It also terminates any keyboard macro currently executing
     unless DONT-TERMINATE is non-`nil'.  If SOUND is specified, it
     should be a symbol specifying which sound to make.  This sound
     will be played if `visible-bell' is `nil'. (This only works if
     sound support was compiled into the executable and you are running
     on the console of a Sun SparcStation, SGI, HP9000s700, or Linux
     PC. Otherwise you just get a beep.) The optional third argument
     specifies what device to make the sound on, and defaults to the
     selected device.

 - Function: beep &optional dont-terminate sound device
     This is a synonym for `ding'.

 - User Option: visible-bell
     This variable determines whether XEmacs should flash the screen to
     represent a bell.  Non-`nil' means yes, `nil' means no.  On TTY
     devices, this is effective only if the Termcap entry for the
     terminal type has the visible bell flag (`vb') set.

 - Variable: sound-alist
     This variable holds an alist associating names with sounds.  When
     `beep' or `ding' is called with one of the name symbols, the
     associated sound will be generated instead of the standard beep.

     Each element of `sound-alist' is a list describing a sound.  The
     first element of the list is the name of the sound being defined.
     Subsequent elements of the list are alternating keyword/value
     pairs:

    `sound'
          A string of raw sound data, or the name of another sound to
          play.  The symbol `t' here means use the default X beep.

    `volume'
          An integer from 0-100, defaulting to `bell-volume'.

    `pitch'
          If using the default X beep, the pitch (Hz) to generate.

    `duration'
          If using the default X beep, the duration (milliseconds).

     For compatibility, elements of `sound-alist' may also be:

        * `( sound-name . <sound> )'

        * `( sound-name <volume> <sound> )'

     You should probably add things to this list by calling the function
     `load-sound-file'.

     Caveats:

        - You can only play audio data if running on the console screen
          of a Sun SparcStation, SGI, or HP9000s700.

        - The pitch, duration, and volume options are available
          everywhere, but many X servers ignore the `pitch' option.

     The following beep-types are used by XEmacs itself:

    `auto-save-error'
          when an auto-save does not succeed

    `command-error'
          when the XEmacs command loop catches an error

    `undefined-key'
          when you type a key that is undefined

    `undefined-click'
          when you use an undefined mouse-click combination

    `no-completion'
          during completing-read

    `y-or-n-p'
          when you type something other than 'y' or 'n'

    `yes-or-no-p'
          when you type something other than 'yes' or 'no'

    `default'
          used when nothing else is appropriate.

     Other lisp packages may use other beep types, but these are the
     ones that the C kernel of XEmacs uses.

 - User Option: bell-volume
     This variable specifies the default volume for sounds, from 0 to
     100.

 - Command: load-default-sounds
     This function loads and installs some sound files as beep-types.

 - Command: load-sound-file filename sound-name &optional volume
     This function reads in an audio file and adds it to `sound-alist'.
     The sound file must be in the Sun/NeXT U-LAW format.  SOUND-NAME
     should be a symbol, specifying the name of the sound.  If VOLUME
     is specified, the sound will be played at that volume; otherwise,
     the value of BELL-VOLUME will be used.

 - Function: play-sound sound &optional volume device
     This function plays sound SOUND, which should be a symbol
     mentioned in `sound-alist'.  If VOLUME is specified, it overrides
     the value (if any) specified in `sound-alist'.  DEVICE specifies
     the device to play the sound on, and defaults to the selected
     device.

 - Command: play-sound-file file &optional volume device
     This function plays the named sound file at volume VOLUME, which
     defaults to `bell-volume'.  DEVICE specifies the device to play
     the sound on, and defaults to the selected device.


File: lispref.info,  Node: Hash Tables,  Next: Range Tables,  Prev: Display,  Up: Top

Hash Tables
***********

 - Function: hash-table-p object
     This function returns `t' if OBJECT is a hash table, else `nil'.

* Menu:

* Introduction to Hash Tables::	Hash tables are fast data structures for
                                implementing simple tables (i.e. finite
                                mappings from keys to values).
* Working With Hash Tables::    Hash table functions.
* Weak Hash Tables::            Hash tables with special garbage-collection
                                behavior.


File: lispref.info,  Node: Introduction to Hash Tables,  Next: Working With Hash Tables,  Up: Hash Tables

Introduction to Hash Tables
===========================

   A "hash table" is a data structure that provides mappings from
arbitrary Lisp objects called "keys" to other arbitrary Lisp objects
called "values".  A key/value pair is sometimes called an "entry" in
the hash table.  There are many ways other than hash tables of
implementing the same sort of mapping, e.g.  association lists (*note
Association Lists::) and property lists (*note Property Lists::), but
hash tables provide much faster lookup when there are many entries in
the mapping.  Hash tables are an implementation of the abstract data
type "dictionary", also known as "associative array".

   Internally, hash tables are hashed using the "linear probing" hash
table implementation method.  This method hashes each key to a
particular spot in the hash table, and then scans forward sequentially
until a blank entry is found.  To look up a key, hash to the appropriate
spot, then search forward for the key until either a key is found or a
blank entry stops the search.  This method is used in preference to
double hashing because of changes in recent hardware.  The penalty for
non-sequential access to memory has been increasing, and this
compensates for the problem of clustering that linear probing entails.

   When hash tables are created, the user may (but is not required to)
specify initial properties that influence performance.

   Use the `:size' parameter to specify the number of entries that are
likely to be stored in the hash table, to avoid the overhead of resizing
the table.  But if the pre-allocated space for the entries is never
used, it is simply wasted and makes XEmacs slower.  Excess unused hash
table entries exact a small continuous performance penalty, since they
must be scanned at every garbage collection.  If the number of entries
in the hash table is unknown, simply avoid using the `:size' keyword.

   Use the `:rehash-size' and `:rehash-threshold' keywords to adjust
the algorithm for deciding when to rehash the hash table.  For
temporary hash tables that are going to be very heavily used, use a
small rehash threshold, for example, 0.4 and a large rehash size, for
example 2.0.  For permanent hash tables that will be infrequently used,
specify a large rehash threshold, for example 0.8.

   Hash tables can also be created by the lisp reader using structure
syntax, for example:
     #s(hash-table size 20 data (foo 1 bar 2))

   The structure syntax accepts the same keywords as `make-hash-table'
(without the `:' character), as well as the additional keyword `data',
which specifies the initial hash table contents.

 - Function: make-hash-table &key `test' `size' `rehash-size'
          `rehash-threshold' `weakness'
     This function returns a new empty hash table object.

     Keyword `:test' can be `eq', `eql' (default) or `equal'.
     Comparison between keys is done using this function.  If speed is
     important, consider using `eq'.  When storing strings in the hash
     table, you will likely need to use `equal'.

     Keyword `:size' specifies the number of keys likely to be inserted.
     This number of entries can be inserted without enlarging the hash
     table.

     Keyword `:rehash-size' must be a float greater than 1.0, and
     specifies the factor by which to increase the size of the hash
     table when enlarging.

     Keyword `:rehash-threshold' must be a float between 0.0 and 1.0,
     and specifies the load factor of the hash table which triggers
     enlarging.

     Non-standard keyword `:weakness' can be `nil' (default), `t',
     `key-and-value', `key', `value' or `key-or-value'.  `t' is an
     alias for `key-and-value'.

     A key-and-value-weak hash table, also known as a fully-weak or
     simply as a weak hash table, is one whose pointers do not count as
     GC referents: for any key-value pair in the hash table, if the only
     remaining pointer to either the key or the value is in a weak hash
     table, then the pair will be removed from the hash table, and the
     key and value collected.  A non-weak hash table (or any other
     pointer) would prevent the object from being collected.

     A key-weak hash table is similar to a fully-weak hash table except
     that a key-value pair will be removed only if the key remains
     unmarked outside of weak hash tables.  The pair will remain in the
     hash table if the key is pointed to by something other than a weak
     hash table, even if the value is not.

     A value-weak hash table is similar to a fully-weak hash table
     except that a key-value pair will be removed only if the value
     remains unmarked outside of weak hash tables.  The pair will
     remain in the hash table if the value is pointed to by something
     other than a weak hash table, even if the key is not.

     A key-or-value-weak hash table is similar to a fully-weak hash
     table except that a key-value pair will be removed only if the
     value and the key remain unmarked outside of weak hash tables.
     The pair will remain in the hash table if the value or key are
     pointed to by something other than a weak hash table, even if the
     other is not.

 - Function: copy-hash-table hash-table
     This function returns a new hash table which contains the same
     keys and values as HASH-TABLE.  The keys and values will not
     themselves be copied.

 - Function: hash-table-count hash-table
     This function returns the number of entries in HASH-TABLE.

 - Function: hash-table-test hash-table
     This function returns the test function of HASH-TABLE.  This can
     be one of `eq', `eql' or `equal'.

 - Function: hash-table-size hash-table
     This function returns the current number of slots in HASH-TABLE,
     whether occupied or not.

 - Function: hash-table-rehash-size hash-table
     This function returns the current rehash size of HASH-TABLE.  This
     is a float greater than 1.0; the factor by which HASH-TABLE is
     enlarged when the rehash threshold is exceeded.

 - Function: hash-table-rehash-threshold hash-table
     This function returns the current rehash threshold of HASH-TABLE.
     This is a float between 0.0 and 1.0; the maximum "load factor" of
     HASH-TABLE, beyond which the HASH-TABLE is enlarged by rehashing.

 - Function: hash-table-weakness hash-table
     This function returns the weakness of HASH-TABLE.  This can be one
     of `nil', `t', `key' or `value'.

