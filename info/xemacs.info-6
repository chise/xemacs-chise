This is ../info/xemacs.info, produced by makeinfo version 3.12s from
xemacs/xemacs.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* XEmacs: (xemacs).		XEmacs Editor.
END-INFO-DIR-ENTRY

   This file documents the XEmacs editor.

   Copyright (C) 1985, 1986, 1988 Richard M. Stallman.  Copyright (C)
1991, 1992, 1993, 1994 Lucid, Inc.  Copyright (C) 1993, 1994 Sun
Microsystems, Inc.  Copyright (C) 1995 Amdahl Corporation.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the author instead of in the original English.


File: xemacs.info,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

Regular Expression Search
=========================

   A "regular expression" ("regexp", for short) is a pattern that
denotes a set of strings, possibly an infinite set.  Searching for
matches for a regexp is a powerful operation that editors on Unix
systems have traditionally offered.  In XEmacs, you can search for the
next match for a regexp either incrementally or not.

   Incremental search for a regexp is done by typing `M-C-s'
(`isearch-forward-regexp').  This command reads a search string
incrementally just like `C-s', but it treats the search string as a
regexp rather than looking for an exact match against the text in the
buffer.  Each time you add text to the search string, you make the
regexp longer, and the new regexp is searched for.  A reverse regexp
search command `isearch-backward-regexp' also exists, but no key runs
it.

   All of the control characters that do special things within an
ordinary incremental search have the same functionality in incremental
regexp search.  Typing `C-s' or `C-r' immediately after starting a
search retrieves the last incremental search regexp used: incremental
regexp and non-regexp searches have independent defaults.

   Non-incremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke them with
`M-x' or bind them to keys.  You can also call `re-search-forward' by
way of incremental regexp search with `M-C-s <RET>'.


File: xemacs.info,  Node: Regexps,  Next: Search Case,  Prev: Regexp Search,  Up: Search

Syntax of Regular Expressions
=============================

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that character and nothing
else.  The special characters are `$', `^', `.', `*', `+', `?', `[',
`]' and `\'; no new special characters will be defined.  Any other
character appearing in a regular expression is ordinary, unless a `\'
precedes it.

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does not match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, you can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  To do something nontrivial, you need to use one of the
following special characters:

`. (Period)'
     is a special character that matches any single character except a
     newline.  Using concatenation, you can make regular expressions
     like `a.b', which matches any three-character string which begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a suffix, which means the
     preceding regular expression is to be repeated as many times as
     possible.  In `fo*', the `*' applies to the `o', so `fo*' matches
     one `f' followed by any number of `o's.  The case of zero `o's is
     allowed: `fo*' does match `f'.

     `*' always applies to the smallest possible preceding expression.
     Thus, `fo*' has a repeating `o', not a repeating `fo'.

     The matcher processes a `*' construct by immediately matching as
     many repetitions as it can find.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the `*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     matching `ca*ar' against the string `caaar', the `a*' first tries
     to match all three `a's; but the rest of the pattern is `ar' and
     there is only `r' left to match, so this try fails.  The next
     alternative is for `a*' to match only two `a's.  With this choice,
     the rest of the regexp matches successfully.

`+'
     is a suffix character similar to `*' except that it requires that
     the preceding expression be matched at least once.  For example,
     `ca+r' will match the strings `car' and `caaaar' but not the
     string `cr', whereas `ca*r' would match all three strings.

`?'
     is a suffix character similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' will match `car' or `cr'; nothing else.

`[ ... ]'
     `[' begins a "character set", which is terminated by a `]'.  In
     the simplest case, the characters between the two form the set.
     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     You can include character ranges in a character set by writing two
     characters with a `-' between them.  Thus, `[a-z]' matches any
     lower-case letter.  Ranges may be intermixed freely with individual
     characters, as in `[a-z$%.]', which matches any lower-case letter
     or `$', `%', or period.

     Note that inside a character set the usual special characters are
     not special any more.  A completely different set of special
     characters exists inside character sets: `]', `-', and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `---', which is a range containing only `-'.  To
     include `^', make it other than the first character in the set.

`[^ ... ]'
     `[^' begins a "complement character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters except letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (`-' and `]' are not special there).

     Note that a complement character set can match a newline, unless
     newline is mentioned as one of the characters not to match.

`^'
     is a special character that matches the empty string, but only if
     at the beginning of a line in the text being matched.  Otherwise,
     it fails to match anything.  Thus, `^foo' matches a `foo' that
     occurs at the beginning of a line.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `xx*$' matches a string of one `x' or more at the end of a line.

`\'
     does two things: it quotes the special characters (including `\'),
     and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression that matches only `$', and `\[' is a regular expression
     that matches only `[', and so on.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, `*foo' treats `*' as ordinary since there is no
preceding expression on which the `*' can act.  It is poor practice to
depend on this behavior; better to quote the special character anyway,
regardless of where is appears.

   Usually, `\' followed by any character matches only that character.
However, there are several exceptions: characters which, when preceded
by `\', are special constructs.  Such characters are always ordinary
when encountered on their own.  Here is a table of `\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches anything A or B
     matches.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix `*' to
          operate on.  Thus, `ba\(na\)*' matches `bananana', etc., with
          any (zero or more) number of `na' strings.

       3. To mark a matched substring for future reference.


     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature which happens to
     be assigned as a second meaning to the same `\( ... \)' construct
     because in practice there is no conflict between the two meanings.
     Here is an explanation:

`\DIGIT'
     after the end of a `\( ... \)' construct, the matcher remembers the
     beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use `\' followed by
     DIGIT to mean "match the same text matched the DIGIT'th time by the
     `\( ... \)' construct."

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in order that the open-parentheses appear in the regular
     expression.  `\1' through `\9' may be used to refer to the text
     matched by the corresponding `\( ... \)' construct.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

`\`'
     matches the empty string, provided it is at the beginning of the
     buffer.

`\''
     matches the empty string, provided it is at the end of the buffer.

`\b'
     matches the empty string, provided it is at the beginning or end
     of a word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

`\B'
     matches the empty string, provided it is not at the beginning or
     end of a word.

`\<'
     matches the empty string, provided it is at the beginning of a
     word.

`\>'
     matches the empty string, provided it is at the end of a word.

`\w'
     matches any word-constituent character.  The editor syntax table
     determines which characters these are.

`\W'
     matches any character that is not a word-constituent.

`\sCODE'
     matches any character whose syntax is CODE.  CODE is a character
     which represents a syntax code: thus, `w' for word constituent,
     `-' for whitespace, `(' for open-parenthesis, etc.  *Note Syntax::.

`\SCODE'
     matches any character whose syntax is not CODE.

   Here is a complicated regexp used by Emacs to recognize the end of a
sentence together with any whitespace that follows.  It is given in Lisp
syntax to enable you to distinguish the spaces from the tab characters.
In Lisp syntax, the string constant begins and ends with a
double-quote.  `\"' stands for a double-quote as part of the regexp,
`\\' for a backslash as part of the regexp, `\t' for a tab and `\n' for
a newline.

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This regexp contains four parts: a character set matching period, `?'
or `!'; a character set matching close-brackets, quotes or parentheses,
repeated any number of times; an alternative in backslash-parentheses
that matches end-of-line, a tab or two spaces; and a character set
matching whitespace characters, repeated any number of times.


File: xemacs.info,  Node: Search Case,  Next: Replace,  Prev: Regexps,  Up: Search

Searching and Case
==================

   All searches in Emacs normally ignore the case of the text they are
searching through; if you specify searching for `FOO', `Foo' and `foo'
are also considered a match.  Regexps, and in particular character
sets, are included: `[aB]' matches `a' or `A' or `b' or `B'.

   If you want a case-sensitive search, set the variable
`case-fold-search' to `nil'.  Then all letters must match exactly,
including case. `case-fold-search' is a per-buffer variable; altering
it affects only the current buffer, but there is a default value which
you can change as well.  *Note Locals::.  You can also use Case
Sensitive Search from the Options menu on your screen.


File: xemacs.info,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

Replacement Commands
====================

   Global search-and-replace operations are not needed as often in
Emacs as they are in other editors, but they are available.  In
addition to the simple `replace-string' command which is like that
found in most editors, there is a `query-replace' command which asks
you, for each occurrence of a pattern, whether to replace it.

   The replace commands all replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs'.  *Note Expanding
Abbrevs::.

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: xemacs.info,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

Unconditional Replacement
-------------------------

`M-x replace-string <RET> STRING <RET> NEWSTRING <RET>'
     Replace every occurrence of STRING with NEWSTRING.

`M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace every match for REGEXP with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement occurs only after point: if you want to cover the whole
buffer you must go to the beginning first.  By default, all occurrences
up to the end of the buffer are replaced.  To limit replacement to part
of the buffer, narrow to that part of the buffer before doing the
replacement (*note Narrowing::).

   When `replace-string' exits, point is left at the last occurrence
replaced.  The value of point when the `replace-string' command was
issued is remembered on the mark ring; `C-u C-<SPC>' moves back there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.


File: xemacs.info,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

Regexp Replacement
------------------

   `replace-string' replaces exact matches for a single string.  The
similar command `replace-regexp' replaces any match for a specified
pattern.

   In `replace-regexp', the NEWSTRING need not be constant.  It can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire text being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the D'th
parenthesized grouping in REGEXP.  For example,

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

would replace (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

would perform exactly the opposite replacements.  To include a `\' in
the text to replace with, you must give `\\'.


File: xemacs.info,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

Replace Commands and Case
-------------------------

   If the arguments to a replace command are in lower case, the command
preserves case when it makes a replacement.  Thus, the following
command:

     M-x replace-string <RET> foo <RET> bar <RET>

replaces a lower-case `foo' with a lower case `bar', `FOO' with `BAR',
and `Foo' with `Bar'.  If upper-case letters are used in the second
argument, they remain upper-case every time that argument is inserted.
If upper-case letters are used in the first argument, the second
argument is always substituted exactly as given, with no case
conversion.  Likewise, if the variable `case-replace' is set to `nil',
replacement is done without case conversion.  If `case-fold-search' is
set to `nil', case is significant in matching occurrences of `foo' to
replace; also, case conversion of the replacement string is not done.


File: xemacs.info,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

Query Replace
-------------

`M-% STRING <RET> NEWSTRING <RET>'
`M-x query-replace <RET> STRING <RET> NEWSTRING <RET>'
     Replace some occurrences of STRING with NEWSTRING.

`M-x query-replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, you can use `query-replace' instead of `M-%'.
This command finds occurrences of `foo' one by one, displays each
occurrence, and asks you whether to replace it.  A numeric argument to
`query-replace' tells it to consider only occurrences that are bounded
by word-delimiter characters.

   Aside from querying, `query-replace' works just like
`replace-string', and `query-replace-regexp' works just like
`replace-regexp'.

   The things you can type when you are shown an occurrence of STRING
or a match for REGEXP are:

`<SPC>'
     to replace the occurrence with NEWSTRING.  This preserves case,
     just like `replace-string', provided `case-replace' is non-`nil',
     as it normally is.

`<DEL>'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     prompted for another input character.  However, since the
     replacement has already been made, <DEL> and <SPC> are equivalent.
     At this point, you can type `C-r' (see below) to alter the
     replaced text.  To undo the replacement, you can type `C-x u'.
     This exits the `query-replace'.  If you want to do further
     replacement you must use `C-x ESC' to restart (*note Repetition::).

`<ESC>'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the location of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake.
     This works by popping the mark ring.  Only one `^' in a row is
     allowed, because only one previous replacement location is kept
     during `query-replace'.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' and the
     next occurrence will be displayed.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in `C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with `C-M-c' and the next occurrence will be
     displayed.

`C-l'
     to redisplay the screen and then give another answer.

`C-h'
     to display a message summarizing these options, then give another
     answer.

   If you type any other character, Emacs exits the `query-replace', and
executes the character as a command.  To restart the `query-replace',
use `C-x <ESC>', which repeats the `query-replace' because it used the
minibuffer to read its arguments.  *Note C-x ESC: Repetition.


File: xemacs.info,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

Other Search-and-Loop Commands
==============================

   Here are some other commands that find matches for a regular
expression.  They all operate from point to the end of the buffer.

`M-x occur'
     Print each line that follows point and contains a match for the
     specified regexp.  A numeric argument specifies the number of
     context lines to print before and after each matching line; the
     default is none.

     The buffer `*Occur*' containing the output serves as a menu for
     finding occurrences in their original context.  Find an occurrence
     as listed in `*Occur*', position point there, and type `C-c C-c';
     this switches to the buffer that was searched and moves point to
     the original of the same occurrence.

`M-x list-matching-lines'
     Synonym for `M-x occur'.

`M-x count-matches'
     Print the number of matches following point for the specified
     regexp.

`M-x delete-non-matching-lines'
     Delete each line that follows point and does not contain a match
     for the specified regexp.

`M-x delete-matching-lines'
     Delete each line that follows point and contains a match for the
     specified regexp.


File: xemacs.info,  Node: Fixit,  Next: Files,  Prev: Search,  Up: Top

Commands for Fixing Typos
*************************

   This chapter describes commands that are especially useful when you
catch a mistake in your text just after you have made it, or when you
change your mind while composing text on line.

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: xemacs.info,  Node: Kill Errors,  Next: Transpose,  Prev: Fixit,  Up: Fixit

Killing Your Mistakes
=====================

`<DEL>'
     Delete last character (`delete-backward-char').

`M-<DEL>'
     Kill last word (`backward-kill-word').

`C-x <DEL>'
     Kill to beginning of sentence (`backward-kill-sentence').

   The <DEL> character (`delete-backward-char') is the most important
correction command.  When used among graphic (self-inserting)
characters, it can be thought of as canceling the last character typed.

   When your mistake is longer than a couple of characters, it might be
more convenient to use `M-<DEL>' or `C-x <DEL>'.  `M-<DEL>' kills back
to the start of the last word, and `C-x <DEL>' kills back to the start
of the last sentence.  `C-x <DEL>' is particularly useful when you are
thinking of what to write as you type it, in case you change your mind
about phrasing.  `M-<DEL>' and `C-x <DEL>' save the killed text for
`C-y' and `M-y' to retrieve.  *Note Yanking::.

   `M-<DEL>' is often useful even when you have typed only a few
characters wrong, if you know you are confused in your typing and aren't
sure exactly what you typed.  At such a time, you cannot correct with
<DEL> except by looking at the screen to see what you did.  It requires
less thought to kill the whole word and start over.


File: xemacs.info,  Node: Transpose,  Next: Fixing Case,  Prev: Kill Errors,  Up: Fixit

Transposing Text
================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two adjacent characters can be fixed
with the `C-t' command (`transpose-chars').  Normally, `C-t' transposes
the two characters on either side of point.  When given at the end of a
line, `C-t' transposes the last two characters on the line, rather than
transposing the last character of the line with the newline, which
would be useless.  If you catch a transposition error right away, you
can fix it with just `C-t'.  If you catch the error later,  move the
cursor back to between the two transposed characters.  If you
transposed a space with the last character of the word before it, the
word motion commands are a good way of getting there.  Otherwise, a
reverse search (`C-r') is often the best way.  *Note Search::.

   `Meta-t' (`transpose-words') transposes the word before point with
the word after point.  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, `FOO, BAR'
transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing two
expressions (*note Lists::), and `C-x C-t' (`transpose-lines')
exchanges lines.  It works like `M-t' but in determines the division of
the text into syntactic units differently.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, sexp, line)
before or containing point across several other characters (words,
sexps, lines).  For example, `C-u 3 C-t' moves the character before
point forward across three other characters.  This is equivalent to
repeating `C-t' three times.  `C-u - 4 M-t' moves the word before point
backward across four words.  `C-u - C-M-t' would cancel the effect of
plain `C-M-t'.

   A numeric argument of zero transposes the character (word, sexp,
line) ending after point with the one ending after the mark (otherwise a
command with a repeat count of zero would do nothing).


File: xemacs.info,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

Case Conversion
===============

`M-- M-l'
     Convert last word to lower case.  Note that `Meta--' is
     "Meta-minus."

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A  common error is to type words in the wrong case.  Because of this,
the word case-conversion commands `M-l', `M-u', and `M-c' do not move
the cursor when used with a negative argument.  As soon as you see you
have mistyped the last word, you can simply case-convert it and
continue typing.  *Note Case::.


File: xemacs.info,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

Checking and Correcting Spelling
================================

`M-$'
     Check and correct spelling of word (`spell-word').

`M-x spell-buffer'
     Check and correct spelling of each word in the buffer.

`M-x spell-region'
     Check and correct spelling of each word in the region.

`M-x spell-string'
     Check spelling of specified word.

   To check the spelling of the word before point, and optionally
correct it, use the command `M-$' (`spell-word').  This command runs an
inferior process containing the `spell' program to see whether the word
is correct English.  If it is not, it asks you to edit the word (in the
minibuffer) into a corrected spelling, and then performs a
`query-replace' to substitute the corrected spelling for the old one
throughout the buffer.

   If you exit the minibuffer without altering the original spelling, it
means you do not want to do anything to that word.  In that case, the
`query-replace' is not done.

   `M-x spell-buffer' checks each word in the buffer the same way that
`spell-word' does, doing a `query-replace' for every incorrect word if
appropriate.

   `M-x spell-region' is similar to `spell-buffer' but operates only on
the region, not the entire buffer.

   `M-x spell-string' reads a string as an argument and checks whether
that is a correctly spelled English word.  It prints a message giving
the answer in the echo area.


File: xemacs.info,  Node: Files,  Next: Buffers,  Prev: Fixit,  Up: Top

File Handling
*************

   The basic unit of stored data in Unix is the "file".  To edit a file,
you must tell Emacs to examine the file and prepare a buffer containing
a copy of the file's text.  This is called "visiting" the file.  Editing
commands apply directly to text in the buffer; that is, to the copy
inside Emacs.  Your changes appear in the file itself only when you
"save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, and operate on file directories.

* Menu:

* File Names::       How to type and edit file name arguments.
* Visiting::         Visiting a file prepares Emacs to edit the file.
* Saving::           Saving makes your changes permanent.
* Reverting::        Reverting cancels all the changes not saved.
* Auto Save::        Auto Save periodically protects against loss of data.
* Version Control::  Version control systems (RCS and SCCS).
* ListDir::          Listing the contents of a file directory.
* Comparing Files::  Finding where two files differ.
* Dired::            ``Editing'' a directory to delete, rename, etc.
                     the files in it.
* Misc File Ops::    Other things you can do on files.


File: xemacs.info,  Node: File Names,  Next: Visiting,  Prev: Files,  Up: Files

File Names
==========

   Most Emacs commands that operate on a file require you to specify the
file name.  (Saving and reverting are exceptions; the buffer knows which
file name to use for them.)  File names are specified in the minibuffer
(*note Minibuffer::).  "Completion" is available, to make it easier to
specify long file names.  *Note Completion::.

   There is always a "default file name" which is used if you enter an
empty argument by typing just <RET>.  Normally the default file name is
the name of the file visited in the current buffer; this makes it easy
to operate on that file with any of the Emacs file commands.

   Each buffer has a default directory, normally the same as the
directory of the file visited in that buffer.  When Emacs reads a file
name, the default directory is used if you do not specify a directory.
If you specify a directory in a relative fashion, with a name that does
not start with a slash, it is interpreted with respect to the default
directory.  The default directory of the current buffer is kept in the
variable `default-directory', which has a separate value in every
buffer.  The value of the variable should end with a slash.

   For example, if the default file name is `/u/rms/gnu/gnu.tasks' then
the default directory is `/u/rms/gnu/'.  If you type just `foo', which
does not specify a directory, it is short for `/u/rms/gnu/foo'.
`../.login' would stand for `/u/rms/.login'.  `new/foo' would stand for
the filename `/u/rms/gnu/new/foo'.

   The variable `default-directory-alist' takes an alist of major modes
and their opinions on `default-directory' as a Lisp expression to
evaluate.  A resulting value of `nil' is ignored in favor of
`default-directory'.

   You can create a new directory with the function `make-directory',
which takes as an argument a file name string. The current directory is
displayed in the minibuffer when the function is called; you can delete
the old directory name and supply a new directory name. For example, if
the current directory is `/u/rms/gnu', you can delete `gnu' and type
`oryx' and <RET> to create `/u/rms/oryx'.  Removing a directory is
similar to creating one.  To remove a directory, use
`remove-directory'; it takes one argument, a file name string.

   The command `M-x pwd' prints the current buffer's default directory,
and the command `M-x cd' sets it (to a value read using the
minibuffer).  A buffer's default directory changes only when the `cd'
command is used.  A file-visiting buffer's default directory is
initialized to the directory of the file that is visited there.  If a
buffer is created with `C-x b', its default directory is copied from
that of the buffer that was current at the time.

   The default directory name actually appears in the minibuffer when
the minibuffer becomes active to read a file name.  This serves two
purposes: it shows you what the default is, so that you can type a
relative file name and know with certainty what it will mean, and it
allows you to edit the default to specify a different directory.  To
inhibit the insertion of the default directory, set the variable
`insert-default-directory' to `nil'.

   Note that it is legitimate to type an absolute file name after you
enter the minibuffer, ignoring the presence of the default directory
name.  The final minibuffer contents may look invalid, but that is not
so.  *Note Minibuffer File::.

   `$' in a file name is used to substitute environment variables.  For
example, if you have used the shell command `setenv FOO rms/hacks' to
set up an environment variable named `FOO', then you can use
`/u/$FOO/test.c' or `/u/${FOO}/test.c' as an abbreviation for
`/u/rms/hacks/test.c'.  The environment variable name consists of all
the alphanumeric characters after the `$'; alternatively, it may be
enclosed in braces after the `$'.  Note that the `setenv' command
affects Emacs only if done before Emacs is started.

   To access a file with `$' in its name, type `$$'.  This pair is
converted to a single `$' at the same time variable substitution is
performed for single `$'.  The Lisp function that performs the
substitution is called `substitute-in-file-name'.  The substitution is
performed only on filenames read as such using the minibuffer.


File: xemacs.info,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

Visiting Files
==============

`C-x C-f'
     Visit a file (`find-file').

`C-x C-v'
     Visit a different file instead of the one visited last
     (`find-alternate-file').

`C-x 4 C-f'
     Visit a file, in another window (`find-file-other-window').  Don't
     change this window.

`C-x 5 C-f'
     Visit a file, in another frame (`find-file-other-frame').  Don't
     change this window or frame.

   "Visiting" a file means copying its contents into an Emacs buffer so
you can edit it.  Emacs creates a new buffer for each file you visit.
We say that the buffer is visiting the file that it was created to
hold.  Emacs constructs the buffer name from the file name by throwing
away the directory and keeping just the file name.  For example, a file
named `/usr/rms/emacs.tex' is displayed in a buffer named `emacs.tex'.
If a buffer with that name exists, a unique name is constructed by
appending `<2>', `<3>',and so on, using the lowest number that makes a
name that is not already in use.

   Each window's mode line shows the name of the buffer that is being
displayed in that window, so you can always tell what buffer you are
editing.

   The changes you make with Emacs are made in the Emacs buffer.  They
do not take effect in the file that you visit, or any other permanent
place, until you "save" the buffer.  Saving the buffer means that Emacs
writes the current contents of the buffer into its visited file.  *Note
Saving::.

   If a buffer contains changes that have not been saved, the buffer is
said to be "modified".  This is important because it implies that some
changes will be lost if the buffer is not saved.  The mode line displays
two stars near the left margin if the buffer is modified.

   To visit a file, use the command `C-x C-f' (`find-file').  Follow
the command with the name of the file you wish to visit, terminated by a
<RET>.  If you are using XEmacs under X, you can also use the Open...
command from the File menu bar item.

   The file name is read using the minibuffer (*note Minibuffer::), with
defaulting and completion in the standard manner (*note File Names::).
While in the minibuffer, you can abort `C-x C-f' by typing `C-g'.

   `C-x C-f' has completed successfully when text appears on the screen
and a new buffer name appears in the mode line.  If the specified file
does not exist and could not be created or cannot be read, an error
results.  The error message is printed in the echo area, and includes
the name of the file that Emacs was trying to visit.

   If you visit a file that is already in Emacs, `C-x C-f' does not make
another copy.  It selects the existing buffer containing that file.
However, before doing so, it checks that the file itself has not changed
since you visited or saved it last.  If the file has changed, Emacs
prints a warning message.  *Note Simultaneous Editing: Interlocking.

   You can switch to a specific file called out in the current buffer by
calling the function `find-this-file'. By providing a prefix argument,
this function calls `filename-at-point' and switches to a buffer
visiting the file FILENAME. It creates one if none already exists. You
can use this function to edit the file mentioned in the buffer you are
working in or to test if the file exists. You can do that by using the
minibuffer completion after snatching the all or part of the filename.

   If the variable `find-file-use-truenames''s value is non-`nil', a
buffer's visited filename will always be traced back to the real file.
The filename will never be a symbolic link, and there will never be a
symbolic link anywhere in its directory path. In other words, the
`buffer-file-name' and `buffer-file-truename' will be equal.

   If the variable `find-file-compare-truenames' value is non-`nil',
the `find-file' command will check the `buffer-file-truename' of all
visited files when deciding whether a given file is already in a
buffer, instead of just `buffer-file-name'.  If you attempt to visit
another file which is a hard-link or symbolic-link to a file that is
already in a buffer, the existing buffer will be found instead of a
newly created one.

   If you want to create a file, just visit it.  Emacs prints `(New
File)' in the echo area, but in other respects behaves as if you had
visited an existing empty file.  If you make any changes and save them,
the file is created.

   If you visit a nonexistent file unintentionally (because you typed
the wrong file name), use the `C-x C-v' (`find-alternate-file') command
to visit the file you wanted.  `C-x C-v' is similar to `C-x C-f', but
it kills the current buffer (after first offering to save it if it is
modified).  `C-x C-v' is allowed even if the current buffer is not
visiting a file.

   If the file you specify is actually a directory, Dired is called on
that directory (*note Dired::).  To inhibit this, set the variable
`find-file-run-dired' to `nil'; then it is an error to try to visit a
directory.

   `C-x 4 f' (`find-file-other-window') is like `C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before `C-x 4 f' continues to show the
same buffer it was already showing.  If you use this command when only
one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  *Note Windows::.

   `C-x 5 C-f' (`find-file-other-frame') is like `C-x C-f' except that
it creates a new frame in which the file is displayed.

   Use the function `find-this-file-other-window' to edit a file
mentioned in the buffer you are editing or to test if that file exists.
To do this, use the minibuffer completion after snatching the part or
all of the filename. By providing a prefix argument, the function calls
`filename-at-point' and switches you to a buffer visiting the file
FILENAME in another window. The function creates a buffer if none
already exists. This function is similar to `find-file-other-window'.

   There are two hook variables that allow extensions to modify the
operation of visiting files.  Visiting a file that does not exist runs
the functions in the list `find-file-not-found-hooks'; the value of this
variable is expected to be a list of functions which are called one by
one until one of them returns non-`nil'.  Any visiting of a file,
whether extant or not, expects `find-file-hooks' to contain list of
functions and calls them all, one by one.  In both cases the functions
receive no arguments.  Visiting a nonexistent file runs the
`find-file-not-found-hooks' first.


File: xemacs.info,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

Saving Files
============

   "Saving" a buffer in Emacs means writing its contents back into the
file that was visited in the buffer.

`C-x C-s'
     Save the current buffer in its visited file (`save-buffer').

`C-x s'
     Save any or all buffers in their visited files
     (`save-some-buffers').

`M-~'
     Forget that the current buffer has been changed (`not-modified').

`C-x C-w'
     Save the current buffer in a specified file, and record that file
     as the one visited in the buffer (`write-file').

`M-x set-visited-file-name'
     Change file the name under which the current buffer will be saved.

   To save a file and make your changes permanent, type `C-x C-s'
(`save-buffer').  After saving is finished, `C-x C-s' prints a message
such as:

     Wrote /u/rms/gnu/gnu.tasks

If the selected buffer is not modified (no changes have been made in it
since the buffer was created or last saved), Emacs does not save it
because it would have no effect.  Instead, `C-x C-s' prints a message
in the echo area saying:

     (No changes need to be saved)

   The command `C-x s' (`save-some-buffers') can save any or all
modified buffers.  First it asks, for each modified buffer, whether to
save it.  The questions should be answered with `y' or `n'.  `C-x C-c',
the key that kills Emacs, invokes `save-some-buffers' and therefore
asks the same questions.

   If you have changed a buffer and do not want the changes to be saved,
you should take some action to prevent it.  Otherwise, you are liable to
save it by mistake each time you use `save-some-buffers' or a related
command.  One thing you can do is type `M-~' (`not-modified'), which
removes the indication that the buffer is modified.  If you do this,
none of the save commands will believe that the buffer needs to be
saved.  (`~' is often used as a mathematical symbol for `not'; thus
`Meta-~' is `not', metafied.)  You could also use
`set-visited-file-name' (see below) to mark the buffer as visiting a
different file name, not in use for anything important.

   You can also undo all the changes made since the file was visited or
saved, by reading the text from the file again.  This is called
"reverting".  *Note Reverting::.  Alternatively, you can undo all the
changes by repeating the undo command `C-x u'; but this only works if
you have not made more changes than the undo mechanism can remember.

   `M-x set-visited-file-name' alters the name of the file that the
current buffer is visiting.  It prompts you for the new file name in the
minibuffer.  You can also use `set-visited-file-name' on a buffer that
is not visiting a file.  The buffer's name is changed to correspond to
the file it is now visiting unless the new name is already used by a
different buffer; in that case, the buffer name is not changed.
`set-visited-file-name' does not save the buffer in the newly visited
file; it just alters the records inside Emacs so that it will save the
buffer in that file.  It also marks the buffer as "modified" so that
`C-x C-s' will save.

   If you wish to mark a buffer as visiting a different file and save it
right away, use `C-x C-w' (`write-file').  It is precisely equivalent
to `set-visited-file-name' followed by `C-x C-s'.  `C-x C-s' used on a
buffer that is not visiting  a file has the same effect as `C-x C-w';
that is, it reads a file name, marks the buffer as visiting that file,
and saves it there.  The default file name in a buffer that is not
visiting a file is made by combining the buffer name with the buffer's
default directory.

   If Emacs is about to save a file and sees that the date of the latest
version on disk does not match what Emacs last read or wrote, Emacs
notifies you of this fact, because it probably indicates a problem
caused by simultaneous editing and requires your immediate attention.
*Note Simultaneous Editing: Interlocking.

   If the variable `require-final-newline' is non-`nil', Emacs puts a
newline at the end of any file that doesn't already end in one, every
time a file is saved or written.

   Use the hook variable `write-file-hooks' to implement other ways to
write files, and specify things to be done before files are written.
The value of this variable should be a list of Lisp functions.  When a
file is to be written, the functions in the list are called, one by
one, with no arguments.  If one of them returns a non-`nil' value, Emacs
takes this to mean that the file has been written in some suitable
fashion; the rest of the functions are not called, and normal writing is
not done. Use the hook variable `after-save-hook' to list all the
functions to be called after writing out a buffer to a file.

* Menu:

* Backup::       How Emacs saves the old version of your file.
* Interlocking:: How Emacs protects against simultaneous editing
                  of one file by two users.


File: xemacs.info,  Node: Backup,  Next: Interlocking,  Prev: Saving,  Up: Saving

Backup Files
------------

   Because Unix does not provide version numbers in file names,
rewriting a file in Unix automatically destroys all record of what the
file used to contain.  Thus, saving a file from Emacs throws away the
old contents of the file--or it would, except that Emacs carefully
copies the old contents to another file, called the "backup" file,
before actually saving.  (Make sure that the variable
`make-backup-files' is non-`nil'.  Backup files are not written if this
variable is `nil').

   At your option, Emacs can keep either a single backup file or a
series of numbered backup files for each file you edit.

   Emacs makes a backup for a file only the first time a file is saved
from one buffer.  No matter how many times you save a file, its backup
file continues to contain the contents from before the file was visited.
Normally this means that the backup file contains the contents from
before the current editing session; however, if you kill the buffer and
then visit the file again, a new backup file is made by the next save.

* Menu:

* Names: Backup Names.		How backup files are named;
				Choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.


File: xemacs.info,  Node: Backup Names,  Next: Backup Deletion,  Prev: Backup,  Up: Backup

Single or Numbered Backups
..........................

   If you choose to have a single backup file (the default), the backup
file's name is constructed by appending `~' to the file name being
edited; thus, the backup file for `eval.c' is `eval.c~'.

   If you choose to have a series of numbered backup files, backup file
names are made by appending `.~', the number, and another `~' to the
original file name.  Thus, the backup files of `eval.c' would be called
`eval.c.~1~', `eval.c.~2~', and so on, through names like
`eval.c.~259~' and beyond.

   If protection stops you from writing backup files under the usual
names, the backup file is written as `%backup%~' in your home directory.
Only one such file can exist, so only the most recently made backup is
available.

   The choice of single backup or numbered backups is controlled by the
variable `version-control'.  Its possible values are:

`t'
     Make numbered backups.

`nil'
     Make numbered backups for files that have numbered backups already.
     Otherwise, make single backups.

`never'
     Never make numbered backups; always make single backups.

`version-control' may be set locally in an individual buffer to control
the making of backups for that buffer's file.  For example, Rmail mode
locally sets `version-control' to `never' to make sure that there is
only one backup for an Rmail file.  *Note Locals::.


File: xemacs.info,  Node: Backup Deletion,  Next: Backup Copying,  Prev: Backup Names,  Up: Backup

Automatic Deletion of Backups
.............................

   To prevent unlimited consumption of disk space, Emacs can delete
numbered backup versions automatically.  Generally Emacs keeps the
first few backups and the latest few backups, deleting any in between.
This happens every time a new backup is made.  The two variables that
control the deletion are `kept-old-versions' and `kept-new-versions'.
Their values are, respectively the number of oldest (lowest-numbered)
backups to keep and the number of newest (highest-numbered) ones to
keep, each time a new backup is made.  The values are used just after a
new backup version is made; that newly made backup is included in the
count in `kept-new-versions'.  By default, both variables are 2.

   If `trim-versions-without-asking' is non-`nil',  excess middle
versions are deleted without notification.  If it is `nil', the
default, you are asked whether the excess middle versions should really
be deleted.

   You can also use Dired's `.' (Period) command to delete old versions.
*Note Dired::.

