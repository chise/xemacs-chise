This is ../info/lispref.info, produced by makeinfo version 4.0 from
lispref/lispref.texi.

INFO-DIR-SECTION XEmacs Editor
START-INFO-DIR-ENTRY
* Lispref: (lispref).		XEmacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Edition History:

   GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993 GNU
Emacs Lisp Reference Manual Further Revised (v2.02), August 1993 Lucid
Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995 XEmacs Lisp
Programmer's Manual (for 19.13) Third Edition, July 1995 XEmacs Lisp
Reference Manual (for 19.14 and 20.0) v3.1, March 1996 XEmacs Lisp
Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May,
November 1997 XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.  Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: lispref.info,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Deleting Windows,  Up: Windows

Selecting Windows
=================

   When a window is selected, the buffer in the window becomes the
current buffer, and the cursor will appear in it.

 - Function: selected-window &optional device
     This function returns the selected window.  This is the window in
     which the cursor appears and to which many commands apply.  Each
     separate device can have its own selected window, which is
     remembered as focus changes from device to device.  Optional
     argument DEVICE specifies which device to return the selected
     window for, and defaults to the selected device.

 - Function: select-window window &optional norecord
     This function makes WINDOW the selected window.  The cursor then
     appears in WINDOW (on redisplay).  The buffer being displayed in
     WINDOW is immediately designated the current buffer.

     If optional argument NORECORD is non-`nil' then the global and
     per-frame buffer orderings are not modified, as by the function
     `record-buffer'.

     The return value is WINDOW.

          (setq w (next-window))
          (select-window w)
               => #<window 65 on windows.texi>

 - Macro: save-selected-window forms...
     This macro records the selected window, executes FORMS in
     sequence, then restores the earlier selected window.  It does not
     save or restore anything about the sizes, arrangement or contents
     of windows; therefore, if the FORMS change them, the changes are
     permanent.

   The following functions choose one of the windows on the screen,
offering various criteria for the choice.

 - Function: get-lru-window &optional frame
     This function returns the window least recently "used" (that is,
     selected).  The selected window is always the most recently used
     window.

     The selected window can be the least recently used window if it is
     the only window.  A newly created window becomes the least
     recently used window until it is selected.  A minibuffer window is
     never a candidate.

     The argument FRAME controls which windows are considered.

        * If it is `nil', consider windows on the selected frame.

        * If it is `t', consider windows on all frames.

        * If it is `visible', consider windows on all visible frames.

        * If it is 0, consider windows on all visible or iconified
          frames.

        * If it is a frame, consider windows on that frame.

 - Function: get-largest-window &optional frame
     This function returns the window with the largest area (height
     times width).  If there are no side-by-side windows, then this is
     the window with the most lines.  A minibuffer window is never a
     candidate.

     If there are two windows of the same size, then the function
     returns the window that is first in the cyclic ordering of windows
     (see following section), starting from the selected window.

     The argument FRAME controls which set of windows are considered.
     See `get-lru-window', above.


File: lispref.info,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

Cyclic Ordering of Windows
==========================

   When you use the command `C-x o' (`other-window') to select the next
window, it moves through all the windows on the screen in a specific
cyclic order.  For any given configuration of windows, this order never
varies.  It is called the "cyclic ordering of windows".

   This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the windows were split.

   If the first split was vertical (into windows one above each other),
and then the subwindows were split horizontally, then the ordering is
left to right in the top of the frame, and then left to right in the
next lower part of the frame, and so on.  If the first split was
horizontal, the ordering is top to bottom in the left part, and so on.
In general, within each set of siblings at any level in the window tree,
the order is left to right, or top to bottom.

 - Function: next-window &optional window minibuf all-frames
     This function returns the window following WINDOW in the cyclic
     ordering of windows.  This is the window that `C-x o' would select
     if typed when WINDOW is selected.  If WINDOW is the only window
     visible, then this function returns WINDOW.  If omitted, WINDOW
     defaults to the selected window.

     The value of the argument MINIBUF determines whether the
     minibuffer is included in the window order.  Normally, when
     MINIBUF is `nil', the minibuffer is included if it is currently
     active; this is the behavior of `C-x o'.  (The minibuffer window
     is active while the minibuffer is in use.  *Note Minibuffers::.)

     If MINIBUF is `t', then the cyclic ordering includes the
     minibuffer window even if it is not active.

     If MINIBUF is neither `t' nor `nil', then the minibuffer window is
     not included even if it is active.

     The argument ALL-FRAMES specifies which frames to consider.  Here
     are the possible values and their meanings:

    `nil'
          Consider all the windows in WINDOW's frame, plus the
          minibuffer used by that frame even if it lies in some other
          frame.

    `t'
          Consider all windows in all existing frames.

    `visible'
          Consider all windows in all visible frames.  (To get useful
          results, you must ensure WINDOW is in a visible frame.)

    0
          Consider all windows in all visible or iconified frames.

    anything else
          Consider precisely the windows in WINDOW's frame, and no
          others.

     This example assumes there are two windows, both displaying the
     buffer `windows.texi':

          (selected-window)
               => #<window 56 on windows.texi>
          (next-window (selected-window))
               => #<window 52 on windows.texi>
          (next-window (next-window (selected-window)))
               => #<window 56 on windows.texi>

 - Function: previous-window &optional window minibuf all-frames
     This function returns the window preceding WINDOW in the cyclic
     ordering of windows.  The other arguments specify which windows to
     include in the cycle, as in `next-window'.

 - Command: other-window count &optional frame
     This function selects the COUNTth following window in the cyclic
     order.  If count is negative, then it selects the -COUNTth
     preceding window.  It returns `nil'.

     In an interactive call, COUNT is the numeric prefix argument.

     The argument FRAME controls which set of windows are considered.
        * If it is `nil' or omitted, then windows on the selected frame
          are considered.

        * If it is a frame, then windows on that frame are considered.

        * If it is `t', then windows on all frames that currently exist
          (including invisible and iconified frames) are considered.

        * If it is the symbol `visible', then windows on all visible
          frames are considered.

        * If it is the number 0, then windows on all visible and
          iconified frames are considered.

        * If it is any other value, then the behavior is undefined.

 - Function: walk-windows proc &optional minibuf all-frames
     This function cycles through all windows, calling `proc' once for
     each window with the window as its sole argument.

     The optional arguments MINIBUF and ALL-FRAMES specify the set of
     windows to include in the scan.  See `next-window', above, for
     details.


File: lispref.info,  Node: Buffers and Windows,  Next: Displaying Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

Buffers and Windows
===================

   This section describes low-level functions to examine windows or to
display buffers in windows in a precisely controlled fashion.  *Note
Displaying Buffers::, for related functions that find a window to use
and specify a buffer for it.  The functions described there are easier
to use than these, but they employ heuristics in choosing or creating a
window; use these functions when you need complete control.

 - Function: set-window-buffer window buffer-or-name
     This function makes WINDOW display BUFFER-OR-NAME as its contents.
     It returns `nil'.

          (set-window-buffer (selected-window) "foo")
               => nil

 - Function: window-buffer &optional window
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted, this function returns the buffer for the
     selected window.

          (window-buffer)
               => #<buffer windows.texi>

 - Function: get-buffer-window buffer-or-name &optional frame
     This function returns a window currently displaying
     BUFFER-OR-NAME, or `nil' if there is none.  If there are several
     such windows, then the function returns the first one in the
     cyclic ordering of windows, starting from the selected window.
     *Note Cyclic Window Ordering::.

     The argument ALL-FRAMES controls which windows to consider.

        * If it is `nil', consider windows on the selected frame.

        * If it is `t', consider windows on all frames.

        * If it is `visible', consider windows on all visible frames.

        * If it is 0, consider windows on all visible or iconified
          frames.

        * If it is a frame, consider windows on that frame.


File: lispref.info,  Node: Displaying Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

Displaying Buffers in Windows
=============================

   In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.  *Note Buffers and Windows::, for low-level functions that give
you more precise control.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which is gratuitous and will surprise the user.  Instead, use
`set-buffer' (*note Current Buffer::) and `save-excursion' (*note
Excursions::), which designate buffers as current for programmed access
without affecting the display of buffers in windows.

 - Command: switch-to-buffer buffer-or-name &optional norecord
     This function makes BUFFER-OR-NAME the current buffer, and also
     displays the buffer in the selected window.  This means that a
     human can see the buffer and subsequent keyboard commands will
     apply to it.  Contrast this with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer but does not display it in the
     selected window.  *Note Current Buffer::.

     If BUFFER-OR-NAME does not identify an existing buffer, then a new
     buffer by that name is created.  The major mode for the new buffer
     is set according to the variable `default-major-mode'.  *Note Auto
     Major Mode::.

     Normally the specified buffer is put at the front of the buffer
     list.  This affects the operation of `other-buffer'.  However, if
     NORECORD is non-`nil', this is not done.  *Note The Buffer List::.

     The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.
     It always returns `nil'.

 - Command: switch-to-buffer-other-window buffer-or-name
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in a window not currently selected.  It then selects that
     window.  The handling of the buffer is the same as in
     `switch-to-buffer'.

     The currently selected window is absolutely never used to do the
     job.  If it is the only window, then it is split to make a
     distinct window for this purpose.  If the selected window is
     already displaying the buffer, then it continues to do so, but
     another window is nonetheless found to display it in as well.

 - Function: pop-to-buffer buffer-or-name &optional other-window
          on-frame
     This function makes BUFFER-OR-NAME the current buffer and switches
     to it in some window, preferably not the window previously
     selected.  The "popped-to" window becomes the selected window
     within its frame.

     If the variable `pop-up-frames' is non-`nil', `pop-to-buffer'
     looks for a window in any visible frame already displaying the
     buffer; if there is one, it returns that window and makes it be
     selected within its frame.  If there is none, it creates a new
     frame and displays the buffer in it.

     If `pop-up-frames' is `nil', then `pop-to-buffer' operates
     entirely within the selected frame.  (If the selected frame has
     just a minibuffer, `pop-to-buffer' operates within the most
     recently selected frame that was not just a minibuffer.)

     If the variable `pop-up-windows' is non-`nil', windows may be
     split to create a new window that is different from the original
     window.  For details, see *Note Choosing Window::.

     If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil', then
     the selected window is considered sufficient display for
     BUFFER-OR-NAME, so that nothing needs to be done.

     All the variables that affect `display-buffer' affect
     `pop-to-buffer' as well.  *Note Choosing Window::.

     If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.  The major mode for the
     new buffer is set according to the variable `default-major-mode'.
     *Note Auto Major Mode::.

     If ON-FRAME is non-`nil', it is the frame to pop to this buffer on.

     An example use of this function is found at the end of *Note
     Filter Functions::.

 - Command: replace-buffer-in-windows buffer
     This function replaces BUFFER with some other buffer in all
     windows displaying it.  The other buffer used is chosen with
     `other-buffer'.  In the usual applications of this function, you
     don't care which other buffer is used; you just want to make sure
     that BUFFER is no longer displayed.

     This function returns `nil'.


File: lispref.info,  Node: Choosing Window,  Next: Window Point,  Prev: Displaying Buffers,  Up: Windows

Choosing a Window for Display
=============================

   This section describes the basic facility that chooses a window to
display a buffer in--`display-buffer'.  All the higher-level functions
and commands use this subroutine.  Here we describe how to use
`display-buffer' and how to customize it.

 - Command: display-buffer buffer-or-name &optional not-this-window
     This command makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The identity of the selected window is
     unaltered by this function.

     If NOT-THIS-WINDOW is non-`nil', it means to display the specified
     buffer in a window other than the selected one, even if it is
     already on display in the selected window.  This can cause the
     buffer to appear in two windows at once.  Otherwise, if
     BUFFER-OR-NAME is already being displayed in any window, that is
     good enough, so this function does nothing.

     `display-buffer' returns the window chosen to display
     BUFFER-OR-NAME.

     Precisely how `display-buffer' finds or creates a window depends on
     the variables described below.

   A window can be marked as "dedicated" to a particular buffer.  Then
XEmacs will not automatically change which buffer appears in the
window, such as `display-buffer' might normally do.

 - Function: window-dedicated-p window
     This function returns WINDOW's dedicated object, usually `t' or
     `nil'.

 - Function: set-window-buffer-dedicated window buffer
     This function makes WINDOW display BUFFER and be dedicated to that
     buffer.  Then XEmacs will not automatically change which buffer
     appears in WINDOW.  If BUFFER is `nil', this function makes WINDOW
     not be dedicated (but doesn't change which buffer appears in it
     currently).

 - User Option: pop-up-windows
     This variable controls whether `display-buffer' makes new windows.
     If it is non-`nil' and there is only one window, then that window
     is split.  If it is `nil', then `display-buffer' does not split
     the single window, but uses it whole.

 - User Option: split-height-threshold
     This variable determines when `display-buffer' may split a window,
     if there are multiple windows.  `display-buffer' always splits the
     largest window if it has at least this many lines.  If the largest
     window is not this tall, it is split only if it is the sole window
     and `pop-up-windows' is non-`nil'.

 - User Option: pop-up-frames
     This variable controls whether `display-buffer' makes new frames.
     If it is non-`nil', `display-buffer' looks for an existing window
     already displaying the desired buffer, on any visible frame.  If
     it finds one, it returns that window.  Otherwise it makes a new
     frame.  The variables `pop-up-windows' and
     `split-height-threshold' do not matter if `pop-up-frames' is
     non-`nil'.

     If `pop-up-frames' is `nil', then `display-buffer' either splits a
     window or reuses one.

     *Note Frames::, for more information.

 - Variable: pop-up-frame-function
     This variable specifies how to make a new frame if `pop-up-frames'
     is non-`nil'.

     Its value should be a function of no arguments.  When
     `display-buffer' makes a new frame, it does so by calling that
     function, which should return a frame.  The default value of the
     variable is a function that creates a frame using properties from
     `pop-up-frame-plist'.

 - Variable: pop-up-frame-plist
     This variable holds a plist specifying frame properties used when
     `display-buffer' makes a new frame.  *Note Frame Properties::, for
     more information about frame properties.

 - Variable: special-display-buffer-names
     A list of buffer names for buffers that should be displayed
     specially.  If the buffer's name is in this list, `display-buffer'
     handles the buffer specially.

     By default, special display means to give the buffer a dedicated
     frame.

     If an element is a list, instead of a string, then the CAR of the
     list is the buffer name, and the rest of the list says how to
     create the frame.  There are two possibilities for the rest of the
     list.  It can be a plist, specifying frame properties, or it can
     contain a function and arguments to give to it.  (The function's
     first argument is always the buffer to be displayed; the arguments
     from the list come after that.)

 - Variable: special-display-regexps
     A list of regular expressions that specify buffers that should be
     displayed specially.  If the buffer's name matches any of the
     regular expressions in this list, `display-buffer' handles the
     buffer specially.

     By default, special display means to give the buffer a dedicated
     frame.

     If an element is a list, instead of a string, then the CAR of the
     list is the regular expression, and the rest of the list says how
     to create the frame.  See above, under
     `special-display-buffer-names'.

 - Variable: special-display-function
     This variable holds the function to call to display a buffer
     specially.  It receives the buffer as an argument, and should
     return the window in which it is displayed.

     The default value of this variable is
     `special-display-popup-frame'.

 - Function: special-display-popup-frame buffer
     This function makes BUFFER visible in a frame of its own.  If
     BUFFER is already displayed in a window in some frame, it makes
     the frame visible and raises it, to use that window.  Otherwise, it
     creates a frame that will be dedicated to BUFFER.

     This function uses an existing window displaying BUFFER whether or
     not it is in a frame of its own; but if you set up the above
     variables in your init file, before BUFFER was created, then
     presumably the window was previously made by this function.

 - User Option: special-display-frame-plist
     This variable holds frame properties for
     `special-display-popup-frame' to use when it creates a frame.

 - Variable: same-window-buffer-names
     A list of buffer names for buffers that should be displayed in the
     selected window.  If the buffer's name is in this list,
     `display-buffer' handles the buffer by switching to it in the
     selected window.

 - Variable: same-window-regexps
     A list of regular expressions that specify buffers that should be
     displayed in the selected window.  If the buffer's name matches
     any of the regular expressions in this list, `display-buffer'
     handles the buffer by switching to it in the selected window.

 - Variable: display-buffer-function
     This variable is the most flexible way to customize the behavior of
     `display-buffer'.  If it is non-`nil', it should be a function
     that `display-buffer' calls to do the work.  The function should
     accept two arguments, the same two arguments that `display-buffer'
     received.  It should choose or create a window, display the
     specified buffer, and then return the window.

     This hook takes precedence over all the other options and hooks
     described above.

   A window can be marked as "dedicated" to its buffer.  Then
`display-buffer' does not try to use that window.

 - Function: window-dedicated-p window
     This function returns `t' if WINDOW is marked as dedicated;
     otherwise `nil'.

 - Function: set-window-dedicated-p window flag
     This function marks WINDOW as dedicated if FLAG is non-`nil', and
     nondedicated otherwise.


File: lispref.info,  Node: Window Point,  Next: Window Start,  Prev: Choosing Window,  Up: Windows

Windows and Point
=================

   Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

   * The window point is established when a window is first created; it
     is initialized from the buffer's point, or from the window point
     of another window opened on the buffer if such a window exists.

   * Selecting a window sets the value of point in its buffer to the
     window's value of point.  Conversely, deselecting a window sets
     the window's value of point from that of the buffer.  Thus, when
     you switch between windows that display a given buffer, the point
     value for the selected window is in effect in the buffer, while
     the point values for the other windows are stored in those windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

   * *Note Positions::, for more details on buffer positions.

   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 - Function: window-point window
     This function returns the current position of point in WINDOW.
     For a nonselected window, this is the value point would have (in
     that window's buffer) if that window were selected.

     When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as point in that
     buffer.

     Strictly speaking, it would be more correct to return the
     "top-level" value of point, outside of any `save-excursion' forms.
     But that value is hard to find.

 - Function: set-window-point window position
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.


File: lispref.info,  Node: Window Start,  Next: Vertical Scrolling,  Prev: Window Point,  Up: Windows

The Window Start Position
=========================

   Each window contains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the "display-start" position of the window (or just the
"start").  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

 - Function: window-start &optional window
     This function returns the display-start position of window WINDOW.
     If WINDOW is `nil', the selected window is used.  For example,

          (window-start)
               => 7058

     When you create a window, or display a different buffer in it, the
     display-start position is set to a display-start position recently
     used for the same buffer, or 1 if the buffer doesn't have any.

     For a realistic example, see the description of `count-lines' in
     *Note Text Lines::.

 - Function: window-end &optional window
     This function returns the position of the end of the display in
     window WINDOW.  If WINDOW is `nil', the selected window is used.

     Simply changing the buffer text or moving point does not update the
     value that `window-end' returns.  The value is updated only when
     Emacs redisplays and redisplay actually finishes.

     If the last redisplay of WINDOW was preempted, and did not finish,
     Emacs does not know the position of the end of display in that
     window.  In that case, this function returns a value that is not
     correct.  In a future version, `window-end' will return `nil' in
     that case.

 - Function: set-window-start window position &optional noforce
     This function sets the display-start position of WINDOW to
     POSITION in WINDOW's buffer.  It returns POSITION.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the
     start position with this function using `nil' for NOFORCE, it
     means you want display to start at POSITION even if that would put
     the location of point off the screen.  If this does place point
     off screen, the display routines move point to the left margin on
     the middle line in the window.

     For example, if point is 1 and you set the start of the window
     to 2, then point would be "above" the top of the window.  The
     display routines will automatically move point if it is still 1
     when redisplay occurs.  Here is an example:

          ;; Here is what `foo' looks like before executing
          ;;   the `set-window-start' expression.
          
          ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------
          
          (set-window-start
           (selected-window)
           (1+ (window-start)))
          => 2
          
          ;; Here is what `foo' looks like after executing
          ;;   the `set-window-start' expression.
          ---------- Buffer: foo ----------
          his is the contents of buffer foo.
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------

     If NOFORCE is non-`nil', and POSITION would place point off screen
     at the next redisplay, then redisplay computes a new window-start
     position that works well with point, and thus POSITION is not used.

 - Function: pos-visible-in-window-p &optional position window
     This function returns `t' if POSITION is within the range of text
     currently visible on the screen in WINDOW.  It returns `nil' if
     POSITION is scrolled vertically out of view.  The argument
     POSITION defaults to the current position of point; WINDOW, to the
     selected window.  Here is an example:

          (or (pos-visible-in-window-p
               (point) (selected-window))
              (recenter 0))

     The `pos-visible-in-window-p' function considers only vertical
     scrolling.  If POSITION is out of view only because WINDOW has
     been scrolled horizontally, `pos-visible-in-window-p' returns `t'.
     *Note Horizontal Scrolling::.


File: lispref.info,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Window Start,  Up: Windows

Vertical Scrolling
==================

   Vertical scrolling means moving the text up or down in a window.  It
works by changing the value of the window's display-start location.  It
may also change the value of `window-point' to keep it on the screen.

   In the commands `scroll-up' and `scroll-down', the directions "up"
and "down" refer to the motion of the text in the buffer at which you
are looking through the window.  Imagine that the text is written on a
long roll of paper and that the scrolling commands move the paper up
and down.  Thus, if you are looking at text in the middle of a buffer
and repeatedly call `scroll-down', you will eventually see the
beginning of the buffer.

   Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
"down" commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

   The scrolling functions (aside from `scroll-other-window') have
unpredictable results if the current buffer is different from the buffer
that is displayed in the selected window.  *Note Current Buffer::.

 - Command: scroll-up &optional count
     This function scrolls the text in the selected window upward COUNT
     lines.  If COUNT is negative, scrolling is actually downward.

     If COUNT is `nil' (or omitted), then the length of scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its modeline).

     `scroll-up' returns `nil'.

 - Command: scroll-down &optional count
     This function scrolls the text in the selected window downward
     COUNT lines.  If COUNT is negative, scrolling is actually upward.

     If COUNT is omitted or `nil', then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-down' returns `nil'.

 - Command: scroll-other-window &optional count
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or `nil', are handled as in
     `scroll-up'.

     You can specify a buffer to scroll with the variable
     `other-window-scroll-buffer'.  When the selected window is the
     minibuffer, the next window is normally the one at the top left
     corner.  You can specify a different window to scroll with the
     variable `minibuffer-scroll-window'.  This variable has no effect
     when any other window is selected.  *Note Minibuffer Misc::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, `scroll-other-window' attempts to scroll the minibuffer.  If
     the minibuffer contains just one line, it has nowhere to scroll
     to, so the line reappears after the echo area momentarily displays
     the message "Beginning of buffer".

 - Variable: other-window-scroll-buffer
     If this variable is non-`nil', it tells `scroll-other-window'
     which buffer to scroll.

 - User Option: scroll-step
     This variable controls how scrolling is done automatically when
     point moves off the screen.  If the value is zero, then redisplay
     scrolls the text to center point vertically in the window.  If the
     value is a positive integer N, then redisplay brings point back on
     screen by scrolling N lines in either direction, if possible;
     otherwise, it centers point.  The default value is zero.

 - User Option: scroll-conservatively
     This variable controls how many lines Emacs tries to scroll before
     recentering.  If you set it to a small number, then when you move
     point a short distance off the screen, XEmacs will scroll the
     screen just far enough to bring point back on screen, provided
     that does not exceed `scroll-conservatively' lines.  This variable
     overrides the redisplay preemption.

 - User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity to
     retain when scrolling by full screens.  For example, `scroll-up'
     with an argument of `nil' scrolls so that this many lines at the
     bottom of the window appear instead at the top.  The default value
     is `2'.

 - Command: recenter &optional count
     This function scrolls the selected window to put the text where
     point is located at a specified vertical position within the
     window.

     If COUNT is a nonnegative number, it puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is a
     negative number, then it counts upward from the bottom of the
     window, so that -1 stands for the last usable line in the window.
     If COUNT is a non-`nil' list, then it stands for the line in the
     middle of the window.

     If COUNT is `nil', `recenter' puts the line containing point in
     the middle of the window, then clears and redisplays the entire
     selected frame.

     When `recenter' is called interactively, COUNT is the raw prefix
     argument.  Thus, typing `C-u' as the prefix sets the COUNT to a
     non-`nil' list, while typing `C-u 4' sets COUNT to 4, which
     positions the current line four lines from the top.

     With an argument of zero, `recenter' positions the current line at
     the top of the window.  This action is so handy that some people
     make a separate key binding to do this.  For example,

          (defun line-to-top-of-window ()
            "Scroll current line to top of window.
          Replaces three keystroke sequence C-u 0 C-l."
            (interactive)
            (recenter 0))
          
          (global-set-key [kp-multiply] 'line-to-top-of-window)


File: lispref.info,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

Horizontal Scrolling
====================

   Because we read English first from top to bottom and second from left
to right, horizontal scrolling is not like vertical scrolling.  Vertical
scrolling involves selection of a contiguous portion of text to display.
Horizontal scrolling causes part of each line to go off screen.  The
amount of horizontal scrolling is therefore specified as a number of
columns rather than as a position in the buffer.  It has nothing to do
with the display-start position returned by `window-start'.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the
screen to be revealed by it; so this is not allowed.  Scrolling to the
left is allowed; it scrolls the first columns of text off the edge of
the window and can reveal additional columns on the right that were
truncated before.  Once a window has a nonzero amount of leftward
horizontal scrolling, you can scroll it back to the right, but only so
far as to reduce the net horizontal scroll to zero.  There is no limit
to how far left you can scroll, but eventually all the text will
disappear off the left edge.

 - Command: scroll-left count
     This function scrolls the selected window COUNT columns to the
     left (or to the right if COUNT is negative).  The return value is
     the total amount of leftward horizontal scrolling in effect after
     the change--just like the value returned by `window-hscroll'
     (below).

 - Command: scroll-right count
     This function scrolls the selected window COUNT columns to the
     right (or to the left if COUNT is negative).  The return value is
     the total amount of leftward horizontal scrolling in effect after
     the change--just like the value returned by `window-hscroll'
     (below).

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther right have no effect.

 - Function: window-hscroll &optional window
     This function returns the total leftward horizontal scrolling of
     WINDOW--the number of columns by which the text in WINDOW is
     scrolled left past the left margin.

     The value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

     If WINDOW is `nil', the selected window is used.

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 - Function: set-window-hscroll window columns
     This function sets the number of columns from the left margin that
     WINDOW is scrolled to the value of COLUMNS.  The argument COLUMNS
     should be zero or positive; if not, it is taken as zero.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (defun hscroll-on-screen (window position)
       (save-excursion
         (goto-char position)
         (and
          (>= (- (current-column) (window-hscroll window)) 0)
          (< (- (current-column) (window-hscroll window))
             (window-width window)))))


File: lispref.info,  Node: Size of Window,  Next: Position of Window,  Prev: Horizontal Scrolling,  Up: Windows

The Size of a Window
====================

   An Emacs window is rectangular, and its size information consists of
the height (in lines or pixels) and the width (in character positions
or pixels).  The modeline is included in the height.  The pixel width
and height values include scrollbars and margins, while the
line/character-position values do not.

   Note that the height in lines, and the width in characters, are
determined by dividing the corresponding pixel value by the height or
width of the default font in that window (if this is a variable-width
font, the average width is used).  The resulting values may or may not
represent the actual number of lines in the window, or the actual number
of character positions in any particular line, esp. if there are pixmaps
or various different fonts in the window.

   The following functions return size information about a window:

 - Function: window-height &optional window
     This function returns the number of lines in WINDOW, including its
     modeline but not including the horizontal scrollbar, if any (this
     is different from `window-pixel-height').  If WINDOW is `nil', the
     function uses the selected window.

          (window-height)
               => 40
          (split-window-vertically)
               => #<window on "windows.texi" 0x679b>
          (window-height)
               => 20

 - Function: window-width &optional window
     This function returns the number of columns in WINDOW, not
     including any left margin, right margin, or vertical scrollbar
     (this is different from `window-pixel-width').  If WINDOW is
     `nil', the function uses the selected window.

          (window-width)
               => 80
          (window-height)
               => 40
          (split-window-horizontally)
               => #<window on "windows.texi" 0x7538>
          (window-width)
               => 39

   Note that after splitting the window into two side-by-side windows,
the width of each window is less the half the width of the original
window because a vertical scrollbar appeared between the windows,
occupying two columns worth of space.  Also, the height shrunk by one
because horizontal scrollbars appeared that weren't there before.
(Horizontal scrollbars appear only when lines are truncated, not when
they wrap.  This is usually the case for horizontally split windows but
not for full-frame windows.  You can change this using the variables
`truncate-lines' and `truncate-partial-width-windows'.)

 - Function: window-pixel-height &optional window
     This function returns the height of WINDOW in pixels, including
     its modeline and horizontal scrollbar, if any.  If WINDOW is
     `nil', the function uses the selected window.

          (window-pixel-height)
               => 600
          (split-window-vertically)
               => #<window on "windows.texi" 0x68a6>
          (window-pixel-height)
               => 300

 - Function: window-pixel-width &optional window
     This function returns the width of WINDOW in pixels, including any
     left margin, right margin, or vertical scrollbar that may be
     displayed alongside it.  If WINDOW is `nil', the function uses the
     selected window.

          (window-pixel-width)
               => 735
          (window-pixel-height)
               => 600
          (split-window-horizontally)
               => #<window on "windows.texi" 0x7538>
          (window-pixel-width)
               => 367
          (window-pixel-height)
               => 600

 - Function: window-text-area-pixel-height &optional window
     This function returns the height in pixels of the text displaying
     portion of WINDOW, which defaults to the selected window.  Unlike
     `window-pixel-height', the space occupied by the modeline and
     horizontal scrollbar, if any, is not counted.

 - Function: window-text-area-pixel-width &optional window
     This function returns the width in pixels of the text displaying
     portion of WINDOW, which defaults to the selected window.  Unlike
     `window-pixel-width', the space occupied by the vertical scrollbar
     and divider, if any, is not counted.

 - Function: window-displayed-text-pixel-height &optional window
          noclipped
     This function returns the height in pixels of the text displayed in
     WINDOW, which defaults to the selected window.  Unlike
     `window-text-area-pixel-height', any blank space below the end of
     the buffer is not included.  If optional argument NOCLIPPED is
     non-`nil', any space occupied by clipped lines will not be
     included.


File: lispref.info,  Node: Position of Window,  Next: Resizing Windows,  Prev: Size of Window,  Up: Windows

The Position of a Window
========================

   XEmacs provides functions to determine the absolute location of
windows within a frame, and the relative location of a window in
comparison to other windows in the same frame.

 - Function: window-pixel-edges &optional window
     This function returns a list of the pixel edge coordinates of
     WINDOW.  If WINDOW is `nil', the selected window is used.

     The order of the list is `(LEFT TOP RIGHT BOTTOM)', all elements
     relative to 0, 0 at the top left corner of the frame.  The element
     RIGHT of the value is one more than the rightmost pixel used by
     WINDOW (including any left margin, right margin, or vertical
     scrollbar displayed alongside it), and BOTTOM is one more than the
     bottommost pixel used by WINDOW (including any modeline or
     horizontal scrollbar displayed above or below it).  The frame area
     does not include any frame menubars or toolbars that may be
     displayed; thus, for example, if there is only one window on the
     frame, the values for LEFT and TOP will always be 0.

     If WINDOW is at the upper left corner of its frame, RIGHT and
     BOTTOM are the same as the values returned by
     `(window-pixel-width)' and `(window-pixel-height)' respectively,
     and TOP and BOTTOM are zero.

   There is no longer a function `window-edges' because it does not
make sense in a world with variable-width and variable-height lines, as
are allowed in XEmacs.

 - Function: window-highest-p window
     This function returns non-`nil' if WINDOW is along the top of its
     frame.

 - Function: window-lowest-p window
     This function returns non-`nil' if WINDOW is along the bottom of
     its frame.

 - Function: window-text-area-pixel-edges &optional window
     This function allows one to determine the location of the
     text-displaying portion of WINDOW, which defaults to the selected
     window, with respect to the top left corner of the window.  It
     returns a list of integer pixel positions `(left top right
     bottom)', all relative to `(0,0)' at the top left corner of the
     window.

