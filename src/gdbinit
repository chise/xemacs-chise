# -*- ksh -*-
# Copyright (C) 1998 Free Software Foundation, Inc.

# This file is part of XEmacs.

# XEmacs is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.

# XEmacs is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General Public License
# along with XEmacs; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

# Author: Martin Buchholz

# Some useful commands for debugging emacs with gdb 4.16 or better.
# Install this as your .gdbinit file in your home directory,
# or source this file from your .gdbinit
# Configure xemacs with --debug, and compile with -g.
#
# See also the question of the XEmacs FAQ, titled
# "How to Debug an XEmacs problem with a debugger".
#
# This can be used to debug XEmacs no matter how the following are
# specified:

# USE_UNION_TYPE
# USE_MINIMAL_TAGBITS
# USE_INDEXED_LRECORD_IMPLEMENTATION
# LRECORD_(SYMBOL|STRING|VECTOR)

# (the above all have configure equivalents)

# Some functions defined here require a running process, but most
# don't.  Considerable effort has been expended to this end.

# See the dbg_ C support code in src/alloc.c that allows the functions
# defined in this file to work correctly.

set print union off
set print pretty off

define decode_object
  set $obj = (unsigned long) $arg0
  if dbg_USE_MINIMAL_TAGBITS
    if $obj & 1
    # It's an int
      set $val = $obj >> 1
      set $type = dbg_Lisp_Type_Int
    else
      set $type = $obj & dbg_typemask
      if $type == dbg_Lisp_Type_Char
        set $val = ($obj & dbg_valmask) >> dbg_gctypebits
      else
        # It's a record pointer
        set $val = $obj
      end
    end
  else
    # not dbg_USE_MINIMAL_TAGBITS
    set $val = $obj & dbg_valmask
    set $type = ($obj & dbg_typemask) >> (dbg_valbits + 1)
  end

  if $type == dbg_Lisp_Type_Record
    set $lheader = (struct lrecord_header *) $val
    if dbg_USE_INDEXED_LRECORD_IMPLEMENTATION
      set $imp = lrecord_implementations_table[$lheader->type]
    else
      set $imp = $lheader->implementation
    end
  else
    set $imp = -1
  end
end

document decode_object
Usage: decode_object lisp_object
Extract implementation information from a Lisp Object.
Defines variables $val, $type and $imp.
end

define xint
decode_object $arg0
print ((long) $val)
end

define xtype
  decode_object $arg0
  if $type == dbg_Lisp_Type_Int
    echo int\n
  else
  if $type == dbg_Lisp_Type_Char
    echo char\n
  else
  if $type == dbg_Lisp_Type_Symbol
    echo symbol\n
  else
  if $type == dbg_Lisp_Type_String
    echo string\n
  else
  if $type == dbg_Lisp_Type_Vector
    echo vector\n
  else
  if $type == dbg_Lisp_Type_Cons
    echo cons\n
  else
    printf "record type: %s\n", $imp->name
  # barf
  end
  end
  end
  end
  end
  end
end

define run-temacs
  unset env EMACSLOADPATH
  set env EMACSBOOTSTRAPLOADPATH ../lisp/:..
  run -batch -l ../lisp/loadup.el run-temacs -q
end

document run-temacs
Usage: run-temacs
Run temacs interactively, like xemacs.
Use this with debugging tools (like purify) that cannot deal with dumping,
or when temacs builds successfully, but xemacs does not.
end

define update-elc
  unset env EMACSLOADPATH
  set env EMACSBOOTSTRAPLOADPATH ../lisp/:..
  run -batch -l ../lisp/update-elc.el
end

document update-elc
Usage: update-elc
Run the core lisp byte compilation part of the build procedure.
Use when debugging temacs, not xemacs!
Use this when temacs builds successfully, but xemacs does not.
end

define dump-temacs
  unset env EMACSLOADPATH
  set env EMACSBOOTSTRAPLOADPATH ../lisp/:..
  run -batch -l ../lisp/loadup.el dump
end

document dump-temacs
Usage: dump-temacs
Run the dumping part of the build procedure.
Use when debugging temacs, not xemacs!
Use this when temacs builds successfully, but xemacs does not.
end

# if you use Purify, do this:
# export PURIFYOPTIONS='-pointer-mask=0x0fffffff'

define ldp
  printf "%s", "Lisp => "
  call debug_print($arg0)
end

document ldp
Usage: ldp lisp_object
Print a Lisp Object value using the Lisp printer.
Requires a running xemacs process.
end

define lbt
call debug_backtrace()
end

document lbt
Usage: lbt
Print the current Lisp stack trace.
Requires a running xemacs process.
end

define wtype
print $arg0->core.widget_class->core_class.class_name
end

define xtname
print XrmQuarkToString(((Object)($arg0))->object.xrm_name)
end

# GDB's command language makes you want to ...

define pstruct
  set $xstruct = (struct $arg0 *) $val
  print $xstruct
  print *$xstruct
end

define pobj
  decode_object $arg0
  if $type == dbg_Lisp_Type_Int
    printf "Integer: %d\n", $val
  else
  if $type == dbg_Lisp_Type_Char
    if $val < 128
      printf "Char: %c\n", $val
    else
      printf "Char: %d\n", $val
    end
  else
  if $type == dbg_Lisp_Type_String || $imp == lrecord_string
    pstruct Lisp_String
  else
  if $type == dbg_Lisp_Type_Cons   || $imp == lrecord_cons
    pstruct Lisp_Cons
  else
  if $type == dbg_Lisp_Type_Symbol || $imp == lrecord_symbol
    pstruct Lisp_Symbol
    printf "Symbol name: %s\n", $xstruct->name->data
  else
  if $type == dbg_Lisp_Type_Vector || $imp == lrecord_vector
    pstruct Lisp_Vector
    printf "Vector of length %d\n", $xstruct->size
    #print *($xstruct->data) @ $xstruct->size
  else
  if $imp == lrecord_bit_vector
    pstruct Lisp_Bit_Vector
  else
  if $imp == lrecord_buffer
    pstruct buffer
  else
  if $imp == lrecord_char_table
    pstruct Lisp_Char_Table
  else
  if $imp == lrecord_char_table_entry
    pstruct Lisp_Char_Table_Entry
  else
  if $imp == lrecord_charset
    pstruct Lisp_Charset
  else
  if $imp == lrecord_coding_system
    pstruct Lisp_Coding_System
  else
  if $imp == lrecord_color_instance
    pstruct Lisp_Color_Instance
  else
  if $imp == lrecord_command_builder
    pstruct command_builder
  else
  if $imp == lrecord_compiled_function
    pstruct Lisp_Compiled_Function
  else
  if $imp == lrecord_console
    pstruct console
  else
  if $imp == lrecord_database
    pstruct Lisp_Database
  else
  if $imp == lrecord_device
    pstruct device
  else
  if $imp == lrecord_event
    pstruct Lisp_Event
  else
  if $imp == lrecord_extent
    pstruct extent
  else
  if $imp == lrecord_extent_auxiliary
    pstruct extent_auxiliary
  else
  if $imp == lrecord_extent_info
    pstruct extent_info
  else
  if $imp == lrecord_face
    pstruct Lisp_Face
  else
  if $imp == lrecord_float
    pstruct Lisp_Float
  else
  if $imp == lrecord_font_instance
    pstruct Lisp_Font_Instance
  else
  if $imp == lrecord_frame
    pstruct frame
  else
  if $imp == lrecord_glyph
    pstruct Lisp_Glyph
  else
  if $imp == lrecord_hash_table
    pstruct Lisp_Hash_Table
  else
  if $imp == lrecord_image_instance
    pstruct Lisp_Image_Instance
  else
  if $imp == lrecord_keymap
    pstruct Lisp_Keymap
  else
  if $imp == lrecord_lcrecord_list
    pstruct lcrecord_list
  else
  if $imp == lrecord_lstream
    pstruct lstream
  else
  if $imp == lrecord_marker
    pstruct Lisp_Marker
  else
  if $imp == lrecord_opaque
    pstruct Lisp_Opaque
  else
  if $imp == lrecord_opaque_list
    pstruct Lisp_Opaque_List
  else
  if $imp == lrecord_popup_data
    pstruct popup_data
  else
  if $imp == lrecord_process
    pstruct Lisp_Process
  else
  if $imp == lrecord_range_table
    pstruct Lisp_Range_Table
  else
  if $imp == lrecord_specifier
    pstruct Lisp_Specifier
  else
  if $imp == lrecord_subr
    pstruct Lisp_Subr
  else
  if $imp == lrecord_symbol_value_buffer_local
    pstruct symbol_value_buffer_local
  else
  if $imp == lrecord_symbol_value_forward
    pstruct symbol_value_forward
  else
  if $imp == lrecord_symbol_value_lisp_magic
    pstruct symbol_value_lisp_magic
  else
  if $imp == lrecord_symbol_value_varalias
    pstruct symbol_value_varalias
  else
  if $imp == lrecord_toolbar_button
    pstruct toolbar_button
  else
  if $imp == lrecord_tooltalk_message
    pstruct Lisp_Tooltalk_Message
  else
  if $imp == lrecord_tooltalk_pattern
    pstruct Lisp_Tooltalk_Pattern
  else
  if $imp == lrecord_weak_list
    pstruct weak_list
  else
  if $imp == lrecord_window
    pstruct window
  else
  if $imp == lrecord_window_configuration
    pstruct window_config
  else
    echo Unknown Lisp Object type\n
    print $arg0
  # Barf, gag, retch
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  # Repeat after me... gdb sux, gdb sux, gdb sux...
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  # Are we having fun yet??
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
  end
end

document pobj
Usage: pobj lisp_object
Print the internal C structure of a underlying Lisp Object.
end
